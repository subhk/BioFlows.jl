<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Methods · BioFlows.jl</title><meta name="title" content="Numerical Methods · BioFlows.jl"/><meta property="og:title" content="Numerical Methods · BioFlows.jl"/><meta property="twitter:title" content="Numerical Methods · BioFlows.jl"/><meta name="description" content="Documentation for BioFlows.jl."/><meta property="og:description" content="Documentation for BioFlows.jl."/><meta property="twitter:description" content="Documentation for BioFlows.jl."/><meta property="og:url" content="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><meta property="twitter:url" content="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><link rel="canonical" href="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BioFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../codebase_structure/">Codebase Structure</a></li><li class="is-active"><a class="tocitem" href>Numerical Methods</a><ul class="internal"><li><a class="tocitem" href="#Governing-Equations"><span>Governing Equations</span></a></li><li><a class="tocitem" href="#Staggered-Grid-(MAC-Grid)"><span>Staggered Grid (MAC Grid)</span></a></li><li><a class="tocitem" href="#Extension-to-3D"><span>Extension to 3D</span></a></li><li><a class="tocitem" href="#Finite-Difference-Operators"><span>Finite Difference Operators</span></a></li><li><a class="tocitem" href="#Convection-Diffusion-Discretization"><span>Convection-Diffusion Discretization</span></a></li><li><a class="tocitem" href="#Time-Integration"><span>Time Integration</span></a></li><li><a class="tocitem" href="#Pressure-Solver"><span>Pressure Solver</span></a></li><li><a class="tocitem" href="#Immersed-Boundary-Method-(BDIM)"><span>Immersed Boundary Method (BDIM)</span></a></li><li><a class="tocitem" href="#Flexible-Body-Kinematics"><span>Flexible Body Kinematics</span></a></li><li><a class="tocitem" href="#Fluid-Structure-Interaction-(FSI)"><span>Fluid-Structure Interaction (FSI)</span></a></li><li><a class="tocitem" href="#Boundary-Conditions-3"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../core_types/">Core Types</a></li><li><a class="tocitem" href="../amr/">Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/BioFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/BioFlows.jl/blob/main/docs/src/numerical_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-Methods"><a class="docs-heading-anchor" href="#Numerical-Methods">Numerical Methods</a><a id="Numerical-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Methods" title="Permalink"></a></h1><p>This section describes the numerical methods used in BioFlows.jl for solving the incompressible Navier-Stokes equations.</p><h2 id="Governing-Equations"><a class="docs-heading-anchor" href="#Governing-Equations">Governing Equations</a><a id="Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Governing-Equations" title="Permalink"></a></h2><p>BioFlows.jl solves the incompressible Navier-Stokes equations in dimensional form:</p><p class="math-container">\[\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u}\]</p><p class="math-container">\[\nabla \cdot \mathbf{u} = 0\]</p><p>where:</p><ul><li><p class="math-container">\[\mathbf{u} = (u, v)\]</p>is the velocity field (m/s)</li><li><p class="math-container">\[p\]</p>is the pressure (Pa)</li><li><p class="math-container">\[\rho\]</p>is the density (kg/m³)</li><li><p class="math-container">\[\nu\]</p>is the kinematic viscosity (m²/s)</li></ul><h2 id="Staggered-Grid-(MAC-Grid)"><a class="docs-heading-anchor" href="#Staggered-Grid-(MAC-Grid)">Staggered Grid (MAC Grid)</a><a id="Staggered-Grid-(MAC-Grid)-1"></a><a class="docs-heading-anchor-permalink" href="#Staggered-Grid-(MAC-Grid)" title="Permalink"></a></h2><p>BioFlows.jl uses a <strong>staggered grid</strong> arrangement, also known as a Marker-And-Cell (MAC) grid. This arrangement naturally satisfies the discrete divergence-free condition and avoids spurious pressure oscillations (checkerboard modes).</p><h3 id="Variable-Locations-in-2D"><a class="docs-heading-anchor" href="#Variable-Locations-in-2D">Variable Locations in 2D</a><a id="Variable-Locations-in-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Locations-in-2D" title="Permalink"></a></h3><p>On a staggered grid, different variables are stored at different locations within each cell:</p><ul><li><strong>Pressure</strong> (<span>$p$</span>): Cell centers</li><li><strong>x-velocity</strong> (<span>$u$</span>): Vertical cell faces (between left/right neighbors)</li><li><strong>y-velocity</strong> (<span>$v$</span>): Horizontal cell faces (between bottom/top neighbors)</li></ul><pre><code class="nohighlight hljs">         Δx
    ├─────────────┤

    ┌─────────────┬─────────────┬─────────────┐  ─┬─
    │             │             │             │   │
    │      ●      v      ●      v      ●      │   │
    │    p_i,j+1  │   p_i+1,j+1 │  p_i+2,j+1  │   │
    │             │             │             │   Δy
    u             u             u             u   │
    │             │             │             │   │
    │      ●      v      ●      v      ●      │  ─┴─
    │    p_i,j    │   p_i+1,j   │  p_i+2,j    │
    │             │             │             │
    u             u             u             u
    │             │             │             │
    │      ●      v      ●      v      ●      │
    │   p_i,j-1   │  p_i+1,j-1  │  p_i+2,j-1  │
    │             │             │             │
    └─────────────┴─────────────┴─────────────┘

    Legend:
    ●  = Pressure (p) at cell center
    u  = x-velocity component at vertical faces
    v  = y-velocity component at horizontal faces</code></pre><h3 id="Detailed-Single-Cell-View"><a class="docs-heading-anchor" href="#Detailed-Single-Cell-View">Detailed Single Cell View</a><a id="Detailed-Single-Cell-View-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-Single-Cell-View" title="Permalink"></a></h3><p>For a single cell <span>$(i,j)$</span>, the staggered arrangement is:</p><pre><code class="nohighlight hljs">                    v[i,j+1]
                       ↑
              ┌────────┼────────┐
              │        │        │
              │        │        │
    u[i,j] ───┼───── p[i,j] ────┼─── u[i+1,j]
      →       │        ●        │       →
              │                 │
              │                 │
              └────────┼────────┘
                       │
                       ↓
                    v[i,j]

    Grid spacing: Δx (horizontal), Δy (vertical)
    Cell center:  (i-½, j-½) in grid coordinates
    u location:   (i, j-½) - on left/right faces
    v location:   (i-½, j) - on bottom/top faces</code></pre><h3 id="Indexing-Convention"><a class="docs-heading-anchor" href="#Indexing-Convention">Indexing Convention</a><a id="Indexing-Convention-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-Convention" title="Permalink"></a></h3><p>In BioFlows.jl, the arrays are indexed as follows:</p><table><tr><th style="text-align: right">Variable</th><th style="text-align: right">Array Index</th><th style="text-align: right">Physical Location</th></tr><tr><td style="text-align: right"><code>p[i,j]</code></td><td style="text-align: right">Cell <span>$(i,j)$</span></td><td style="text-align: right">Center of cell <span>$(i,j)$</span></td></tr><tr><td style="text-align: right"><code>u[i,j,1]</code></td><td style="text-align: right">Face <span>$(i,j)$</span></td><td style="text-align: right">Left face of cell <span>$(i,j)$</span></td></tr><tr><td style="text-align: right"><code>u[i,j,2]</code></td><td style="text-align: right">Face <span>$(i,j)$</span></td><td style="text-align: right">Bottom face of cell <span>$(i,j)$</span></td></tr></table><p>The velocity field is stored in a single array <code>u[I,d]</code> where <code>I</code> is the cell index and <code>d</code> is the direction (1=x, 2=y for 2D; 1=x, 2=y, 3=z for 3D).</p><h2 id="Extension-to-3D"><a class="docs-heading-anchor" href="#Extension-to-3D">Extension to 3D</a><a id="Extension-to-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Extension-to-3D" title="Permalink"></a></h2><p>In three dimensions, the staggered grid extends naturally:</p><ul><li><strong>Pressure</strong> (<span>$p$</span>): Cell centers</li><li><strong>x-velocity</strong> (<span>$u$</span>): yz-faces (perpendicular to x)</li><li><strong>y-velocity</strong> (<span>$v$</span>): xz-faces (perpendicular to y)</li><li><strong>z-velocity</strong> (<span>$w$</span>): xy-faces (perpendicular to z)</li></ul><pre><code class="nohighlight hljs">                        z
                        │   y
                        │  /
                        │ /
                        │/
            ────────────┼──────────── x


                    ┌───────────────────┐
                   /│                  /│
                  / │       w_top     / │
                 /  │       ↑        /  │
                ┌───────────────────┐   │
                │   │      ●        │   │
          u_L → │   │    p_ijk      │ → u_R
                │   │               │   │
                │   └ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ┘
                │  /                │  /
                │ /      ↓         │ /
                │/    w_bottom     │/
                └───────────────────┘
                      ↗       ↘
                   v_front   v_back


    Legend:
    ●     = Pressure at cell center (i,j,k)
    u_L   = u[i,j,k,1] at left face
    u_R   = u[i+1,j,k,1] at right face
    v     = v[i,j,k,2] at front/back faces
    w     = w[i,j,k,3] at top/bottom faces</code></pre><h2 id="Finite-Difference-Operators"><a class="docs-heading-anchor" href="#Finite-Difference-Operators">Finite Difference Operators</a><a id="Finite-Difference-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Operators" title="Permalink"></a></h2><h3 id="Divergence"><a class="docs-heading-anchor" href="#Divergence">Divergence</a><a id="Divergence-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence" title="Permalink"></a></h3><p>The discrete divergence operator at cell center <span>$(i,j)$</span>:</p><p class="math-container">\[(\nabla \cdot \mathbf{u})_{i,j} = \frac{u_{i+1,j} - u_{i,j}}{\Delta x} + \frac{v_{i,j+1} - v_{i,j}}{\Delta y}\]</p><h3 id="Gradient"><a class="docs-heading-anchor" href="#Gradient">Gradient</a><a id="Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient" title="Permalink"></a></h3><p>The discrete pressure gradient at face locations:</p><p class="math-container">\[\left(\frac{\partial p}{\partial x}\right)_{i,j} = \frac{p_{i,j} - p_{i-1,j}}{\Delta x} \quad \text{(at u-location)}\]</p><p class="math-container">\[\left(\frac{\partial p}{\partial y}\right)_{i,j} = \frac{p_{i,j} - p_{i,j-1}}{\Delta y} \quad \text{(at v-location)}\]</p><h3 id="Laplacian"><a class="docs-heading-anchor" href="#Laplacian">Laplacian</a><a id="Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Laplacian" title="Permalink"></a></h3><p>The discrete Laplacian for the Poisson equation:</p><p class="math-container">\[\nabla^2 p_{i,j} = \frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{\Delta x^2} + \frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{\Delta y^2}\]</p><h2 id="Convection-Diffusion-Discretization"><a class="docs-heading-anchor" href="#Convection-Diffusion-Discretization">Convection-Diffusion Discretization</a><a id="Convection-Diffusion-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Convection-Diffusion-Discretization" title="Permalink"></a></h2><p>The momentum equation contains convection and diffusion terms that must be carefully discretized on the staggered grid.</p><h3 id="Momentum-Equation"><a class="docs-heading-anchor" href="#Momentum-Equation">Momentum Equation</a><a id="Momentum-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-Equation" title="Permalink"></a></h3><p>For velocity component <span>$u_i$</span>, the semi-discrete momentum equation is:</p><p class="math-container">\[\frac{\partial u_i}{\partial t} = -\sum_j \frac{\partial (u_j u_i)}{\partial x_j} + \nu \sum_j \frac{\partial^2 u_i}{\partial x_j^2} - \frac{1}{\rho}\frac{\partial p}{\partial x_i}\]</p><p>The convection term <span>$\partial(u_j u_i)/\partial x_j$</span> is in <strong>conservative (flux) form</strong>, representing the divergence of momentum flux. This is distinct from the non-conservative form <span>$u_j \partial u_i/\partial x_j$</span>.</p><h3 id="2D-Momentum-Equations-(Conservative-Form)"><a class="docs-heading-anchor" href="#2D-Momentum-Equations-(Conservative-Form)">2D Momentum Equations (Conservative Form)</a><a id="2D-Momentum-Equations-(Conservative-Form)-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Momentum-Equations-(Conservative-Form)" title="Permalink"></a></h3><p>For 2D flow with coordinates <span>$(x, z)$</span> and velocities <span>$(u, w)$</span>:</p><p><strong>x-momentum (u):</strong></p><p class="math-container">\[\frac{\partial u}{\partial t} = -\frac{\partial (uu)}{\partial x} - \frac{\partial (wu)}{\partial z} + \nu\left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial z^2}\right) - \frac{1}{\rho}\frac{\partial p}{\partial x}\]</p><p><strong>z-momentum (w):</strong></p><p class="math-container">\[\frac{\partial w}{\partial t} = -\frac{\partial (uw)}{\partial x} - \frac{\partial (ww)}{\partial z} + \nu\left(\frac{\partial^2 w}{\partial x^2} + \frac{\partial^2 w}{\partial z^2}\right) - \frac{1}{\rho}\frac{\partial p}{\partial z}\]</p><p>The terms <span>$\partial(uu)/\partial x$</span>, <span>$\partial(wu)/\partial z$</span>, <span>$\partial(uw)/\partial x$</span>, and <span>$\partial(ww)/\partial z$</span> are the conservative convective fluxes.</p><h3 id="Finite-Volume-Formulation"><a class="docs-heading-anchor" href="#Finite-Volume-Formulation">Finite Volume Formulation</a><a id="Finite-Volume-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Volume-Formulation" title="Permalink"></a></h3><p>BioFlows.jl uses a <strong>conservative finite volume method (FVM)</strong> where fluxes are computed at cell faces and applied symmetrically to adjacent cells. This ensures exact conservation of momentum.</p><p>For a control volume around velocity <span>$u_i$</span> at location <span>$I$</span>:</p><p class="math-container">\[\frac{d u_i^I}{d t} = \sum_j \left( F_{i,j}^{I} - F_{i,j}^{I-\delta_j} \right)\]</p><p>where <span>$F_{i,j}^I$</span> is the total flux (convective + diffusive) of momentum component <span>$i$</span> through face <span>$j$</span> at index <span>$I$</span>.</p><h3 id="Flux-Computation-at-Cell-Faces"><a class="docs-heading-anchor" href="#Flux-Computation-at-Cell-Faces">Flux Computation at Cell Faces</a><a id="Flux-Computation-at-Cell-Faces-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Computation-at-Cell-Faces" title="Permalink"></a></h3><p>At each face in direction <span>$j$</span>, two fluxes contribute to the momentum balance:</p><h4 id="1.-Convective-Flux"><a class="docs-heading-anchor" href="#1.-Convective-Flux">1. Convective Flux</a><a id="1.-Convective-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Convective-Flux" title="Permalink"></a></h4><p>The convective flux transports momentum with the flow velocity:</p><p class="math-container">\[F_{i,j}^{conv} = \frac{u_j^{face}}{\Delta x_j} \cdot \phi(u_i)\]</p><p>where:</p><ul><li><p class="math-container">\[u_j^{face}\]</p>= face-normal velocity (interpolated to face)</li><li><p class="math-container">\[\phi(u_i)\]</p>= upwind-biased reconstruction of <span>$u_i$</span> at the face</li><li><p class="math-container">\[\Delta x_j\]</p>= grid spacing in direction <span>$j$</span></li></ul><p>The face velocity <span>$u_j^{face}$</span> is computed by interpolation:</p><p class="math-container">\[u_j^{face} = \frac{1}{2}(u_j^L + u_j^R)\]</p><h4 id="2.-Diffusive-Flux"><a class="docs-heading-anchor" href="#2.-Diffusive-Flux">2. Diffusive Flux</a><a id="2.-Diffusive-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Diffusive-Flux" title="Permalink"></a></h4><p>The diffusive flux represents viscous stress:</p><p class="math-container">\[F_{i,j}^{diff} = -\frac{\nu}{\Delta x_j} \left( u_i^I - u_i^{I-\delta_j} \right)\]</p><p>This is a central difference approximation to <span>$-\nu \partial u_i / \partial x_j$</span>.</p><h4 id="Total-Flux"><a class="docs-heading-anchor" href="#Total-Flux">Total Flux</a><a id="Total-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Flux" title="Permalink"></a></h4><p>The total flux at face <span>$I$</span> in direction <span>$j$</span> for momentum component <span>$i$</span>:</p><p class="math-container">\[F_{i,j}^I = F_{i,j}^{conv,I} + F_{i,j}^{diff,I}\]</p><h3 id="Upwind-Schemes-for-Convection"><a class="docs-heading-anchor" href="#Upwind-Schemes-for-Convection">Upwind Schemes for Convection</a><a id="Upwind-Schemes-for-Convection-1"></a><a class="docs-heading-anchor-permalink" href="#Upwind-Schemes-for-Convection" title="Permalink"></a></h3><p>BioFlows.jl implements several upwind schemes for reconstructing face values. Given the stencil values <span>$u_U$</span> (upwind), <span>$u_C$</span> (center), <span>$u_D$</span> (downwind), the schemes compute the face value <span>$\phi$</span>.</p><h4 id="QUICK-with-Median-Limiter"><a class="docs-heading-anchor" href="#QUICK-with-Median-Limiter">QUICK with Median Limiter</a><a id="QUICK-with-Median-Limiter-1"></a><a class="docs-heading-anchor-permalink" href="#QUICK-with-Median-Limiter" title="Permalink"></a></h4><p>BioFlows uses a modified QUICK scheme with a median limiter for stability:</p><p class="math-container">\[\phi_{QUICK} = \text{median}\left( \frac{5u_C + 2u_D - u_U}{6}, \, u_C, \, \text{median}(10u_C - 9u_U, \, u_C, \, u_D) \right)\]</p><p>The median limiter prevents spurious oscillations near discontinuities while maintaining high accuracy in smooth regions. For smooth monotonic profiles, this reduces to the quadratic interpolation <span>$(5u_C + 2u_D - u_U)/6$</span>.</p><p><strong>Code:</strong> <code>quick(u,c,d) = median((5c+2d-u)/6, c, median(10c-9u,c,d))</code></p><h4 id="Van-Leer-(TVD)"><a class="docs-heading-anchor" href="#Van-Leer-(TVD)">Van Leer (TVD)</a><a id="Van-Leer-(TVD)-1"></a><a class="docs-heading-anchor-permalink" href="#Van-Leer-(TVD)" title="Permalink"></a></h4><p>The van Leer scheme uses a monotonicity-preserving limiter:</p><p class="math-container">\[\phi_{vanLeer} = \begin{cases}
u_C &amp; \text{if } u_C \leq \min(u_U, u_D) \text{ or } u_C \geq \max(u_U, u_D) \\
u_C + (u_D - u_C) \cdot \frac{u_C - u_U}{u_D - u_U} &amp; \text{otherwise}
\end{cases}\]</p><p>This ensures the interpolated value lies between neighboring values, preventing oscillations.</p><p><strong>Code:</strong> <code>vanLeer(u,c,d) = (c≤min(u,d) || c≥max(u,d)) ? c : c+(d-c)*(c-u)/(d-u)</code></p><h4 id="Central-Difference-(CDS)"><a class="docs-heading-anchor" href="#Central-Difference-(CDS)">Central Difference (CDS)</a><a id="Central-Difference-(CDS)-1"></a><a class="docs-heading-anchor-permalink" href="#Central-Difference-(CDS)" title="Permalink"></a></h4><p>The central difference scheme provides 2nd-order accuracy but may oscillate:</p><p class="math-container">\[\phi_{CDS} = \frac{u_C + u_D}{2}\]</p><p><strong>Code:</strong> <code>cds(u,c,d) = (c+d)/2</code></p><h4 id="Stencil-Selection"><a class="docs-heading-anchor" href="#Stencil-Selection">Stencil Selection</a><a id="Stencil-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Stencil-Selection" title="Permalink"></a></h4><p>The upwind direction is determined by the face velocity <span>$u_j^{face}$</span>:</p><p class="math-container">\[\phi(u_i) = \begin{cases}
\lambda(u_i^{I-2\delta}, u_i^{I-\delta}, u_i^{I}) &amp; \text{if } u_j^{face} &gt; 0 \\
\lambda(u_i^{I+\delta}, u_i^{I}, u_i^{I-\delta}) &amp; \text{if } u_j^{face} &lt; 0
\end{cases}\]</p><p>where <span>$\lambda$</span> is the chosen scheme (quick, vanLeer, or cds).</p><h3 id="Conservative-Flux-Application"><a class="docs-heading-anchor" href="#Conservative-Flux-Application">Conservative Flux Application</a><a id="Conservative-Flux-Application-1"></a><a class="docs-heading-anchor-permalink" href="#Conservative-Flux-Application" title="Permalink"></a></h3><p>The key feature of FVM is that <strong>the same flux value is added to one cell and subtracted from its neighbor</strong>:</p><pre><code class="nohighlight hljs">Cell I-1:    r[I-1] -= F[I]    (flux leaves)
Cell I:      r[I]   += F[I]    (flux enters)</code></pre><p>This ensures that momentum is exactly conserved — no momentum is created or destroyed at internal faces.</p><pre><code class="nohighlight hljs">        Face I
          ↓
    ┌─────┼─────┐
    │     │     │
    │ I-1 │  I  │
    │     │     │
    └─────┼─────┘
          │
     -F ←─┼─→ +F</code></pre><h3 id="Code-Implementation"><a class="docs-heading-anchor" href="#Code-Implementation">Code Implementation</a><a id="Code-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Implementation" title="Permalink"></a></h3><p>The FVM is implemented in <code>src/Flow.jl</code>. Here&#39;s how the math maps to code:</p><h4 id="Flux-Storage-(Optional)"><a class="docs-heading-anchor" href="#Flux-Storage-(Optional)">Flux Storage (Optional)</a><a id="Flux-Storage-(Optional)-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Storage-(Optional)" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Flow struct fields for explicit flux storage
F_conv :: Array{T,D+2}  # Convective flux F_conv[I,j,i]
F_diff :: Array{T,D+2}  # Diffusive flux F_diff[I,j,i]
store_fluxes :: Bool    # Enable FVM mode</code></pre><p>The flux tensor has indices:</p><ul><li><code>I</code> = spatial cell index (D-dimensional)</li><li><code>j</code> = face direction (1=x, 2=y, 3=z)</li><li><code>i</code> = momentum component</li></ul><h4 id="Computing-Fluxes"><a class="docs-heading-anchor" href="#Computing-Fluxes">Computing Fluxes</a><a id="Computing-Fluxes-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Fluxes" title="Permalink"></a></h4><pre><code class="language-julia hljs"># From compute_face_flux! in src/Flow.jl
for i ∈ 1:n, j ∈ 1:n
    inv_Δxj = 1/Δx[j]
    ν_Δxj = ν/Δx[j]

    # Interior faces
    @loop (
        # Convective flux: (1/Δx) * u_face * ϕ(u)
        F_conv[I,j,i] = inv_Δxj * ϕu(j, CI(I,i), u, ϕ(i,CI(I,j),u), λ);
        # Diffusive flux: -(ν/Δx) * ∂u/∂x
        F_diff[I,j,i] = -ν_Δxj * ∂(j, CI(I,i), u)
    ) over I ∈ inside_u(N,j)

    # Boundary fluxes (one-sided stencils)
    compute_boundary_flux!(...)
end</code></pre><p>Key functions:</p><ul><li><code>ϕ(i,I,u)</code> — Interpolates velocity component <code>i</code> to face location</li><li><code>ϕu(j,I,u,u_face,λ)</code> — Computes upwind flux using scheme <code>λ</code> (quick, vanLeer, cds)</li><li><code>∂(j,I,u)</code> — Central difference <span>$u^I - u^{I-\delta_j}$</span></li></ul><h4 id="Applying-Fluxes-Conservatively"><a class="docs-heading-anchor" href="#Applying-Fluxes-Conservatively">Applying Fluxes Conservatively</a><a id="Applying-Fluxes-Conservatively-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Fluxes-Conservatively" title="Permalink"></a></h4><pre><code class="language-julia hljs"># From apply_fluxes! in src/Flow.jl
for i ∈ 1:n, j ∈ 1:n
    F_total = F_conv[I,j,i] + F_diff[I,j,i]

    # Lower boundary: only flux INTO domain
    @loop r[I,i] += F_total over I ∈ slice(N,2,j,2)

    # Interior: flux enters I, leaves I-δ (CONSERVATIVE!)
    @loop r[I,i] += F_total over I ∈ inside_u(N,j)
    @loop r[I-δ(j,I),i] -= F_total over I ∈ inside_u(N,j)

    # Upper boundary: only flux OUT OF domain
    @loop r[I-δ(j,I),i] -= F_total over I ∈ slice(N,N[j],j,2)
end</code></pre><h3 id="Enabling-FVM-Mode"><a class="docs-heading-anchor" href="#Enabling-FVM-Mode">Enabling FVM Mode</a><a id="Enabling-FVM-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Enabling-FVM-Mode" title="Permalink"></a></h3><p>To use explicit flux storage and verification:</p><pre><code class="language-julia hljs"># Enable FVM with flux storage
sim = Simulation((nx, ny), (Lx, Ly);
                 store_fluxes = true,  # Enable FVM mode
                 ν = 0.01)

# Run simulation
sim_step!(sim)

# Access stored fluxes for analysis
F_conv = sim.flow.F_conv  # Convective fluxes
F_diff = sim.flow.F_diff  # Diffusive fluxes

# Verify conservation (sum of internal fluxes = 0)</code></pre><p>When <code>store_fluxes=false</code> (default), the original method is used which computes fluxes on-the-fly without storing them.</p><h3 id="Boundary-Flux-Treatment"><a class="docs-heading-anchor" href="#Boundary-Flux-Treatment">Boundary Flux Treatment</a><a id="Boundary-Flux-Treatment-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Flux-Treatment" title="Permalink"></a></h3><p>At domain boundaries, fluxes are handled specially since there&#39;s no neighbor cell outside:</p><table><tr><th style="text-align: right">Boundary</th><th style="text-align: right">Treatment</th><th style="text-align: right">Stencil</th></tr><tr><td style="text-align: right">Lower (index 2)</td><td style="text-align: right">One-sided upwind</td><td style="text-align: right"><code>ϕuL</code></td></tr><tr><td style="text-align: right">Upper (index N)</td><td style="text-align: right">One-sided upwind</td><td style="text-align: right"><code>ϕuR</code></td></tr><tr><td style="text-align: right">Periodic</td><td style="text-align: right">Wrap-around</td><td style="text-align: right"><code>ϕuP</code></td></tr></table><pre><code class="language-julia hljs"># Lower boundary: use left-biased stencil
F_conv[I,j,i] = ϕuL(j, I, u, u_face, λ)

# Upper boundary: use right-biased stencil
F_conv[I,j,i] = ϕuR(j, I, u, u_face, λ)

# Periodic: wrap to opposite boundary
F_conv[I,j,i] = ϕuP(j, I_wrapped, I, u, u_face, λ)</code></pre><h3 id="Conservation-Verification"><a class="docs-heading-anchor" href="#Conservation-Verification">Conservation Verification</a><a id="Conservation-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Conservation-Verification" title="Permalink"></a></h3><p>The FVM ensures exact momentum conservation. For a closed system with no external forces:</p><p class="math-container">\[\frac{d}{dt} \sum_I u_i^I \cdot \Delta V = \sum_{\text{boundaries}} F_{i}^{boundary}\]</p><p>Interior fluxes cancel exactly because each internal face contributes:</p><ul><li><p class="math-container">\[+F\]</p>to cell <span>$I$</span></li><li><p class="math-container">\[-F\]</p>to cell <span>$I-\delta$</span></li></ul><p>This property is crucial for accurate long-time simulations and proper vortex dynamics.</p><h2 id="Time-Integration"><a class="docs-heading-anchor" href="#Time-Integration">Time Integration</a><a id="Time-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Integration" title="Permalink"></a></h2><p>BioFlows.jl uses a <strong>2nd-order predictor-corrector</strong> (Heun&#39;s method) combined with pressure projection to ensure incompressibility. This provides 2nd-order temporal accuracy.</p><h3 id="Predictor-Step"><a class="docs-heading-anchor" href="#Predictor-Step">Predictor Step</a><a id="Predictor-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Predictor-Step" title="Permalink"></a></h3><p>First, compute a forward Euler prediction:</p><p class="math-container">\[\mathbf{u}^* = \mathbf{u}^n + \Delta t \left[ -(\mathbf{u}^n \cdot \nabla)\mathbf{u}^n + \nu \nabla^2 \mathbf{u}^n + \mathbf{g} \right]\]</p><p>Then project onto divergence-free space:</p><p class="math-container">\[\nabla^2 \phi = \nabla \cdot \mathbf{u}^*\]</p><p class="math-container">\[\mathbf{u}&#39; = \mathbf{u}^* - \nabla \phi\]</p><h3 id="Corrector-Step"><a class="docs-heading-anchor" href="#Corrector-Step">Corrector Step</a><a id="Corrector-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Corrector-Step" title="Permalink"></a></h3><p>Re-evaluate the right-hand side at the predicted velocity:</p><p class="math-container">\[\mathbf{f}&#39; = -(\mathbf{u}&#39; \cdot \nabla)\mathbf{u}&#39; + \nu \nabla^2 \mathbf{u}&#39; + \mathbf{g}\]</p><p>Average the predictor and corrector contributions (Heun&#39;s method):</p><p class="math-container">\[\mathbf{u}^{**} = \frac{1}{2}\left( \mathbf{u}&#39; + \mathbf{u}^n + \Delta t \, \mathbf{f}&#39; \right)\]</p><p>This is equivalent to the trapezoidal rule:</p><p class="math-container">\[\mathbf{u}^{**} = \mathbf{u}^n + \frac{\Delta t}{2} \left( \mathbf{f}^n + \mathbf{f}&#39; \right)\]</p><p>Finally, project onto divergence-free space:</p><p class="math-container">\[\nabla^2 \psi = \frac{2}{\Delta t} \nabla \cdot \mathbf{u}^{**}\]</p><p class="math-container">\[\mathbf{u}^{n+1} = \mathbf{u}^{**} - \frac{\Delta t}{2} \nabla \psi\]</p><h3 id="Summary-of-the-Algorithm"><a class="docs-heading-anchor" href="#Summary-of-the-Algorithm">Summary of the Algorithm</a><a id="Summary-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-the-Algorithm" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Algorithm: 2nd-order Predictor-Corrector with Pressure Projection
─────────────────────────────────────────────────────────────────
Input: uⁿ (divergence-free velocity at time tⁿ)
Output: uⁿ⁺¹ (divergence-free velocity at time tⁿ⁺¹)

1. Save: u⁰ ← uⁿ

2. PREDICTOR:
   a. f ← RHS(u⁰)                    // Convection + diffusion
   b. u* ← u⁰ + Δt·f                 // Forward Euler
   c. Solve ∇²φ = ∇·u*               // Pressure Poisson
   d. u&#39; ← u* - ∇φ                   // Project to div-free

3. CORRECTOR:
   a. f&#39; ← RHS(u&#39;)                   // Re-evaluate at predicted
   b. u** ← u&#39; + u⁰ + Δt·f&#39;          // Accumulate
   c. u** ← 0.5·u**                  // Average (Heun)
   d. Solve ∇²ψ = (2/Δt)·∇·u**       // Pressure Poisson
   e. uⁿ⁺¹ ← u** - (Δt/2)·∇ψ        // Final projection

4. Compute Δt from CFL condition</code></pre><h3 id="CFL-Condition"><a class="docs-heading-anchor" href="#CFL-Condition">CFL Condition</a><a id="CFL-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#CFL-Condition" title="Permalink"></a></h3><p>The time step is constrained by the CFL (Courant-Friedrichs-Lewy) condition:</p><p class="math-container">\[\Delta t \leq \left( \sum_d \frac{|u_d|}{\Delta x_d} + \sum_d \frac{2\nu}{\Delta x_d^2} \right)^{-1}\]</p><p>where the first term is the convective constraint and the second is the diffusive constraint.</p><h2 id="Pressure-Solver"><a class="docs-heading-anchor" href="#Pressure-Solver">Pressure Solver</a><a id="Pressure-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Pressure-Solver" title="Permalink"></a></h2><p>The pressure Poisson equation is solved using a <strong>geometric multigrid</strong> method with:</p><ul><li>Jacobi smoothing iterations</li><li>Full-weighting restriction</li><li>Bilinear interpolation for prolongation</li><li>V-cycle iteration until convergence</li></ul><p>The multigrid solver operates on a hierarchy of progressively coarser grids, enabling efficient solution of the elliptic pressure equation.</p><h2 id="Immersed-Boundary-Method-(BDIM)"><a class="docs-heading-anchor" href="#Immersed-Boundary-Method-(BDIM)">Immersed Boundary Method (BDIM)</a><a id="Immersed-Boundary-Method-(BDIM)-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-Boundary-Method-(BDIM)" title="Permalink"></a></h2><p>BioFlows.jl implements the <strong>Boundary Data Immersion Method (BDIM)</strong> for handling complex geometries, including moving and deforming bodies. This section provides the complete mathematical formulation.</p><h3 id="Signed-Distance-Function-(SDF)"><a class="docs-heading-anchor" href="#Signed-Distance-Function-(SDF)">Signed Distance Function (SDF)</a><a id="Signed-Distance-Function-(SDF)-1"></a><a class="docs-heading-anchor-permalink" href="#Signed-Distance-Function-(SDF)" title="Permalink"></a></h3><p>Bodies are defined implicitly through signed distance functions:</p><p class="math-container">\[\phi(\mathbf{x}, t) &lt; 0 \quad \text{inside body}\]</p><p class="math-container">\[\phi(\mathbf{x}, t) = 0 \quad \text{on boundary}\]</p><p class="math-container">\[\phi(\mathbf{x}, t) &gt; 0 \quad \text{in fluid}\]</p><p>The SDF provides:</p><ul><li><strong>Distance to surface</strong>: <span>$d = \phi(\mathbf{x}, t)$</span></li><li><strong>Surface normal</strong>: <span>$\mathbf{n} = \nabla\phi / |\nabla\phi|$</span></li><li><strong>Curvature</strong>: <span>$\kappa = \nabla \cdot \mathbf{n}$</span></li></ul><h3 id="BDIM-Kernel-Functions"><a class="docs-heading-anchor" href="#BDIM-Kernel-Functions">BDIM Kernel Functions</a><a id="BDIM-Kernel-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#BDIM-Kernel-Functions" title="Permalink"></a></h3><p>The BDIM uses a smooth kernel to transition from fluid to solid over a band of width <span>$2\epsilon$</span> centered at the body surface. The kernel is a raised cosine:</p><p class="math-container">\[K(\xi) = \frac{1}{2} + \frac{1}{2}\cos(\pi\xi), \quad \xi \in [-1, 1]\]</p><p>where <span>$\xi = d/\epsilon$</span> is the normalized distance.</p><h4 id="Zeroth-Moment-(Volume-Fraction)"><a class="docs-heading-anchor" href="#Zeroth-Moment-(Volume-Fraction)">Zeroth Moment (Volume Fraction)</a><a id="Zeroth-Moment-(Volume-Fraction)-1"></a><a class="docs-heading-anchor-permalink" href="#Zeroth-Moment-(Volume-Fraction)" title="Permalink"></a></h4><p>The volume fraction <span>$\mu_0$</span> represents how much of a cell is fluid:</p><p class="math-container">\[\mu_0(d, \epsilon) = \int_{-1}^{d/\epsilon} K(s) \, ds = \frac{1}{2} + \frac{d}{2\epsilon} + \frac{1}{2\pi}\sin\left(\frac{\pi d}{\epsilon}\right)\]</p><p>Properties:</p><ul><li><p class="math-container">\[\mu_0 = 0\]</p>when <span>$d \leq -\epsilon$</span> (fully inside solid)</li><li><p class="math-container">\[\mu_0 = 1\]</p>when <span>$d \geq +\epsilon$</span> (fully in fluid)</li><li><p class="math-container">\[\mu_0 = 0.5\]</p>at <span>$d = 0$</span> (on surface)</li></ul><h4 id="First-Moment-(Gradient-Correction)"><a class="docs-heading-anchor" href="#First-Moment-(Gradient-Correction)">First Moment (Gradient Correction)</a><a id="First-Moment-(Gradient-Correction)-1"></a><a class="docs-heading-anchor-permalink" href="#First-Moment-(Gradient-Correction)" title="Permalink"></a></h4><p>The first moment <span>$\mu_1$</span> provides gradient information for boundary layer resolution:</p><p class="math-container">\[\mu_1(d, \epsilon) = \epsilon \int_{-1}^{d/\epsilon} s \cdot K(s) \, ds = \epsilon \left[ \frac{1}{4}\left(1 - \frac{d^2}{\epsilon^2}\right) - \frac{1}{2\pi^2}\left(\frac{d}{\epsilon}\sin\frac{\pi d}{\epsilon} + \frac{1 + \cos\frac{\pi d}{\epsilon}}{\pi}\right) \right]\]</p><h3 id="BDIM-Velocity-Update"><a class="docs-heading-anchor" href="#BDIM-Velocity-Update">BDIM Velocity Update</a><a id="BDIM-Velocity-Update-1"></a><a class="docs-heading-anchor-permalink" href="#BDIM-Velocity-Update" title="Permalink"></a></h3><p>The BDIM enforces no-slip/no-penetration at immersed boundaries by blending the fluid velocity <span>$\mathbf{u}^*$</span> with the body velocity <span>$\mathbf{V}$</span>:</p><p class="math-container">\[\mathbf{u} = \mu_0 \cdot \mathbf{f} + \mathbf{V} + \boldsymbol{\mu}_1 \cdot \nabla \mathbf{f}\]</p><p>where the correction field is:</p><p class="math-container">\[\mathbf{f} = \mathbf{u}^0 + \Delta t \cdot \mathbf{RHS} - \mathbf{V}\]</p><p>and:</p><ul><li><p class="math-container">\[\mathbf{u}^0\]</p>= velocity at previous time step</li><li><p class="math-container">\[\mathbf{RHS}\]</p>= convection + diffusion terms</li><li><p class="math-container">\[\mathbf{V}\]</p>= body velocity at each point</li><li><p class="math-container">\[\boldsymbol{\mu}_1 = \mu_1 \cdot \mathbf{n}\]</p>= directional first moment</li></ul><p>This formulation:</p><ol><li>Smoothly transitions from fluid velocity to body velocity</li><li>Maintains proper boundary layer behavior</li><li>Conserves momentum at the interface</li></ol><h3 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h3><p>Maertens, A.P. and Weymouth, G.D. (2015). &quot;Accurate Cartesian-grid simulations of near-body flows at intermediate Reynolds numbers.&quot; <em>Computer Methods in Applied Mechanics and Engineering</em>, 283, 106-129. doi:<a href="https://doi.org/10.1016/j.cma.2014.09.007">10.1016/j.cma.2014.09.007</a></p><h2 id="Flexible-Body-Kinematics"><a class="docs-heading-anchor" href="#Flexible-Body-Kinematics">Flexible Body Kinematics</a><a id="Flexible-Body-Kinematics-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Body-Kinematics" title="Permalink"></a></h2><p>BioFlows supports time-varying body geometries through two mechanisms:</p><ol><li><strong>Coordinate mapping</strong> for rigid body motion (translation, rotation)</li><li><strong>Time-dependent SDF</strong> for flexible/deforming bodies</li></ol><h3 id="Coordinate-Mapping-(Rigid-Motion)"><a class="docs-heading-anchor" href="#Coordinate-Mapping-(Rigid-Motion)">Coordinate Mapping (Rigid Motion)</a><a id="Coordinate-Mapping-(Rigid-Motion)-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-Mapping-(Rigid-Motion)" title="Permalink"></a></h3><p>For rigid bodies, the SDF shape is fixed but the body moves via a coordinate mapping <span>$\mathbf{m}(\mathbf{x}, t)$</span>:</p><p class="math-container">\[\phi(\mathbf{x}, t) = \phi_0(\mathbf{m}(\mathbf{x}, t))\]</p><p>where <span>$\phi_0$</span> is the reference SDF and <span>$\mathbf{m}$</span> maps world coordinates to body-fixed coordinates.</p><h4 id="Body-Velocity-from-Mapping"><a class="docs-heading-anchor" href="#Body-Velocity-from-Mapping">Body Velocity from Mapping</a><a id="Body-Velocity-from-Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Body-Velocity-from-Mapping" title="Permalink"></a></h4><p>The body velocity is computed from the coordinate mapping using:</p><p class="math-container">\[\mathbf{V} = -\mathbf{J}^{-1} \cdot \frac{\partial \mathbf{m}}{\partial t}\]</p><p>where <span>$\mathbf{J} = \partial \mathbf{m} / \partial \mathbf{x}$</span> is the Jacobian of the mapping.</p><p><strong>Derivation</strong>: For a material point <span>$\boldsymbol{\xi} = \mathbf{m}(\mathbf{x}, t)$</span> fixed in the body frame, we have <span>$D\boldsymbol{\xi}/Dt = 0$</span>. Using the chain rule:</p><p class="math-container">\[\frac{\partial \mathbf{m}}{\partial t} + \mathbf{J} \cdot \dot{\mathbf{x}} = 0\]</p><p>Solving for the velocity <span>$\dot{\mathbf{x}} = \mathbf{V}$</span>:</p><p class="math-container">\[\mathbf{V} = -\mathbf{J}^{-1} \cdot \frac{\partial \mathbf{m}}{\partial t}\]</p><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><p><strong>Oscillating Cylinder</strong> (vertical sinusoidal motion):</p><p class="math-container">\[\mathbf{m}(\mathbf{x}, t) = \mathbf{x} - \begin{pmatrix} 0 \\ A\sin(\omega t) \end{pmatrix}\]</p><p>Body velocity:</p><p class="math-container">\[\mathbf{V} = \begin{pmatrix} 0 \\ A\omega\cos(\omega t) \end{pmatrix}\]</p><p><strong>Rotating Body</strong> (angular velocity <span>$\Omega$</span>):</p><p class="math-container">\[\mathbf{m}(\mathbf{x}, t) = \mathbf{R}(-\Omega t) \cdot (\mathbf{x} - \mathbf{x}_c)\]</p><p>where <span>$\mathbf{R}(\theta)$</span> is the rotation matrix and <span>$\mathbf{x}_c$</span> is the center of rotation.</p><h3 id="Time-Dependent-SDF-(Flexible-Bodies)"><a class="docs-heading-anchor" href="#Time-Dependent-SDF-(Flexible-Bodies)">Time-Dependent SDF (Flexible Bodies)</a><a id="Time-Dependent-SDF-(Flexible-Bodies)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Dependent-SDF-(Flexible-Bodies)" title="Permalink"></a></h3><p>For flexible bodies where the shape itself changes over time, the SDF is directly time-dependent:</p><p class="math-container">\[\phi = \phi(\mathbf{x}, t)\]</p><p>The surface normal is computed as:</p><p class="math-container">\[\mathbf{n} = \frac{\nabla \phi}{|\nabla \phi|}\]</p><p>For <strong>pseudo-SDFs</strong> (implicit functions where <span>$|\nabla \phi| \neq 1$</span>), the distance is corrected:</p><p class="math-container">\[d = \frac{\phi}{|\nabla \phi|}\]</p><h2 id="Fluid-Structure-Interaction-(FSI)"><a class="docs-heading-anchor" href="#Fluid-Structure-Interaction-(FSI)">Fluid-Structure Interaction (FSI)</a><a id="Fluid-Structure-Interaction-(FSI)-1"></a><a class="docs-heading-anchor-permalink" href="#Fluid-Structure-Interaction-(FSI)" title="Permalink"></a></h2><p>BioFlows implements true fluid-structure interaction using the <strong>Euler-Bernoulli beam equation</strong> coupled with the incompressible Navier-Stokes equations. This allows simulation of passive flexible bodies whose deformation is computed from fluid forces, not prescribed.</p><h3 id="Euler-Bernoulli-Beam-Equation"><a class="docs-heading-anchor" href="#Euler-Bernoulli-Beam-Equation">Euler-Bernoulli Beam Equation</a><a id="Euler-Bernoulli-Beam-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Bernoulli-Beam-Equation" title="Permalink"></a></h3><p>The governing equation for a flexible beam is:</p><p class="math-container">\[\rho_s A \frac{\partial^2 w}{\partial t^2} + c \frac{\partial w}{\partial t} + EI \frac{\partial^4 w}{\partial x^4} - T \frac{\partial^2 w}{\partial x^2} = q(x, t) + f_{active}(x, t)\]</p><p>where:</p><table><tr><th style="text-align: right">Symbol</th><th style="text-align: right">Description</th><th style="text-align: right">Units</th></tr><tr><td style="text-align: right"><span>$\rho_s$</span></td><td style="text-align: right">Beam material density</td><td style="text-align: right">kg/m³</td></tr><tr><td style="text-align: right"><span>$A$</span></td><td style="text-align: right">Cross-sectional area</td><td style="text-align: right">m²</td></tr><tr><td style="text-align: right"><span>$c$</span></td><td style="text-align: right">Damping coefficient</td><td style="text-align: right">kg/(m·s)</td></tr><tr><td style="text-align: right"><span>$E$</span></td><td style="text-align: right">Young&#39;s modulus</td><td style="text-align: right">Pa</td></tr><tr><td style="text-align: right"><span>$I$</span></td><td style="text-align: right">Second moment of area</td><td style="text-align: right">m⁴</td></tr><tr><td style="text-align: right"><span>$T$</span></td><td style="text-align: right">Axial tension</td><td style="text-align: right">N</td></tr><tr><td style="text-align: right"><span>$w(x, t)$</span></td><td style="text-align: right">Transverse displacement</td><td style="text-align: right">m</td></tr><tr><td style="text-align: right"><span>$q(x, t)$</span></td><td style="text-align: right">Distributed fluid load</td><td style="text-align: right">N/m</td></tr><tr><td style="text-align: right"><span>$f_{active}(x, t)$</span></td><td style="text-align: right">Active forcing (muscle)</td><td style="text-align: right">N/m</td></tr></table><h3 id="Physical-Interpretation"><a class="docs-heading-anchor" href="#Physical-Interpretation">Physical Interpretation</a><a id="Physical-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Interpretation" title="Permalink"></a></h3><p>Each term represents a physical effect:</p><ol><li><strong>Inertia</strong>: <span>$\rho_s A \, \partial^2 w/\partial t^2$</span> — mass times acceleration</li><li><strong>Damping</strong>: <span>$c \, \partial w/\partial t$</span> — viscous resistance to motion</li><li><strong>Bending</strong>: <span>$EI \, \partial^4 w/\partial x^4$</span> — resistance to curvature</li><li><strong>Tension</strong>: <span>$-T \, \partial^2 w/\partial x^2$</span> — stiffening from axial load</li><li><strong>Fluid load</strong>: <span>$q(x, t)$</span> — pressure forces from surrounding fluid</li><li><strong>Active forcing</strong>: <span>$f_{active}(x, t)$</span> — muscle activation for swimming</li></ol><h3 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h3><p>The beam supports several boundary condition types:</p><table><tr><th style="text-align: right">Type</th><th style="text-align: right">Conditions</th><th style="text-align: right">Physical Meaning</th></tr><tr><td style="text-align: right"><strong>Clamped</strong></td><td style="text-align: right"><span>$w = 0, \, w&#39; = 0$</span></td><td style="text-align: right">Fixed position and slope</td></tr><tr><td style="text-align: right"><strong>Free</strong></td><td style="text-align: right"><span>$w&#39;&#39; = 0, \, w&#39;&#39;&#39; = 0$</span></td><td style="text-align: right">No moment, no shear</td></tr><tr><td style="text-align: right"><strong>Pinned</strong></td><td style="text-align: right"><span>$w = 0, \, w&#39;&#39; = 0$</span></td><td style="text-align: right">Fixed position, free rotation</td></tr><tr><td style="text-align: right"><strong>Prescribed</strong></td><td style="text-align: right"><span>$w = w_p(t)$</span></td><td style="text-align: right">Time-varying position</td></tr></table><p>For a fish-like body:</p><ul><li><strong>Head (left)</strong>: Clamped or prescribed motion</li><li><strong>Tail (right)</strong>: Free</li></ul><h3 id="Two-Way-Coupling"><a class="docs-heading-anchor" href="#Two-Way-Coupling">Two-Way Coupling</a><a id="Two-Way-Coupling-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Way-Coupling" title="Permalink"></a></h3><p>The FSI coupling is bidirectional:</p><h4 id="1.-Fluid-Structure"><a class="docs-heading-anchor" href="#1.-Fluid-Structure">1. Fluid → Structure</a><a id="1.-Fluid-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Fluid-Structure" title="Permalink"></a></h4><p>The fluid exerts pressure forces on the beam:</p><p class="math-container">\[q(s) = \oint p(\mathbf{x}) \, \mathbf{n} \cdot \mathbf{e}_z \, d\ell \approx \Delta p(s) \cdot b(s)\]</p><p>where:</p><ul><li><p class="math-container">\[\Delta p = p_{below} - p_{above}\]</p>is the pressure difference across the body</li><li><p class="math-container">\[b(s)\]</p>is the local body width</li></ul><h4 id="2.-Structure-Fluid"><a class="docs-heading-anchor" href="#2.-Structure-Fluid">2. Structure → Fluid</a><a id="2.-Structure-Fluid-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Structure-Fluid" title="Permalink"></a></h4><p>The beam deformation updates the body geometry:</p><p class="math-container">\[\phi(\mathbf{x}, t) = |z - z_{body}(x, t)| - h(s)\]</p><p>where <span>$z_{body}(x, t) = z_{center} + w(s, t)$</span> is the deformed centerline.</p><h3 id="Numerical-Discretization"><a class="docs-heading-anchor" href="#Numerical-Discretization">Numerical Discretization</a><a id="Numerical-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Discretization" title="Permalink"></a></h3><h4 id="Hermite-Finite-Element-Method"><a class="docs-heading-anchor" href="#Hermite-Finite-Element-Method">Hermite Finite Element Method</a><a id="Hermite-Finite-Element-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Hermite-Finite-Element-Method" title="Permalink"></a></h4><p>BioFlows uses <strong>Hermite cubic finite elements</strong> for accurate beam dynamics. Each node has two degrees of freedom:</p><table><tr><th style="text-align: right">DOF</th><th style="text-align: right">Symbol</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">Displacement</td><td style="text-align: right"><span>$w_i$</span></td><td style="text-align: right">Transverse deflection at node <span>$i$</span></td></tr><tr><td style="text-align: right">Rotation</td><td style="text-align: right"><span>$\theta_i$</span></td><td style="text-align: right">Slope <span>$\partial w/\partial x$</span> at node <span>$i$</span></td></tr></table><p>The state vector for <span>$n$</span> nodes is:</p><p class="math-container">\[\mathbf{u} = [w_1, \theta_1, w_2, \theta_2, \ldots, w_n, \theta_n]^T \in \mathbb{R}^{2n}\]</p><h4 id="Element-Matrices"><a class="docs-heading-anchor" href="#Element-Matrices">Element Matrices</a><a id="Element-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Element-Matrices" title="Permalink"></a></h4><p>For element <span>$e$</span> connecting nodes <span>$i$</span> and <span>$i+1$</span> with length <span>$h$</span>:</p><p><strong>Element Stiffness Matrix</strong> (bending):</p><p class="math-container">\[\mathbf{K}^e = \frac{EI}{h^3} \begin{bmatrix}
12 &amp; 6h &amp; -12 &amp; 6h \\
6h &amp; 4h^2 &amp; -6h &amp; 2h^2 \\
-12 &amp; -6h &amp; 12 &amp; -6h \\
6h &amp; 2h^2 &amp; -6h &amp; 4h^2
\end{bmatrix}\]</p><p><strong>Element Mass Matrix</strong> (consistent mass):</p><p class="math-container">\[\mathbf{M}^e = \frac{\rho A h}{420} \begin{bmatrix}
156 &amp; 22h &amp; 54 &amp; -13h \\
22h &amp; 4h^2 &amp; 13h &amp; -3h^2 \\
54 &amp; 13h &amp; 156 &amp; -22h \\
-13h &amp; -3h^2 &amp; -22h &amp; 4h^2
\end{bmatrix}\]</p><p><strong>Geometric Stiffness</strong> (for tension <span>$T$</span>):</p><p class="math-container">\[\mathbf{K}_g^e = \frac{T}{30h} \begin{bmatrix}
36 &amp; 3h &amp; -36 &amp; 3h \\
3h &amp; 4h^2 &amp; -3h &amp; -h^2 \\
-36 &amp; -3h &amp; 36 &amp; -3h \\
3h &amp; -h^2 &amp; -3h &amp; 4h^2
\end{bmatrix}\]</p><h4 id="Global-Assembly"><a class="docs-heading-anchor" href="#Global-Assembly">Global Assembly</a><a id="Global-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Assembly" title="Permalink"></a></h4><p>Element matrices are assembled into global system matrices <span>$\mathbf{M}$</span>, <span>$\mathbf{C}$</span>, <span>$\mathbf{K}$</span> by summing contributions at shared nodes. The semi-discrete equation becomes:</p><p class="math-container">\[\mathbf{M} \ddot{\mathbf{u}} + \mathbf{C} \dot{\mathbf{u}} + \mathbf{K} \mathbf{u} = \mathbf{F}(t)\]</p><h4 id="Boundary-Conditions-2"><a class="docs-heading-anchor" href="#Boundary-Conditions-2">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-2" title="Permalink"></a></h4><p>Boundary conditions are enforced using the <strong>penalty method</strong>:</p><p class="math-container">\[K_{ii} \leftarrow K_{ii} + \alpha, \quad F_i \leftarrow \alpha \cdot u_{prescribed}\]</p><p>where <span>$\alpha \sim 10^8 \cdot \max(K_{ij})$</span> is a large penalty parameter.</p><table><tr><th style="text-align: right">BC Type</th><th style="text-align: right">Constrained DOFs</th></tr><tr><td style="text-align: right">Clamped</td><td style="text-align: right"><span>$w_i = 0$</span>, <span>$\theta_i = 0$</span></td></tr><tr><td style="text-align: right">Pinned</td><td style="text-align: right"><span>$w_i = 0$</span></td></tr><tr><td style="text-align: right">Free</td><td style="text-align: right">None</td></tr></table><h4 id="Time-Integration-(Newmark-Beta)"><a class="docs-heading-anchor" href="#Time-Integration-(Newmark-Beta)">Time Integration (Newmark-Beta)</a><a id="Time-Integration-(Newmark-Beta)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Integration-(Newmark-Beta)" title="Permalink"></a></h4><p>The Newmark-beta method provides unconditionally stable time integration:</p><p class="math-container">\[\mathbf{u}_{n+1} = \mathbf{u}_n + \Delta t \, \dot{\mathbf{u}}_n + \Delta t^2 \left[ \left(\frac{1}{2} - \beta\right) \ddot{\mathbf{u}}_n + \beta \, \ddot{\mathbf{u}}_{n+1} \right]\]</p><p class="math-container">\[\dot{\mathbf{u}}_{n+1} = \dot{\mathbf{u}}_n + \Delta t \left[ (1 - \gamma) \ddot{\mathbf{u}}_n + \gamma \, \ddot{\mathbf{u}}_{n+1} \right]\]</p><p>With <span>$\beta = 0.25$</span> and <span>$\gamma = 0.5$</span> (average acceleration method), the scheme is:</p><ul><li><strong>Unconditionally stable</strong> for any time step</li><li><strong>Second-order accurate</strong> in time</li><li><strong>No numerical damping</strong> (energy conserving)</li></ul><h4 id="Effective-Stiffness-Formulation"><a class="docs-heading-anchor" href="#Effective-Stiffness-Formulation">Effective Stiffness Formulation</a><a id="Effective-Stiffness-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-Stiffness-Formulation" title="Permalink"></a></h4><p>At each time step, solve:</p><p class="math-container">\[\mathbf{K}_{eff} \, \mathbf{u}_{n+1} = \mathbf{F}_{eff}\]</p><p>where:</p><p class="math-container">\[\mathbf{K}_{eff} = \mathbf{K} + \frac{\gamma}{\beta \Delta t} \mathbf{C} + \frac{1}{\beta \Delta t^2} \mathbf{M}\]</p><p class="math-container">\[\mathbf{F}_{eff} = \mathbf{F}_{n+1} + \mathbf{M} \left( \frac{1}{\beta \Delta t^2} \mathbf{u}_n + \frac{1}{\beta \Delta t} \dot{\mathbf{u}}_n + \left(\frac{1}{2\beta} - 1\right) \ddot{\mathbf{u}}_n \right) + \mathbf{C} \left( \frac{\gamma}{\beta \Delta t} \mathbf{u}_n + \left(\frac{\gamma}{\beta} - 1\right) \dot{\mathbf{u}}_n + \frac{\Delta t}{2} \left(\frac{\gamma}{\beta} - 2\right) \ddot{\mathbf{u}}_n \right)\]</p><h3 id="Verification-Results"><a class="docs-heading-anchor" href="#Verification-Results">Verification Results</a><a id="Verification-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Verification-Results" title="Permalink"></a></h3><p>The Hermite FEM implementation has been verified against analytical solutions:</p><table><tr><th style="text-align: right">Test Case</th><th style="text-align: right">Analytical</th><th style="text-align: right">Numerical</th><th style="text-align: right">Error</th></tr><tr><td style="text-align: right">Cantilever (uniform load)</td><td style="text-align: right"><span>$w_{tip} = qL^4/(8EI)$</span></td><td style="text-align: right">Computed</td><td style="text-align: right">&lt; 8%</td></tr><tr><td style="text-align: right">Cantilever (point load)</td><td style="text-align: right"><span>$w_{tip} = PL^3/(3EI)$</span></td><td style="text-align: right">Computed</td><td style="text-align: right">&lt; 1%</td></tr><tr><td style="text-align: right">Natural frequency</td><td style="text-align: right"><span>$f_1 = 1.875^2 \sqrt{EI/(\rho A L^4)}/(2\pi)$</span></td><td style="text-align: right">Computed</td><td style="text-align: right">&lt; 1%</td></tr><tr><td style="text-align: right">Energy conservation</td><td style="text-align: right"><span>$E_{total} = const$</span></td><td style="text-align: right">Computed</td><td style="text-align: right">&lt; 1%</td></tr></table><h3 id="Adaptive-Mesh-Refinement-for-Flexible-Bodies"><a class="docs-heading-anchor" href="#Adaptive-Mesh-Refinement-for-Flexible-Bodies">Adaptive Mesh Refinement for Flexible Bodies</a><a id="Adaptive-Mesh-Refinement-for-Flexible-Bodies-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Mesh-Refinement-for-Flexible-Bodies" title="Permalink"></a></h3><p>BioFlows supports <strong>adaptive mesh refinement (AMR)</strong> that automatically follows flexible bodies as they deform during simulation. This ensures high resolution near the moving body surface while keeping computational cost low in far-field regions.</p><h4 id="FlexibleBodySDF"><a class="docs-heading-anchor" href="#FlexibleBodySDF">FlexibleBodySDF</a><a id="FlexibleBodySDF-1"></a><a class="docs-heading-anchor-permalink" href="#FlexibleBodySDF" title="Permalink"></a></h4><p>The <code>FlexibleBodySDF</code> creates a time-dependent signed distance function from the beam state:</p><pre><code class="language-julia hljs">beam_sdf = FlexibleBodySDF(beam, x_head, z_center;
                           thickness_func=s -&gt; beam.geometry.thickness(s),
                           width=0.01)</code></pre><p>The SDF automatically updates as the beam deforms:</p><ul><li>Negative values: inside the body</li><li>Positive values: outside the body</li><li>Zero: on the body surface</li></ul><h4 id="AMR-Configuration"><a class="docs-heading-anchor" href="#AMR-Configuration">AMR Configuration</a><a id="AMR-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#AMR-Configuration" title="Permalink"></a></h4><p>Configure AMR behavior with <code>BeamAMRConfig</code>:</p><pre><code class="language-julia hljs">config = BeamAMRConfig(
    max_level=2,                    # Maximum refinement level (2=4x)
    beam_distance_threshold=3.0,    # Refine within 3 cells of beam
    gradient_threshold=1.0,         # Velocity gradient threshold
    vorticity_threshold=1.0,        # Vorticity threshold
    beam_weight=0.6,                # Weight for beam proximity
    gradient_weight=0.25,           # Weight for velocity gradients
    vorticity_weight=0.15,          # Weight for vorticity
    buffer_size=2,                  # Buffer cells around refined region
    min_regrid_interval=5,          # Minimum steps between regrids
    motion_threshold=0.5,           # Displacement change to trigger regrid
    regrid_interval=10              # Force regrid every N steps
)</code></pre><h4 id="Motion-Triggered-Regridding"><a class="docs-heading-anchor" href="#Motion-Triggered-Regridding">Motion-Triggered Regridding</a><a id="Motion-Triggered-Regridding-1"></a><a class="docs-heading-anchor-permalink" href="#Motion-Triggered-Regridding" title="Permalink"></a></h4><p>The <code>BeamAMRTracker</code> monitors beam motion and triggers regridding when the beam moves significantly:</p><pre><code class="language-julia hljs">tracker = BeamAMRTracker(beam_sdf)

# In simulation loop
for step in 1:n_steps
    # Advance beam
    step!(beam, dt)

    # Check if regrid needed
    if should_regrid(tracker, step; min_interval=5, motion_threshold=0.5)
        # Perform regridding
        regrid_for_beam!(amr_sim, beam_sdf, tracker, step, config)
    end
end</code></pre><h4 id="Combined-Refinement-Indicator"><a class="docs-heading-anchor" href="#Combined-Refinement-Indicator">Combined Refinement Indicator</a><a id="Combined-Refinement-Indicator-1"></a><a class="docs-heading-anchor-permalink" href="#Combined-Refinement-Indicator" title="Permalink"></a></h4><p>The refinement decision combines three criteria:</p><p class="math-container">\[I_{combined} = w_b I_{beam} + w_g I_{gradient} + w_v I_{vorticity}\]</p><p>where:</p><ul><li><p class="math-container">\[I_{beam}\]</p>: 1 if within <code>beam_distance_threshold</code> of beam surface</li><li><p class="math-container">\[I_{gradient}\]</p>: 1 if velocity gradient exceeds threshold</li><li><p class="math-container">\[I_{vorticity}\]</p>: 1 if vorticity magnitude exceeds threshold</li><li><p class="math-container">\[w_b, w_g, w_v\]</p>: configurable weights (default: 0.6, 0.25, 0.15)</li></ul><h4 id="Example:-Swimming-Fish-with-AMR"><a class="docs-heading-anchor" href="#Example:-Swimming-Fish-with-AMR">Example: Swimming Fish with AMR</a><a id="Example:-Swimming-Fish-with-AMR-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Swimming-Fish-with-AMR" title="Permalink"></a></h4><pre><code class="language-julia hljs">using BioFlows

# Create flexible beam (fish body)
material = BeamMaterial(ρ=1050.0, E=5e5)
L = 0.2
h_func = fish_thickness_profile(L, 0.02)
geometry = BeamGeometry(L, 51; thickness=h_func, width=0.02)

beam = EulerBernoulliBeam(geometry, material;
                          bc_left=CLAMPED, bc_right=FREE,
                          damping=0.5)

# Create body and SDF from beam
body, beam_sdf = create_beam_body(beam, 0.2, 0.5)

# Create AMR simulation
amr_config = AMRConfig(
    max_level=2,
    body_distance_threshold=3.0,
    flexible_body=true,
    indicator_change_threshold=0.1
)

sim = AMRSimulation((256, 128), (2.0, 1.0);
                    body=body,
                    amr_config=amr_config,
                    ν=0.001)

# Create tracker for motion-based regridding
tracker = BeamAMRTracker(beam_sdf)
flex_config = BeamAMRConfig(max_level=2, beam_weight=0.7)

# Traveling wave forcing
f_wave = traveling_wave_forcing(amplitude=100.0, frequency=2.0,
                                wavelength=1.0, envelope=:carangiform, L=L)

# Simulation loop
dt = 1e-4
for step in 1:10000
    t = step * dt

    # Advance beam
    set_active_forcing!(beam, f_wave, t)
    step!(beam, dt)

    # Update body SDF
    update!(beam_sdf)

    # Advance flow with remeasure for moving body
    sim_step!(sim; remeasure=true)

    # Check for regrid
    if should_regrid(tracker, step; motion_threshold=0.5)
        regrid_for_beam!(sim, beam_sdf, tracker, step, flex_config)
        println(&quot;Regrid at step $step&quot;)
    end
end</code></pre><h4 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h4><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>create_beam_body(beam, x, z)</code></td><td style="text-align: right">Create AutoBody from beam</td></tr><tr><td style="text-align: right"><code>update!(beam_sdf)</code></td><td style="text-align: right">Update SDF with current beam state</td></tr><tr><td style="text-align: right"><code>get_beam_bounding_box(sdf)</code></td><td style="text-align: right">Get current bounding box</td></tr><tr><td style="text-align: right"><code>should_regrid(tracker, step)</code></td><td style="text-align: right">Check if regrid needed</td></tr><tr><td style="text-align: right"><code>mark_regrid!(tracker, step)</code></td><td style="text-align: right">Mark that regrid occurred</td></tr><tr><td style="text-align: right"><code>compute_beam_refinement_indicator(flow, sdf)</code></td><td style="text-align: right">Compute beam-only indicator</td></tr><tr><td style="text-align: right"><code>compute_beam_combined_indicator(flow, sdf)</code></td><td style="text-align: right">Compute weighted combined indicator</td></tr></table><h4 id="BeamAMRSimulation"><a class="docs-heading-anchor" href="#BeamAMRSimulation">BeamAMRSimulation</a><a id="BeamAMRSimulation-1"></a><a class="docs-heading-anchor-permalink" href="#BeamAMRSimulation" title="Permalink"></a></h4><p>For fully integrated beam-fluid simulations with AMR, use <code>BeamAMRSimulation</code>:</p><pre><code class="language-julia hljs">using BioFlows

# Create beam
material = BeamMaterial(ρ=1050.0, E=5e5)
geometry = BeamGeometry(0.2, 51; thickness=fish_thickness_profile(0.2, 0.02))
beam = EulerBernoulliBeam(geometry, material; bc_left=CLAMPED, bc_right=FREE)

# AMR configuration
config = BeamAMRConfig(
    max_level=2,
    beam_distance_threshold=4.0,
    beam_weight=0.7,
    min_regrid_interval=10,
    motion_threshold=0.002
)

# Create integrated simulation
sim = BeamAMRSimulation((256, 128), (2.0, 1.0), beam, 0.4, 0.5;
                         config=config, ν=0.001, U=1.0)

# Set active forcing
f_wave = traveling_wave_forcing(amplitude=100.0, frequency=2.0)
set_forcing!(sim, f_wave)

# Run simulation - beam and fluid are coupled automatically
for step in 1:1000
    sim_step!(sim)
end

# Get status
beam_info(sim)</code></pre><p>The <code>BeamAMRSimulation</code> automatically:</p><ol><li>Advances beam dynamics with the specified <code>dt_beam</code></li><li>Updates the body SDF with the deformed beam shape</li><li>Triggers AMR regridding when the beam moves significantly</li><li>Advances the fluid with the updated body position</li><li>Couples forces between beam and fluid (when enabled)</li></ol><h4 id="Convenience-Constructor"><a class="docs-heading-anchor" href="#Convenience-Constructor">Convenience Constructor</a><a id="Convenience-Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-Constructor" title="Permalink"></a></h4><p>For quick setup of swimming fish simulations:</p><pre><code class="language-julia hljs"># Create ready-to-run swimming fish with AMR
sim = swimming_fish_simulation(
    L_fish = 0.2,           # Fish length
    Re = 1000,              # Reynolds number
    St = 0.3,               # Strouhal number
    grid_size = (256, 128), # Base grid
    domain = (2.0, 1.0)     # Domain size
)

# Run
for step in 1:10000
    sim_step!(sim)
end</code></pre><h3 id="Active-Forcing-for-Swimming"><a class="docs-heading-anchor" href="#Active-Forcing-for-Swimming">Active Forcing for Swimming</a><a id="Active-Forcing-for-Swimming-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Forcing-for-Swimming" title="Permalink"></a></h3><h4 id="Traveling-Wave-Muscle-Activation"><a class="docs-heading-anchor" href="#Traveling-Wave-Muscle-Activation">Traveling Wave Muscle Activation</a><a id="Traveling-Wave-Muscle-Activation-1"></a><a class="docs-heading-anchor-permalink" href="#Traveling-Wave-Muscle-Activation" title="Permalink"></a></h4><p>To simulate active swimming, apply a traveling wave force:</p><p class="math-container">\[f_{active}(s, t) = A_{muscle}(s) \sin(ks - \omega t)\]</p><p>where the amplitude envelope <span>$A_{muscle}(s)$</span> follows the swimming mode:</p><table><tr><th style="text-align: right">Mode</th><th style="text-align: right">Envelope</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">Carangiform</td><td style="text-align: right"><span>$A(s) = A_0 (s/L)^2$</span></td><td style="text-align: right">Tail-dominated</td></tr><tr><td style="text-align: right">Anguilliform</td><td style="text-align: right"><span>$A(s) = A_0 (0.3 + 0.7 s/L)$</span></td><td style="text-align: right">Whole-body</td></tr><tr><td style="text-align: right">Subcarangiform</td><td style="text-align: right"><span>$A(s) = A_0 (s/L)^{1.5}$</span></td><td style="text-align: right">Intermediate</td></tr></table><h4 id="Heave-Pitch-Forcing"><a class="docs-heading-anchor" href="#Heave-Pitch-Forcing">Heave + Pitch Forcing</a><a id="Heave-Pitch-Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Heave-Pitch-Forcing" title="Permalink"></a></h4><p>For leading-edge oscillation:</p><p class="math-container">\[f_{active}(s, t) = f_{heave}(s, t) + f_{pitch}(s, t)\]</p><p>where:</p><ul><li><p class="math-container">\[f_{heave} = A_{heave} \exp(-(s/L)^2/0.01) \sin(\omega t + \phi_{heave})\]</p>— concentrated at head</li><li><p class="math-container">\[f_{pitch} = A_{pitch} (s/L) \exp(-(s/L)^2/0.1) \sin(\omega t + \phi_{pitch})\]</p>— moment at head</li></ul><h3 id="Fish-Body-Geometry"><a class="docs-heading-anchor" href="#Fish-Body-Geometry">Fish Body Geometry</a><a id="Fish-Body-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Fish-Body-Geometry" title="Permalink"></a></h3><p>The fish body uses a NACA-like thickness profile:</p><p class="math-container">\[h(s) = h_{max} \cdot 4 \frac{s}{L} \left(1 - \frac{s}{L}\right)\]</p><p>This gives:</p><ul><li>Zero thickness at head (<span>$s=0$</span>) and tail (<span>$s=L$</span>)</li><li>Maximum thickness at mid-body (<span>$s=L/2$</span>)</li></ul><h3 id="Dimensionless-Parameters"><a class="docs-heading-anchor" href="#Dimensionless-Parameters">Dimensionless Parameters</a><a id="Dimensionless-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensionless-Parameters" title="Permalink"></a></h3><h4 id="Strouhal-Number"><a class="docs-heading-anchor" href="#Strouhal-Number">Strouhal Number</a><a id="Strouhal-Number-1"></a><a class="docs-heading-anchor-permalink" href="#Strouhal-Number" title="Permalink"></a></h4><p class="math-container">\[St = \frac{f \cdot A_{tail}}{U}\]</p><p>Optimal swimming: <span>$St \approx 0.2 - 0.4$</span></p><h4 id="Reynolds-Number"><a class="docs-heading-anchor" href="#Reynolds-Number">Reynolds Number</a><a id="Reynolds-Number-1"></a><a class="docs-heading-anchor-permalink" href="#Reynolds-Number" title="Permalink"></a></h4><p class="math-container">\[Re = \frac{U \cdot L}{\nu}\]</p><h4 id="Cauchy-Number-(Flexibility)"><a class="docs-heading-anchor" href="#Cauchy-Number-(Flexibility)">Cauchy Number (Flexibility)</a><a id="Cauchy-Number-(Flexibility)-1"></a><a class="docs-heading-anchor-permalink" href="#Cauchy-Number-(Flexibility)" title="Permalink"></a></h4><p class="math-container">\[Ca = \frac{\rho_f U^2 L^3}{EI}\]</p><ul><li><p class="math-container">\[Ca \ll 1\]</p>: Rigid body (bending dominates)</li><li><p class="math-container">\[Ca \gg 1\]</p>: Highly flexible (fluid forces dominate)</li></ul><h4 id="Mass-Ratio"><a class="docs-heading-anchor" href="#Mass-Ratio">Mass Ratio</a><a id="Mass-Ratio-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Ratio" title="Permalink"></a></h4><p class="math-container">\[m^* = \frac{\rho_s}{\rho_f}\]</p><ul><li><p class="math-container">\[m^* \ll 1\]</p>: Light structure (strong FSI effects)</li><li><p class="math-container">\[m^* \gg 1\]</p>: Heavy structure (weak FSI effects)</li></ul><h3 id="FSI-Coupling-Algorithm"><a class="docs-heading-anchor" href="#FSI-Coupling-Algorithm">FSI Coupling Algorithm</a><a id="FSI-Coupling-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#FSI-Coupling-Algorithm" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Algorithm: Two-Way FSI Coupling
───────────────────────────────────────────────
Input: Flow state uⁿ, pⁿ; Beam state wⁿ, ẇⁿ
Output: Flow state uⁿ⁺¹, pⁿ⁺¹; Beam state wⁿ⁺¹, ẇⁿ⁺¹

1. FLUID STEP:
   a. Update body SDF from wⁿ
   b. Measure body (compute μ₀, μ₁, V)
   c. Advance flow: mom_step!(flow, poisson)
   d. Output: uⁿ⁺¹, pⁿ⁺¹

2. STRUCTURE STEP:
   For iter = 1 to max_iterations:
     a. Compute fluid load: q ← integrate(pⁿ⁺¹)
     b. Set active forcing: f_active ← muscle(s, t)
     c. Advance beam: Newmark-beta step
     d. Under-relax: w ← ω·w_new + (1-ω)·w_old
     e. Check convergence: |w - w_old| &lt; tol ?
   Output: wⁿ⁺¹, ẇⁿ⁺¹

3. Update time: t ← t + Δt</code></pre><h3 id="Example:-Passive-Flag-in-Flow"><a class="docs-heading-anchor" href="#Example:-Passive-Flag-in-Flow">Example: Passive Flag in Flow</a><a id="Example:-Passive-Flag-in-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Passive-Flag-in-Flow" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BioFlows

# Material: flexible rubber sheet
material = BeamMaterial(ρ=1100.0, E=1e6)

# Geometry: thin flag
geometry = BeamGeometry(L=0.2, n=51; thickness=0.002, width=0.1)

# Beam: clamped at leading edge, free at trailing edge
beam = EulerBernoulliBeam(geometry, material;
                          bc_left=CLAMPED, bc_right=FREE,
                          damping=0.1)

# Create FSI simulation
sim = FSISimulation((256, 128), (1.0, 0.5);
                    beam=beam,
                    x_head=0.2, z_center=0.25,
                    ν=0.001, ρ=1000.0,
                    inletBC=(1.0, 0.0))

# Run simulation
for step in 1:1000
    sim_step!(sim)
end</code></pre><h3 id="Example:-Active-Swimming-Fish"><a class="docs-heading-anchor" href="#Example:-Active-Swimming-Fish">Example: Active Swimming Fish</a><a id="Example:-Active-Swimming-Fish-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Active-Swimming-Fish" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BioFlows

# Material: fish tissue
material = BeamMaterial(ρ=1050.0, E=5e5)

# Geometry: fish-like profile
L = 0.2  # Fish length
h_func = fish_thickness_profile(L, 0.02)
geometry = BeamGeometry(L, 51; thickness=h_func, width=0.02)

# Active forcing: carangiform swimming
f_active = traveling_wave_forcing(
    amplitude=100.0,    # N/m
    frequency=2.0,      # Hz
    wavelength=1.0,     # Body lengths
    envelope=:carangiform,
    L=L
)

# Create FSI simulation with muscle activation
sim = FSISimulation((256, 128), (1.0, 0.5);
                    beam=beam,
                    active_forcing=f_active,
                    x_head=0.2, z_center=0.25,
                    ν=0.001, ρ=1000.0)

# Run simulation
for step in 1:1000
    sim_step!(sim)

    # Monitor energy
    KE = kinetic_energy(get_beam(sim))
    PE = potential_energy(get_beam(sim))
    println(&quot;Step $step: KE=$KE, PE=$PE&quot;)
end</code></pre><h3 id="Beam-State-Output"><a class="docs-heading-anchor" href="#Beam-State-Output">Beam State Output</a><a id="Beam-State-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Beam-State-Output" title="Permalink"></a></h3><p>BioFlows provides <code>BeamStateWriter</code> for saving flexible body positions to JLD2 files with configurable save rates. Each beam/flag can have its own separate output file.</p><h4 id="BeamStateWriter"><a class="docs-heading-anchor" href="#BeamStateWriter">BeamStateWriter</a><a id="BeamStateWriter-1"></a><a class="docs-heading-anchor-permalink" href="#BeamStateWriter" title="Permalink"></a></h4><p>The <code>BeamStateWriter</code> records beam state at specified time intervals:</p><pre><code class="language-julia hljs">BeamStateWriter(filename::String; interval::Real=0.01, overwrite::Bool=true)</code></pre><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>filename</code></td><td style="text-align: right">Output JLD2 file path</td><td style="text-align: right">Required</td></tr><tr><td style="text-align: right"><code>interval</code></td><td style="text-align: right">Time interval between saves</td><td style="text-align: right">0.01</td></tr><tr><td style="text-align: right"><code>overwrite</code></td><td style="text-align: right">Overwrite existing file</td><td style="text-align: right">true</td></tr></table><p><strong>Saved Data:</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Shape</th></tr><tr><td style="text-align: right"><code>displacement</code></td><td style="text-align: right">Transverse displacement <span>$w(s)$</span></td><td style="text-align: right"><span>$(n, n_{snap})$</span></td></tr><tr><td style="text-align: right"><code>rotation</code></td><td style="text-align: right">Rotation angle <span>$\theta(s) = \partial w/\partial s$</span></td><td style="text-align: right"><span>$(n, n_{snap})$</span></td></tr><tr><td style="text-align: right"><code>velocity</code></td><td style="text-align: right">Velocity <span>$\dot{w}(s)$</span></td><td style="text-align: right"><span>$(n, n_{snap})$</span></td></tr><tr><td style="text-align: right"><code>curvature</code></td><td style="text-align: right">Curvature <span>$\kappa(s) = \partial\theta/\partial s$</span></td><td style="text-align: right"><span>$(n, n_{snap})$</span></td></tr><tr><td style="text-align: right"><code>moment</code></td><td style="text-align: right">Bending moment <span>$M(s) = EI\kappa$</span></td><td style="text-align: right"><span>$(n, n_{snap})$</span></td></tr><tr><td style="text-align: right"><code>kinetic_energy</code></td><td style="text-align: right">Kinetic energy time series</td><td style="text-align: right"><span>$(n_{snap},)$</span></td></tr><tr><td style="text-align: right"><code>potential_energy</code></td><td style="text-align: right">Potential energy time series</td><td style="text-align: right"><span>$(n_{snap},)$</span></td></tr></table><h4 id="Single-Beam-Output"><a class="docs-heading-anchor" href="#Single-Beam-Output">Single Beam Output</a><a id="Single-Beam-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Beam-Output" title="Permalink"></a></h4><pre><code class="language-julia hljs">using BioFlows

# Create beam
material = BeamMaterial(ρ=1100.0, E=1e6)
geometry = BeamGeometry(0.2, 51; thickness=0.01, width=0.05)
beam = EulerBernoulliBeam(geometry, material;
                          bc_left=CLAMPED, bc_right=FREE)

# Create writer with 0.01 time unit interval
writer = BeamStateWriter(&quot;flag_simulation.jld2&quot;; interval=0.01)

# Simulation loop
dt = 1e-4
for step in 1:10000
    t = step * dt
    fill!(beam.q, 50.0)  # Apply load
    step!(beam, dt)
    file_save!(writer, beam, t)
end

# IMPORTANT: Must close writer to save data to file
close!(writer, beam)</code></pre><h4 id="Multiple-Beams-(Separate-Files)"><a class="docs-heading-anchor" href="#Multiple-Beams-(Separate-Files)">Multiple Beams (Separate Files)</a><a id="Multiple-Beams-(Separate-Files)-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Beams-(Separate-Files)" title="Permalink"></a></h4><p>For simulations with multiple flexible bodies, use <code>BeamStateWriterGroup</code> to create one file per beam:</p><pre><code class="language-julia hljs">using BioFlows

# Create multiple beams with different properties
n_flags = 5
beams = [
    EulerBernoulliBeam(
        BeamGeometry(0.2, 51; thickness=0.01, width=0.05),
        BeamMaterial(ρ=1100.0, E=1e6 * i);  # Varying stiffness
        bc_left=CLAMPED, bc_right=FREE
    ) for i in 1:n_flags
]

# Create writer group - generates flag_1.jld2, flag_2.jld2, etc.
writers = BeamStateWriterGroup(&quot;flag&quot;, n_flags; interval=0.01)

# Simulation loop
dt = 1e-4
for step in 1:10000
    t = step * dt
    for beam in beams
        step!(beam, dt)
    end
    file_save!(writers, beams, t)  # Save all beams at once
end

# Close all writers
close!(writers, beams)</code></pre><h4 id="JLD2-File-Structure"><a class="docs-heading-anchor" href="#JLD2-File-Structure">JLD2 File Structure</a><a id="JLD2-File-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#JLD2-File-Structure" title="Permalink"></a></h4><p>The output JLD2 file has the following hierarchical structure:</p><pre><code class="nohighlight hljs">beam_state.jld2
├── metadata/
│   ├── n_snapshots      # Total number of saved snapshots
│   ├── interval         # Time interval between saves
│   ├── n_nodes          # Number of beam nodes
│   └── length           # Beam length L
├── coordinates/
│   └── s                # Arc-length coordinates [0, L]
├── material/
│   ├── density          # Material density ρ
│   └── youngs_modulus   # Young&#39;s modulus E
├── time                 # Time array [t₁, t₂, ..., tₙ]
├── kinetic_energy       # KE time series
├── potential_energy     # PE time series
├── fields/              # Matrices (n_nodes × n_snapshots)
│   ├── displacement     # w(s, t)
│   ├── rotation         # θ(s, t)
│   ├── velocity         # ẇ(s, t)
│   └── curvature        # κ(s, t)
└── snapshots/           # Individual snapshot groups
    ├── 1/
    │   ├── time
    │   ├── displacement
    │   ├── rotation
    │   ├── velocity
    │   ├── curvature
    │   └── moment
    ├── 2/
    │   └── ...
    └── ...</code></pre><h4 id="Reading-Beam-State-Data"><a class="docs-heading-anchor" href="#Reading-Beam-State-Data">Reading Beam State Data</a><a id="Reading-Beam-State-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-Beam-State-Data" title="Permalink"></a></h4><pre><code class="language-julia hljs">using JLD2

jldopen(&quot;flag_simulation.jld2&quot;, &quot;r&quot;) do file
    # Read metadata
    n_snapshots = file[&quot;metadata/n_snapshots&quot;]
    n_nodes = file[&quot;metadata/n_nodes&quot;]
    L = file[&quot;metadata/length&quot;]
    println(&quot;Loaded $n_snapshots snapshots, $n_nodes nodes, L=$L m&quot;)

    # Read coordinates
    s = file[&quot;coordinates/s&quot;]

    # Read time series
    t = file[&quot;time&quot;]
    KE = file[&quot;kinetic_energy&quot;]
    PE = file[&quot;potential_energy&quot;]

    # Read field matrices (efficient for analysis)
    w = file[&quot;fields/displacement&quot;]  # Shape: (n_nodes, n_snapshots)
    θ = file[&quot;fields/rotation&quot;]
    κ = file[&quot;fields/curvature&quot;]

    # Compute tip displacement over time
    w_tip = w[end, :]
    println(&quot;Max tip displacement: $(maximum(abs.(w_tip)) * 1000) mm&quot;)

    # Read individual snapshot
    w_50 = file[&quot;snapshots/50/displacement&quot;]
    M_50 = file[&quot;snapshots/50/moment&quot;]
end</code></pre><h4 id="Post-Processing-Example"><a class="docs-heading-anchor" href="#Post-Processing-Example">Post-Processing Example</a><a id="Post-Processing-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing-Example" title="Permalink"></a></h4><pre><code class="language-julia hljs">using JLD2
using Plots

# Load data
data = load(&quot;flag_simulation.jld2&quot;)
t = data[&quot;time&quot;]
s = data[&quot;coordinates/s&quot;]
w = data[&quot;fields/displacement&quot;]
KE = data[&quot;kinetic_energy&quot;]
PE = data[&quot;potential_energy&quot;]

# Plot 1: Energy over time
p1 = plot(t, KE, label=&quot;Kinetic&quot;, xlabel=&quot;Time (s)&quot;, ylabel=&quot;Energy (J)&quot;)
plot!(p1, t, PE, label=&quot;Potential&quot;)
plot!(p1, t, KE .+ PE, label=&quot;Total&quot;, linestyle=:dash)

# Plot 2: Beam shape at different times
p2 = plot(xlabel=&quot;Arc length s (m)&quot;, ylabel=&quot;Displacement w (m)&quot;)
for i in [1, 10, 50, 100]
    plot!(p2, s, w[:, i], label=&quot;t=$(round(t[i], digits=3))&quot;)
end

# Plot 3: Tip displacement over time
p3 = plot(t, w[end, :] * 1000,
          xlabel=&quot;Time (s)&quot;, ylabel=&quot;Tip displacement (mm)&quot;,
          legend=false)

# Combine plots
plot(p1, p2, p3, layout=(3, 1), size=(600, 800))
savefig(&quot;beam_analysis.png&quot;)</code></pre><h2 id="Boundary-Conditions-3"><a class="docs-heading-anchor" href="#Boundary-Conditions-3">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-3" title="Permalink"></a></h2><p>BioFlows.jl supports three types of boundary conditions for the domain boundaries (not to be confused with immersed body boundaries handled by BDIM).</p><h3 id="Domain-Boundary-Overview"><a class="docs-heading-anchor" href="#Domain-Boundary-Overview">Domain Boundary Overview</a><a id="Domain-Boundary-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-Boundary-Overview" title="Permalink"></a></h3><pre><code class="nohighlight hljs">                    Top boundary (j = nz)
                    ─────────────────────
                    │                   │
                    │                   │
    Inlet           │                   │    Outlet
    (i = 1)         │     Domain        │    (i = nx)
    inletBC         │                   │    outletBC
                    │                   │
                    │                   │
                    ─────────────────────
                    Bottom boundary (j = 1)</code></pre><h3 id="1.-Inlet-Boundary-Condition-(inletBC)"><a class="docs-heading-anchor" href="#1.-Inlet-Boundary-Condition-(inletBC)">1. Inlet Boundary Condition (<code>inletBC</code>)</a><a id="1.-Inlet-Boundary-Condition-(inletBC)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Inlet-Boundary-Condition-(inletBC)" title="Permalink"></a></h3><p>The inlet boundary (at <span>$x = 0$</span>) uses a <strong>Dirichlet condition</strong> where velocity is prescribed.</p><h4 id="Constant-Inlet"><a class="docs-heading-anchor" href="#Constant-Inlet">Constant Inlet</a><a id="Constant-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-Inlet" title="Permalink"></a></h4><p>For uniform inflow, specify a tuple:</p><pre><code class="language-julia hljs">inletBC = (U, 0.0)  # u = U, v = 0 at inlet</code></pre><p>This sets:</p><p class="math-container">\[u(0, y, t) = U, \quad v(0, y, t) = 0\]</p><h4 id="Spatially-Varying-Inlet"><a class="docs-heading-anchor" href="#Spatially-Varying-Inlet">Spatially-Varying Inlet</a><a id="Spatially-Varying-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Spatially-Varying-Inlet" title="Permalink"></a></h4><p>For non-uniform profiles (e.g., parabolic channel flow), use a function:</p><pre><code class="language-julia hljs"># Parabolic profile: u(y) = U_max * (1 - (y-H)²/H²)
H = Ly / 2  # channel half-height
U_max = 1.5
inletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0</code></pre><p>The function signature is <code>inletBC(i, x, t)</code> where:</p><ul><li><code>i</code> = velocity component (1 = x, 2 = y/z)</li><li><code>x</code> = position vector</li><li><code>t</code> = time</li></ul><h4 id="Time-Varying-Inlet"><a class="docs-heading-anchor" href="#Time-Varying-Inlet">Time-Varying Inlet</a><a id="Time-Varying-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Varying-Inlet" title="Permalink"></a></h4><p>For pulsatile or oscillating inflow:</p><pre><code class="language-julia hljs"># Oscillating inlet: u(t) = U₀(1 + A·sin(ωt))
inletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(2π*t)) : 0.0</code></pre><div class="admonition is-info" id="Velocity-Scale-Required-6c158d793f69d119"><header class="admonition-header">Velocity Scale Required<a class="admonition-anchor" href="#Velocity-Scale-Required-6c158d793f69d119" title="Permalink"></a></header><div class="admonition-body"><p>When using a function for <code>inletBC</code>, you must specify <code>U</code> (velocity scale) explicitly since it cannot be auto-computed.</p></div></div><h3 id="2.-Convective-Outlet-Boundary-Condition-(outletBC)"><a class="docs-heading-anchor" href="#2.-Convective-Outlet-Boundary-Condition-(outletBC)">2. Convective Outlet Boundary Condition (<code>outletBC</code>)</a><a id="2.-Convective-Outlet-Boundary-Condition-(outletBC)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Convective-Outlet-Boundary-Condition-(outletBC)" title="Permalink"></a></h3><p>The outlet boundary (at <span>$x = L_x$</span>) is the most challenging because <strong>we don&#39;t know the flow state there in advance</strong>. Simple conditions like zero-gradient (<span>$\partial u/\partial x = 0$</span>) cause <strong>spurious reflections</strong> — pressure waves bounce back into the domain and contaminate the solution.</p><h4 id="The-Convective-BC-Approach"><a class="docs-heading-anchor" href="#The-Convective-BC-Approach">The Convective BC Approach</a><a id="The-Convective-BC-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-Convective-BC-Approach" title="Permalink"></a></h4><p>The convective (or advective) outlet condition assumes flow structures are <strong>transported out</strong> of the domain at a convection velocity <span>$U_c$</span>:</p><p class="math-container">\[\frac{\partial u}{\partial t} + U_c \frac{\partial u}{\partial x} = 0\]</p><p>This is a 1D wave equation that advects the local velocity pattern out of the domain.</p><h4 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h4><p>Using first-order upwind differencing:</p><p class="math-container">\[u_i^{n+1} = u_i^n - U_c \Delta t \frac{u_i^n - u_{i-1}^n}{\Delta x}\]</p><p>In BioFlows, <span>$U_c$</span> is taken as the mean inlet velocity to ensure mass conservation.</p><h4 id="Mass-Conservation-Correction"><a class="docs-heading-anchor" href="#Mass-Conservation-Correction">Mass Conservation Correction</a><a id="Mass-Conservation-Correction-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Conservation-Correction" title="Permalink"></a></h4><p>After applying the convective BC, a correction ensures global mass conservation:</p><p class="math-container">\[\oint u \, dA = 0 \quad \text{(for incompressible flow)}\]</p><p>The outlet velocity is adjusted so that mass flux out equals mass flux in:</p><pre><code class="language-julia hljs"># From src/util.jl - exitBC!
U = mean(u_inlet)           # Average inlet flux
u_outlet = u_outlet - Δt * U * ∂u/∂x  # Convective update
correction = mean(u_outlet) - U       # Mass imbalance
u_outlet = u_outlet - correction      # Enforce conservation</code></pre><h4 id="Why-Convective-BC-Works"><a class="docs-heading-anchor" href="#Why-Convective-BC-Works">Why Convective BC Works</a><a id="Why-Convective-BC-Works-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Convective-BC-Works" title="Permalink"></a></h4><pre><code class="nohighlight hljs">Without Convective BC:              With Convective BC:

    ────────────────────┐              ────────────────────→
    Vortex → → → ↩ ↩ ↩  │              Vortex → → → → → →
    ────────────────────┘              ────────────────────→
                ↑                                  ↑
          Reflection!                      Passes through</code></pre><p>The convective BC allows vortices, wakes, and other flow structures to exit smoothly without generating artificial reflections.</p><h4 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h4><pre><code class="language-julia hljs">sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (1.0, 0.0),
                 outletBC = true)      # Enable convective outlet</code></pre><h3 id="3.-Periodic-Boundary-Condition-(perdir)"><a class="docs-heading-anchor" href="#3.-Periodic-Boundary-Condition-(perdir)">3. Periodic Boundary Condition (<code>perdir</code>)</a><a id="3.-Periodic-Boundary-Condition-(perdir)-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Periodic-Boundary-Condition-(perdir)" title="Permalink"></a></h3><p>Periodic boundaries make the domain wrap around — flow exiting one side re-enters from the opposite side.</p><p class="math-container">\[u(x, 0, t) = u(x, L_y, t), \quad v(x, 0, t) = v(x, L_y, t)\]</p><h4 id="When-to-Use-Periodic-BC"><a class="docs-heading-anchor" href="#When-to-Use-Periodic-BC">When to Use Periodic BC</a><a id="When-to-Use-Periodic-BC-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Periodic-BC" title="Permalink"></a></h4><table><tr><th style="text-align: right">Scenario</th><th style="text-align: right">Direction</th><th style="text-align: right">Example</th></tr><tr><td style="text-align: right">Infinite span</td><td style="text-align: right">z (spanwise)</td><td style="text-align: right">Flow past cylinder</td></tr><tr><td style="text-align: right">Channel flow</td><td style="text-align: right">x (streamwise)</td><td style="text-align: right">Fully-developed pipe flow</td></tr><tr><td style="text-align: right">Homogeneous turbulence</td><td style="text-align: right">All</td><td style="text-align: right">Isotropic turbulence box</td></tr></table><h4 id="Usage-2"><a class="docs-heading-anchor" href="#Usage-2">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-2" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Periodic in z-direction (direction 2)
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (1.0, 0.0),
                 perdir = (2,))

# Periodic in both y and z (3D)
sim = Simulation((nx, ny, nz), (Lx, Ly, Lz);
                 inletBC = (1.0, 0.0, 0.0),
                 perdir = (2, 3))</code></pre><h3 id="4.-Default-(No-Flux)-Boundaries"><a class="docs-heading-anchor" href="#4.-Default-(No-Flux)-Boundaries">4. Default (No-Flux) Boundaries</a><a id="4.-Default-(No-Flux)-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Default-(No-Flux)-Boundaries" title="Permalink"></a></h3><p>Boundaries not explicitly set use a <strong>zero normal gradient</strong> (Neumann) condition:</p><p class="math-container">\[\frac{\partial u}{\partial n} = 0\]</p><p>This is appropriate for:</p><ul><li>Slip walls (free-slip, no penetration)</li><li>Symmetry planes</li><li>Far-field boundaries (approximate)</li></ul><h3 id="Boundary-Condition-Summary"><a class="docs-heading-anchor" href="#Boundary-Condition-Summary">Boundary Condition Summary</a><a id="Boundary-Condition-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Condition-Summary" title="Permalink"></a></h3><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Condition</th><th style="text-align: right">Mathematical Form</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right"><code>inletBC</code></td><td style="text-align: right">Dirichlet</td><td style="text-align: right"><span>$u = u_{prescribed}$</span></td><td style="text-align: right">Inflow boundaries</td></tr><tr><td style="text-align: right"><code>outletBC=true</code></td><td style="text-align: right">Convective</td><td style="text-align: right"><span>$\partial_t u + U \partial_x u = 0$</span></td><td style="text-align: right">Outflow (prevents reflections)</td></tr><tr><td style="text-align: right"><code>perdir=(d,)</code></td><td style="text-align: right">Periodic</td><td style="text-align: right"><span>$u(0) = u(L)$</span></td><td style="text-align: right">Infinite/repeating domains</td></tr><tr><td style="text-align: right">(default)</td><td style="text-align: right">Neumann</td><td style="text-align: right"><span>$\partial_n u = 0$</span></td><td style="text-align: right">Slip walls, symmetry</td></tr></table><h3 id="Common-Configurations"><a class="docs-heading-anchor" href="#Common-Configurations">Common Configurations</a><a id="Common-Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Configurations" title="Permalink"></a></h3><h4 id="External-Flow-(Wake-Problems)"><a class="docs-heading-anchor" href="#External-Flow-(Wake-Problems)">External Flow (Wake Problems)</a><a id="External-Flow-(Wake-Problems)-1"></a><a class="docs-heading-anchor-permalink" href="#External-Flow-(Wake-Problems)" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Flow past cylinder: inlet + convective outlet + periodic spanwise
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0),
                 outletBC = true,
                 perdir = (2,),
                 body = AutoBody(sdf))</code></pre><h4 id="Channel-Flow"><a class="docs-heading-anchor" href="#Channel-Flow">Channel Flow</a><a id="Channel-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Channel-Flow" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Fully-developed channel: periodic streamwise + no-slip walls
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0),
                 perdir = (1,))  # Periodic in x (streamwise)</code></pre><h4 id="Closed-Cavity"><a class="docs-heading-anchor" href="#Closed-Cavity">Closed Cavity</a><a id="Closed-Cavity-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-Cavity" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Lid-driven cavity: no outlet, no periodic
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0))  # Top wall moves at U</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li><p>Harlow, F.H. and Welch, J.E. (1965). &quot;Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface.&quot; <em>Physics of Fluids</em>, 8(12), 2182-2189.</p></li><li><p>Weymouth, G.D. and Yue, D.K.P. (2011). &quot;Boundary data immersion method for Cartesian-grid simulations of fluid-body interaction problems.&quot; <em>Journal of Computational Physics</em>, 230(16), 6233-6247.</p></li><li><p>Orlanski, I. (1976). &quot;A simple boundary condition for unbounded hyperbolic flows.&quot; <em>Journal of Computational Physics</em>, 21(3), 251-269.</p></li><li><p>Leonard, B.P. (1979). &quot;A stable and accurate convective modelling procedure based on quadratic upstream interpolation.&quot; <em>Computer Methods in Applied Mechanics and Engineering</em>, 19(1), 59-98. (QUICK scheme)</p></li><li><p>Van Leer, B. (1979). &quot;Towards the ultimate conservative difference scheme. V. A second-order sequel to Godunov&#39;s method.&quot; <em>Journal of Computational Physics</em>, 32(1), 101-136. (Van Leer limiter)</p></li><li><p>Versteeg, H.K. and Malalasekera, W. (2007). <em>An Introduction to Computational Fluid Dynamics: The Finite Volume Method</em>. Pearson Education.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../codebase_structure/">« Codebase Structure</a><a class="docs-footer-nextpage" href="../core_types/">Core Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 26 December 2025 10:32">Friday 26 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
