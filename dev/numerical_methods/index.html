<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Methods · BioFlows.jl</title><meta name="title" content="Numerical Methods · BioFlows.jl"/><meta property="og:title" content="Numerical Methods · BioFlows.jl"/><meta property="twitter:title" content="Numerical Methods · BioFlows.jl"/><meta name="description" content="Documentation for BioFlows.jl."/><meta property="og:description" content="Documentation for BioFlows.jl."/><meta property="twitter:description" content="Documentation for BioFlows.jl."/><meta property="og:url" content="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><meta property="twitter:url" content="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><link rel="canonical" href="https://subhk.github.io/BioFlows.jl/numerical_methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BioFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Numerical Methods</a><ul class="internal"><li><a class="tocitem" href="#Governing-Equations"><span>Governing Equations</span></a></li><li><a class="tocitem" href="#Staggered-Grid-(MAC-Grid)"><span>Staggered Grid (MAC Grid)</span></a></li><li><a class="tocitem" href="#Extension-to-3D"><span>Extension to 3D</span></a></li><li><a class="tocitem" href="#Finite-Difference-Operators"><span>Finite Difference Operators</span></a></li><li><a class="tocitem" href="#Convection-Diffusion-Discretization"><span>Convection-Diffusion Discretization</span></a></li><li><a class="tocitem" href="#Time-Integration"><span>Time Integration</span></a></li><li><a class="tocitem" href="#Pressure-Solver"><span>Pressure Solver</span></a></li><li><a class="tocitem" href="#Immersed-Boundary-Method"><span>Immersed Boundary Method</span></a></li><li><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../core_types/">Core Types</a></li><li><a class="tocitem" href="../amr/">Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/BioFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/BioFlows.jl/blob/main/docs/src/numerical_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-Methods"><a class="docs-heading-anchor" href="#Numerical-Methods">Numerical Methods</a><a id="Numerical-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Methods" title="Permalink"></a></h1><p>This section describes the numerical methods used in BioFlows.jl for solving the incompressible Navier-Stokes equations.</p><h2 id="Governing-Equations"><a class="docs-heading-anchor" href="#Governing-Equations">Governing Equations</a><a id="Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Governing-Equations" title="Permalink"></a></h2><p>BioFlows.jl solves the incompressible Navier-Stokes equations in dimensional form:</p><p class="math-container">\[\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u}\]</p><p class="math-container">\[\nabla \cdot \mathbf{u} = 0\]</p><p>where:</p><ul><li><p class="math-container">\[\mathbf{u} = (u, v)\]</p>is the velocity field (m/s)</li><li><p class="math-container">\[p\]</p>is the pressure (Pa)</li><li><p class="math-container">\[\rho\]</p>is the density (kg/m³)</li><li><p class="math-container">\[\nu\]</p>is the kinematic viscosity (m²/s)</li></ul><h2 id="Staggered-Grid-(MAC-Grid)"><a class="docs-heading-anchor" href="#Staggered-Grid-(MAC-Grid)">Staggered Grid (MAC Grid)</a><a id="Staggered-Grid-(MAC-Grid)-1"></a><a class="docs-heading-anchor-permalink" href="#Staggered-Grid-(MAC-Grid)" title="Permalink"></a></h2><p>BioFlows.jl uses a <strong>staggered grid</strong> arrangement, also known as a Marker-And-Cell (MAC) grid. This arrangement naturally satisfies the discrete divergence-free condition and avoids spurious pressure oscillations (checkerboard modes).</p><h3 id="Variable-Locations-in-2D"><a class="docs-heading-anchor" href="#Variable-Locations-in-2D">Variable Locations in 2D</a><a id="Variable-Locations-in-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Locations-in-2D" title="Permalink"></a></h3><p>On a staggered grid, different variables are stored at different locations within each cell:</p><ul><li><strong>Pressure</strong> (<span>$p$</span>): Cell centers</li><li><strong>x-velocity</strong> (<span>$u$</span>): Vertical cell faces (between left/right neighbors)</li><li><strong>y-velocity</strong> (<span>$v$</span>): Horizontal cell faces (between bottom/top neighbors)</li></ul><pre><code class="nohighlight hljs">         Δx
    ├─────────────┤

    ┌─────────────┬─────────────┬─────────────┐  ─┬─
    │             │             │             │   │
    │      ●      v      ●      v      ●      │   │
    │    p_i,j+1  │   p_i+1,j+1 │  p_i+2,j+1  │   │
    │             │             │             │   Δy
    u             u             u             u   │
    │             │             │             │   │
    │      ●      v      ●      v      ●      │  ─┴─
    │    p_i,j    │   p_i+1,j   │  p_i+2,j    │
    │             │             │             │
    u             u             u             u
    │             │             │             │
    │      ●      v      ●      v      ●      │
    │   p_i,j-1   │  p_i+1,j-1  │  p_i+2,j-1  │
    │             │             │             │
    └─────────────┴─────────────┴─────────────┘

    Legend:
    ●  = Pressure (p) at cell center
    u  = x-velocity component at vertical faces
    v  = y-velocity component at horizontal faces</code></pre><h3 id="Detailed-Single-Cell-View"><a class="docs-heading-anchor" href="#Detailed-Single-Cell-View">Detailed Single Cell View</a><a id="Detailed-Single-Cell-View-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-Single-Cell-View" title="Permalink"></a></h3><p>For a single cell <span>$(i,j)$</span>, the staggered arrangement is:</p><pre><code class="nohighlight hljs">                    v[i,j+1]
                       ↑
              ┌────────┼────────┐
              │        │        │
              │        │        │
    u[i,j] ───┼───── p[i,j] ────┼─── u[i+1,j]
      →       │        ●        │       →
              │                 │
              │                 │
              └────────┼────────┘
                       │
                       ↓
                    v[i,j]

    Grid spacing: Δx (horizontal), Δy (vertical)
    Cell center:  (i-½, j-½) in grid coordinates
    u location:   (i, j-½) - on left/right faces
    v location:   (i-½, j) - on bottom/top faces</code></pre><h3 id="Indexing-Convention"><a class="docs-heading-anchor" href="#Indexing-Convention">Indexing Convention</a><a id="Indexing-Convention-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-Convention" title="Permalink"></a></h3><p>In BioFlows.jl, the arrays are indexed as follows:</p><table><tr><th style="text-align: right">Variable</th><th style="text-align: right">Array Index</th><th style="text-align: right">Physical Location</th></tr><tr><td style="text-align: right"><code>p[i,j]</code></td><td style="text-align: right">Cell <span>$(i,j)$</span></td><td style="text-align: right">Center of cell <span>$(i,j)$</span></td></tr><tr><td style="text-align: right"><code>u[i,j,1]</code></td><td style="text-align: right">Face <span>$(i,j)$</span></td><td style="text-align: right">Left face of cell <span>$(i,j)$</span></td></tr><tr><td style="text-align: right"><code>u[i,j,2]</code></td><td style="text-align: right">Face <span>$(i,j)$</span></td><td style="text-align: right">Bottom face of cell <span>$(i,j)$</span></td></tr></table><p>The velocity field is stored in a single array <code>u[I,d]</code> where <code>I</code> is the cell index and <code>d</code> is the direction (1=x, 2=y for 2D; 1=x, 2=y, 3=z for 3D).</p><h2 id="Extension-to-3D"><a class="docs-heading-anchor" href="#Extension-to-3D">Extension to 3D</a><a id="Extension-to-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Extension-to-3D" title="Permalink"></a></h2><p>In three dimensions, the staggered grid extends naturally:</p><ul><li><strong>Pressure</strong> (<span>$p$</span>): Cell centers</li><li><strong>x-velocity</strong> (<span>$u$</span>): yz-faces (perpendicular to x)</li><li><strong>y-velocity</strong> (<span>$v$</span>): xz-faces (perpendicular to y)</li><li><strong>z-velocity</strong> (<span>$w$</span>): xy-faces (perpendicular to z)</li></ul><pre><code class="nohighlight hljs">                        z
                        │   y
                        │  /
                        │ /
                        │/
            ────────────┼──────────── x


                    ┌───────────────────┐
                   /│                  /│
                  / │       w_top     / │
                 /  │       ↑        /  │
                ┌───────────────────┐   │
                │   │      ●        │   │
          u_L → │   │    p_ijk      │ → u_R
                │   │               │   │
                │   └ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ┘
                │  /                │  /
                │ /      ↓         │ /
                │/    w_bottom     │/
                └───────────────────┘
                      ↗       ↘
                   v_front   v_back


    Legend:
    ●     = Pressure at cell center (i,j,k)
    u_L   = u[i,j,k,1] at left face
    u_R   = u[i+1,j,k,1] at right face
    v     = v[i,j,k,2] at front/back faces
    w     = w[i,j,k,3] at top/bottom faces</code></pre><h2 id="Finite-Difference-Operators"><a class="docs-heading-anchor" href="#Finite-Difference-Operators">Finite Difference Operators</a><a id="Finite-Difference-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Operators" title="Permalink"></a></h2><h3 id="Divergence"><a class="docs-heading-anchor" href="#Divergence">Divergence</a><a id="Divergence-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence" title="Permalink"></a></h3><p>The discrete divergence operator at cell center <span>$(i,j)$</span>:</p><p class="math-container">\[(\nabla \cdot \mathbf{u})_{i,j} = \frac{u_{i+1,j} - u_{i,j}}{\Delta x} + \frac{v_{i,j+1} - v_{i,j}}{\Delta y}\]</p><h3 id="Gradient"><a class="docs-heading-anchor" href="#Gradient">Gradient</a><a id="Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient" title="Permalink"></a></h3><p>The discrete pressure gradient at face locations:</p><p class="math-container">\[\left(\frac{\partial p}{\partial x}\right)_{i,j} = \frac{p_{i,j} - p_{i-1,j}}{\Delta x} \quad \text{(at u-location)}\]</p><p class="math-container">\[\left(\frac{\partial p}{\partial y}\right)_{i,j} = \frac{p_{i,j} - p_{i,j-1}}{\Delta y} \quad \text{(at v-location)}\]</p><h3 id="Laplacian"><a class="docs-heading-anchor" href="#Laplacian">Laplacian</a><a id="Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Laplacian" title="Permalink"></a></h3><p>The discrete Laplacian for the Poisson equation:</p><p class="math-container">\[\nabla^2 p_{i,j} = \frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{\Delta x^2} + \frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{\Delta y^2}\]</p><h2 id="Convection-Diffusion-Discretization"><a class="docs-heading-anchor" href="#Convection-Diffusion-Discretization">Convection-Diffusion Discretization</a><a id="Convection-Diffusion-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Convection-Diffusion-Discretization" title="Permalink"></a></h2><p>The momentum equation contains convection and diffusion terms that must be carefully discretized on the staggered grid.</p><h3 id="Momentum-Equation"><a class="docs-heading-anchor" href="#Momentum-Equation">Momentum Equation</a><a id="Momentum-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-Equation" title="Permalink"></a></h3><p>For velocity component <span>$u_i$</span>, the semi-discrete momentum equation is:</p><p class="math-container">\[\frac{\partial u_i}{\partial t} = -\sum_j \frac{\partial (u_j u_i)}{\partial x_j} + \nu \sum_j \frac{\partial^2 u_i}{\partial x_j^2} - \frac{1}{\rho}\frac{\partial p}{\partial x_i}\]</p><p>The convection term <span>$\partial(u_j u_i)/\partial x_j$</span> represents momentum flux in direction <span>$j$</span>, while the diffusion term <span>$\nu \partial^2 u_i/\partial x_j^2$</span> represents viscous stress.</p><h3 id="Finite-Volume-Formulation"><a class="docs-heading-anchor" href="#Finite-Volume-Formulation">Finite Volume Formulation</a><a id="Finite-Volume-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Volume-Formulation" title="Permalink"></a></h3><p>BioFlows.jl uses a <strong>conservative finite volume method (FVM)</strong> where fluxes are computed at cell faces and applied symmetrically to adjacent cells. This ensures exact conservation of momentum.</p><p>For a control volume around velocity <span>$u_i$</span> at location <span>$I$</span>:</p><p class="math-container">\[\frac{d u_i^I}{d t} = \sum_j \left( F_{i,j}^{I} - F_{i,j}^{I-\delta_j} \right)\]</p><p>where <span>$F_{i,j}^I$</span> is the total flux (convective + diffusive) of momentum component <span>$i$</span> through face <span>$j$</span> at index <span>$I$</span>.</p><h3 id="Flux-Computation-at-Cell-Faces"><a class="docs-heading-anchor" href="#Flux-Computation-at-Cell-Faces">Flux Computation at Cell Faces</a><a id="Flux-Computation-at-Cell-Faces-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Computation-at-Cell-Faces" title="Permalink"></a></h3><p>At each face in direction <span>$j$</span>, two fluxes contribute to the momentum balance:</p><h4 id="1.-Convective-Flux"><a class="docs-heading-anchor" href="#1.-Convective-Flux">1. Convective Flux</a><a id="1.-Convective-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Convective-Flux" title="Permalink"></a></h4><p>The convective flux transports momentum with the flow velocity:</p><p class="math-container">\[F_{i,j}^{conv} = \frac{u_j^{face}}{\Delta x_j} \cdot \phi(u_i)\]</p><p>where:</p><ul><li><p class="math-container">\[u_j^{face}\]</p>= face-normal velocity (interpolated to face)</li><li><p class="math-container">\[\phi(u_i)\]</p>= upwind-biased reconstruction of <span>$u_i$</span> at the face</li><li><p class="math-container">\[\Delta x_j\]</p>= grid spacing in direction <span>$j$</span></li></ul><p>The face velocity <span>$u_j^{face}$</span> is computed by interpolation:</p><p class="math-container">\[u_j^{face} = \frac{1}{2}(u_j^L + u_j^R)\]</p><h4 id="2.-Diffusive-Flux"><a class="docs-heading-anchor" href="#2.-Diffusive-Flux">2. Diffusive Flux</a><a id="2.-Diffusive-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Diffusive-Flux" title="Permalink"></a></h4><p>The diffusive flux represents viscous stress:</p><p class="math-container">\[F_{i,j}^{diff} = -\frac{\nu}{\Delta x_j} \left( u_i^I - u_i^{I-\delta_j} \right)\]</p><p>This is a central difference approximation to <span>$-\nu \partial u_i / \partial x_j$</span>.</p><h4 id="Total-Flux"><a class="docs-heading-anchor" href="#Total-Flux">Total Flux</a><a id="Total-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Flux" title="Permalink"></a></h4><p>The total flux at face <span>$I$</span> in direction <span>$j$</span> for momentum component <span>$i$</span>:</p><p class="math-container">\[F_{i,j}^I = F_{i,j}^{conv,I} + F_{i,j}^{diff,I}\]</p><h3 id="Upwind-Schemes-for-Convection"><a class="docs-heading-anchor" href="#Upwind-Schemes-for-Convection">Upwind Schemes for Convection</a><a id="Upwind-Schemes-for-Convection-1"></a><a class="docs-heading-anchor-permalink" href="#Upwind-Schemes-for-Convection" title="Permalink"></a></h3><p>BioFlows.jl implements several upwind schemes for reconstructing face values. Given the stencil values <span>$u_U$</span> (upwind), <span>$u_C$</span> (center), <span>$u_D$</span> (downwind), the schemes compute the face value <span>$\phi$</span>.</p><h4 id="QUICK-with-Median-Limiter"><a class="docs-heading-anchor" href="#QUICK-with-Median-Limiter">QUICK with Median Limiter</a><a id="QUICK-with-Median-Limiter-1"></a><a class="docs-heading-anchor-permalink" href="#QUICK-with-Median-Limiter" title="Permalink"></a></h4><p>BioFlows uses a modified QUICK scheme with a median limiter for stability:</p><p class="math-container">\[\phi_{QUICK} = \text{median}\left( \frac{5u_C + 2u_D - u_U}{6}, \, u_C, \, \text{median}(10u_C - 9u_U, \, u_C, \, u_D) \right)\]</p><p>The median limiter prevents spurious oscillations near discontinuities while maintaining high accuracy in smooth regions. For smooth monotonic profiles, this reduces to the quadratic interpolation <span>$(5u_C + 2u_D - u_U)/6$</span>.</p><p><strong>Code:</strong> <code>quick(u,c,d) = median((5c+2d-u)/6, c, median(10c-9u,c,d))</code></p><h4 id="Van-Leer-(TVD)"><a class="docs-heading-anchor" href="#Van-Leer-(TVD)">Van Leer (TVD)</a><a id="Van-Leer-(TVD)-1"></a><a class="docs-heading-anchor-permalink" href="#Van-Leer-(TVD)" title="Permalink"></a></h4><p>The van Leer scheme uses a monotonicity-preserving limiter:</p><p class="math-container">\[\phi_{vanLeer} = \begin{cases}
u_C &amp; \text{if } u_C \leq \min(u_U, u_D) \text{ or } u_C \geq \max(u_U, u_D) \\
u_C + (u_D - u_C) \cdot \frac{u_C - u_U}{u_D - u_U} &amp; \text{otherwise}
\end{cases}\]</p><p>This ensures the interpolated value lies between neighboring values, preventing oscillations.</p><p><strong>Code:</strong> <code>vanLeer(u,c,d) = (c≤min(u,d) || c≥max(u,d)) ? c : c+(d-c)*(c-u)/(d-u)</code></p><h4 id="Central-Difference-(CDS)"><a class="docs-heading-anchor" href="#Central-Difference-(CDS)">Central Difference (CDS)</a><a id="Central-Difference-(CDS)-1"></a><a class="docs-heading-anchor-permalink" href="#Central-Difference-(CDS)" title="Permalink"></a></h4><p>The central difference scheme provides 2nd-order accuracy but may oscillate:</p><p class="math-container">\[\phi_{CDS} = \frac{u_C + u_D}{2}\]</p><p><strong>Code:</strong> <code>cds(u,c,d) = (c+d)/2</code></p><h4 id="Stencil-Selection"><a class="docs-heading-anchor" href="#Stencil-Selection">Stencil Selection</a><a id="Stencil-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Stencil-Selection" title="Permalink"></a></h4><p>The upwind direction is determined by the face velocity <span>$u_j^{face}$</span>:</p><p class="math-container">\[\phi(u_i) = \begin{cases}
\lambda(u_i^{I-2\delta}, u_i^{I-\delta}, u_i^{I}) &amp; \text{if } u_j^{face} &gt; 0 \\
\lambda(u_i^{I+\delta}, u_i^{I}, u_i^{I-\delta}) &amp; \text{if } u_j^{face} &lt; 0
\end{cases}\]</p><p>where <span>$\lambda$</span> is the chosen scheme (quick, vanLeer, or cds).</p><h3 id="Conservative-Flux-Application"><a class="docs-heading-anchor" href="#Conservative-Flux-Application">Conservative Flux Application</a><a id="Conservative-Flux-Application-1"></a><a class="docs-heading-anchor-permalink" href="#Conservative-Flux-Application" title="Permalink"></a></h3><p>The key feature of FVM is that <strong>the same flux value is added to one cell and subtracted from its neighbor</strong>:</p><pre><code class="nohighlight hljs">Cell I-1:    r[I-1] -= F[I]    (flux leaves)
Cell I:      r[I]   += F[I]    (flux enters)</code></pre><p>This ensures that momentum is exactly conserved — no momentum is created or destroyed at internal faces.</p><pre><code class="nohighlight hljs">        Face I
          ↓
    ┌─────┼─────┐
    │     │     │
    │ I-1 │  I  │
    │     │     │
    └─────┼─────┘
          │
     -F ←─┼─→ +F</code></pre><h3 id="Code-Implementation"><a class="docs-heading-anchor" href="#Code-Implementation">Code Implementation</a><a id="Code-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Implementation" title="Permalink"></a></h3><p>The FVM is implemented in <code>src/Flow.jl</code>. Here&#39;s how the math maps to code:</p><h4 id="Flux-Storage-(Optional)"><a class="docs-heading-anchor" href="#Flux-Storage-(Optional)">Flux Storage (Optional)</a><a id="Flux-Storage-(Optional)-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Storage-(Optional)" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Flow struct fields for explicit flux storage
F_conv :: Array{T,D+2}  # Convective flux F_conv[I,j,i]
F_diff :: Array{T,D+2}  # Diffusive flux F_diff[I,j,i]
store_fluxes :: Bool    # Enable FVM mode</code></pre><p>The flux tensor has indices:</p><ul><li><code>I</code> = spatial cell index (D-dimensional)</li><li><code>j</code> = face direction (1=x, 2=y, 3=z)</li><li><code>i</code> = momentum component</li></ul><h4 id="Computing-Fluxes"><a class="docs-heading-anchor" href="#Computing-Fluxes">Computing Fluxes</a><a id="Computing-Fluxes-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Fluxes" title="Permalink"></a></h4><pre><code class="language-julia hljs"># From compute_face_flux! in src/Flow.jl
for i ∈ 1:n, j ∈ 1:n
    inv_Δxj = 1/Δx[j]
    ν_Δxj = ν/Δx[j]

    # Interior faces
    @loop (
        # Convective flux: (1/Δx) * u_face * ϕ(u)
        F_conv[I,j,i] = inv_Δxj * ϕu(j, CI(I,i), u, ϕ(i,CI(I,j),u), λ);
        # Diffusive flux: -(ν/Δx) * ∂u/∂x
        F_diff[I,j,i] = -ν_Δxj * ∂(j, CI(I,i), u)
    ) over I ∈ inside_u(N,j)

    # Boundary fluxes (one-sided stencils)
    compute_boundary_flux!(...)
end</code></pre><p>Key functions:</p><ul><li><code>ϕ(i,I,u)</code> — Interpolates velocity component <code>i</code> to face location</li><li><code>ϕu(j,I,u,u_face,λ)</code> — Computes upwind flux using scheme <code>λ</code> (quick, vanLeer, cds)</li><li><code>∂(j,I,u)</code> — Central difference <span>$u^I - u^{I-\delta_j}$</span></li></ul><h4 id="Applying-Fluxes-Conservatively"><a class="docs-heading-anchor" href="#Applying-Fluxes-Conservatively">Applying Fluxes Conservatively</a><a id="Applying-Fluxes-Conservatively-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Fluxes-Conservatively" title="Permalink"></a></h4><pre><code class="language-julia hljs"># From apply_fluxes! in src/Flow.jl
for i ∈ 1:n, j ∈ 1:n
    F_total = F_conv[I,j,i] + F_diff[I,j,i]

    # Lower boundary: only flux INTO domain
    @loop r[I,i] += F_total over I ∈ slice(N,2,j,2)

    # Interior: flux enters I, leaves I-δ (CONSERVATIVE!)
    @loop r[I,i] += F_total over I ∈ inside_u(N,j)
    @loop r[I-δ(j,I),i] -= F_total over I ∈ inside_u(N,j)

    # Upper boundary: only flux OUT OF domain
    @loop r[I-δ(j,I),i] -= F_total over I ∈ slice(N,N[j],j,2)
end</code></pre><h3 id="Enabling-FVM-Mode"><a class="docs-heading-anchor" href="#Enabling-FVM-Mode">Enabling FVM Mode</a><a id="Enabling-FVM-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Enabling-FVM-Mode" title="Permalink"></a></h3><p>To use explicit flux storage and verification:</p><pre><code class="language-julia hljs"># Enable FVM with flux storage
sim = Simulation((nx, ny), (Lx, Ly);
                 store_fluxes = true,  # Enable FVM mode
                 ν = 0.01)

# Run simulation
sim_step!(sim)

# Access stored fluxes for analysis
F_conv = sim.flow.F_conv  # Convective fluxes
F_diff = sim.flow.F_diff  # Diffusive fluxes

# Verify conservation (sum of internal fluxes = 0)</code></pre><p>When <code>store_fluxes=false</code> (default), the original method is used which computes fluxes on-the-fly without storing them.</p><h3 id="Boundary-Flux-Treatment"><a class="docs-heading-anchor" href="#Boundary-Flux-Treatment">Boundary Flux Treatment</a><a id="Boundary-Flux-Treatment-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Flux-Treatment" title="Permalink"></a></h3><p>At domain boundaries, fluxes are handled specially since there&#39;s no neighbor cell outside:</p><table><tr><th style="text-align: right">Boundary</th><th style="text-align: right">Treatment</th><th style="text-align: right">Stencil</th></tr><tr><td style="text-align: right">Lower (index 2)</td><td style="text-align: right">One-sided upwind</td><td style="text-align: right"><code>ϕuL</code></td></tr><tr><td style="text-align: right">Upper (index N)</td><td style="text-align: right">One-sided upwind</td><td style="text-align: right"><code>ϕuR</code></td></tr><tr><td style="text-align: right">Periodic</td><td style="text-align: right">Wrap-around</td><td style="text-align: right"><code>ϕuP</code></td></tr></table><pre><code class="language-julia hljs"># Lower boundary: use left-biased stencil
F_conv[I,j,i] = ϕuL(j, I, u, u_face, λ)

# Upper boundary: use right-biased stencil
F_conv[I,j,i] = ϕuR(j, I, u, u_face, λ)

# Periodic: wrap to opposite boundary
F_conv[I,j,i] = ϕuP(j, I_wrapped, I, u, u_face, λ)</code></pre><h3 id="Conservation-Verification"><a class="docs-heading-anchor" href="#Conservation-Verification">Conservation Verification</a><a id="Conservation-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Conservation-Verification" title="Permalink"></a></h3><p>The FVM ensures exact momentum conservation. For a closed system with no external forces:</p><p class="math-container">\[\frac{d}{dt} \sum_I u_i^I \cdot \Delta V = \sum_{\text{boundaries}} F_{i}^{boundary}\]</p><p>Interior fluxes cancel exactly because each internal face contributes:</p><ul><li><p class="math-container">\[+F\]</p>to cell <span>$I$</span></li><li><p class="math-container">\[-F\]</p>to cell <span>$I-\delta$</span></li></ul><p>This property is crucial for accurate long-time simulations and proper vortex dynamics.</p><h2 id="Time-Integration"><a class="docs-heading-anchor" href="#Time-Integration">Time Integration</a><a id="Time-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Integration" title="Permalink"></a></h2><p>BioFlows.jl uses a <strong>2nd-order predictor-corrector</strong> (Heun&#39;s method) combined with pressure projection to ensure incompressibility. This provides 2nd-order temporal accuracy.</p><h3 id="Predictor-Step"><a class="docs-heading-anchor" href="#Predictor-Step">Predictor Step</a><a id="Predictor-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Predictor-Step" title="Permalink"></a></h3><p>First, compute a forward Euler prediction:</p><p class="math-container">\[\mathbf{u}^* = \mathbf{u}^n + \Delta t \left[ -(\mathbf{u}^n \cdot \nabla)\mathbf{u}^n + \nu \nabla^2 \mathbf{u}^n + \mathbf{g} \right]\]</p><p>Then project onto divergence-free space:</p><p class="math-container">\[\nabla^2 \phi = \nabla \cdot \mathbf{u}^*\]</p><p class="math-container">\[\mathbf{u}&#39; = \mathbf{u}^* - \nabla \phi\]</p><h3 id="Corrector-Step"><a class="docs-heading-anchor" href="#Corrector-Step">Corrector Step</a><a id="Corrector-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Corrector-Step" title="Permalink"></a></h3><p>Re-evaluate the right-hand side at the predicted velocity:</p><p class="math-container">\[\mathbf{f}&#39; = -(\mathbf{u}&#39; \cdot \nabla)\mathbf{u}&#39; + \nu \nabla^2 \mathbf{u}&#39; + \mathbf{g}\]</p><p>Average the predictor and corrector contributions (Heun&#39;s method):</p><p class="math-container">\[\mathbf{u}^{**} = \frac{1}{2}\left( \mathbf{u}&#39; + \mathbf{u}^n + \Delta t \, \mathbf{f}&#39; \right)\]</p><p>This is equivalent to the trapezoidal rule:</p><p class="math-container">\[\mathbf{u}^{**} = \mathbf{u}^n + \frac{\Delta t}{2} \left( \mathbf{f}^n + \mathbf{f}&#39; \right)\]</p><p>Finally, project onto divergence-free space:</p><p class="math-container">\[\nabla^2 \psi = \frac{2}{\Delta t} \nabla \cdot \mathbf{u}^{**}\]</p><p class="math-container">\[\mathbf{u}^{n+1} = \mathbf{u}^{**} - \frac{\Delta t}{2} \nabla \psi\]</p><h3 id="Summary-of-the-Algorithm"><a class="docs-heading-anchor" href="#Summary-of-the-Algorithm">Summary of the Algorithm</a><a id="Summary-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-the-Algorithm" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Algorithm: 2nd-order Predictor-Corrector with Pressure Projection
─────────────────────────────────────────────────────────────────
Input: uⁿ (divergence-free velocity at time tⁿ)
Output: uⁿ⁺¹ (divergence-free velocity at time tⁿ⁺¹)

1. Save: u⁰ ← uⁿ

2. PREDICTOR:
   a. f ← RHS(u⁰)                    // Convection + diffusion
   b. u* ← u⁰ + Δt·f                 // Forward Euler
   c. Solve ∇²φ = ∇·u*               // Pressure Poisson
   d. u&#39; ← u* - ∇φ                   // Project to div-free

3. CORRECTOR:
   a. f&#39; ← RHS(u&#39;)                   // Re-evaluate at predicted
   b. u** ← u&#39; + u⁰ + Δt·f&#39;          // Accumulate
   c. u** ← 0.5·u**                  // Average (Heun)
   d. Solve ∇²ψ = (2/Δt)·∇·u**       // Pressure Poisson
   e. uⁿ⁺¹ ← u** - (Δt/2)·∇ψ        // Final projection

4. Compute Δt from CFL condition</code></pre><h3 id="CFL-Condition"><a class="docs-heading-anchor" href="#CFL-Condition">CFL Condition</a><a id="CFL-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#CFL-Condition" title="Permalink"></a></h3><p>The time step is constrained by the CFL (Courant-Friedrichs-Lewy) condition:</p><p class="math-container">\[\Delta t \leq \left( \sum_d \frac{|u_d|}{\Delta x_d} + \sum_d \frac{2\nu}{\Delta x_d^2} \right)^{-1}\]</p><p>where the first term is the convective constraint and the second is the diffusive constraint.</p><h2 id="Pressure-Solver"><a class="docs-heading-anchor" href="#Pressure-Solver">Pressure Solver</a><a id="Pressure-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Pressure-Solver" title="Permalink"></a></h2><p>The pressure Poisson equation is solved using a <strong>geometric multigrid</strong> method with:</p><ul><li>Jacobi smoothing iterations</li><li>Full-weighting restriction</li><li>Bilinear interpolation for prolongation</li><li>V-cycle iteration until convergence</li></ul><p>The multigrid solver operates on a hierarchy of progressively coarser grids, enabling efficient solution of the elliptic pressure equation.</p><h2 id="Immersed-Boundary-Method"><a class="docs-heading-anchor" href="#Immersed-Boundary-Method">Immersed Boundary Method</a><a id="Immersed-Boundary-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-Boundary-Method" title="Permalink"></a></h2><p>BioFlows.jl implements the <strong>Boundary Data Immersion Method (BDIM)</strong> for handling complex geometries. Bodies are defined implicitly through signed distance functions (SDFs):</p><p class="math-container">\[\phi(\mathbf{x}, t) &lt; 0 \quad \text{inside body}\]</p><p class="math-container">\[\phi(\mathbf{x}, t) = 0 \quad \text{on boundary}\]</p><p class="math-container">\[\phi(\mathbf{x}, t) &gt; 0 \quad \text{in fluid}\]</p><p>The SDF is used to:</p><ol><li>Identify solid and fluid regions</li><li>Interpolate boundary conditions</li><li>Compute surface normals: <span>$\mathbf{n} = \nabla\phi / |\nabla\phi|$</span></li><li>Calculate hydrodynamic forces on immersed bodies</li></ol><h2 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h2><p>BioFlows.jl supports three types of boundary conditions for the domain boundaries (not to be confused with immersed body boundaries handled by BDIM).</p><h3 id="Domain-Boundary-Overview"><a class="docs-heading-anchor" href="#Domain-Boundary-Overview">Domain Boundary Overview</a><a id="Domain-Boundary-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-Boundary-Overview" title="Permalink"></a></h3><pre><code class="nohighlight hljs">                    Top boundary (j = nz)
                    ─────────────────────
                    │                   │
                    │                   │
    Inlet           │                   │    Outlet
    (i = 1)         │     Domain        │    (i = nx)
    inletBC         │                   │    outletBC
                    │                   │
                    │                   │
                    ─────────────────────
                    Bottom boundary (j = 1)</code></pre><h3 id="1.-Inlet-Boundary-Condition-(inletBC)"><a class="docs-heading-anchor" href="#1.-Inlet-Boundary-Condition-(inletBC)">1. Inlet Boundary Condition (<code>inletBC</code>)</a><a id="1.-Inlet-Boundary-Condition-(inletBC)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Inlet-Boundary-Condition-(inletBC)" title="Permalink"></a></h3><p>The inlet boundary (at <span>$x = 0$</span>) uses a <strong>Dirichlet condition</strong> where velocity is prescribed.</p><h4 id="Constant-Inlet"><a class="docs-heading-anchor" href="#Constant-Inlet">Constant Inlet</a><a id="Constant-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-Inlet" title="Permalink"></a></h4><p>For uniform inflow, specify a tuple:</p><pre><code class="language-julia hljs">inletBC = (U, 0.0)  # u = U, v = 0 at inlet</code></pre><p>This sets:</p><p class="math-container">\[u(0, y, t) = U, \quad v(0, y, t) = 0\]</p><h4 id="Spatially-Varying-Inlet"><a class="docs-heading-anchor" href="#Spatially-Varying-Inlet">Spatially-Varying Inlet</a><a id="Spatially-Varying-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Spatially-Varying-Inlet" title="Permalink"></a></h4><p>For non-uniform profiles (e.g., parabolic channel flow), use a function:</p><pre><code class="language-julia hljs"># Parabolic profile: u(y) = U_max * (1 - (y-H)²/H²)
H = Ly / 2  # channel half-height
U_max = 1.5
inletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0</code></pre><p>The function signature is <code>inletBC(i, x, t)</code> where:</p><ul><li><code>i</code> = velocity component (1 = x, 2 = y/z)</li><li><code>x</code> = position vector</li><li><code>t</code> = time</li></ul><h4 id="Time-Varying-Inlet"><a class="docs-heading-anchor" href="#Time-Varying-Inlet">Time-Varying Inlet</a><a id="Time-Varying-Inlet-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Varying-Inlet" title="Permalink"></a></h4><p>For pulsatile or oscillating inflow:</p><pre><code class="language-julia hljs"># Oscillating inlet: u(t) = U₀(1 + A·sin(ωt))
inletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(2π*t)) : 0.0</code></pre><div class="admonition is-info" id="Velocity-Scale-Required-6c158d793f69d119"><header class="admonition-header">Velocity Scale Required<a class="admonition-anchor" href="#Velocity-Scale-Required-6c158d793f69d119" title="Permalink"></a></header><div class="admonition-body"><p>When using a function for <code>inletBC</code>, you must specify <code>U</code> (velocity scale) explicitly since it cannot be auto-computed.</p></div></div><h3 id="2.-Convective-Outlet-Boundary-Condition-(outletBC)"><a class="docs-heading-anchor" href="#2.-Convective-Outlet-Boundary-Condition-(outletBC)">2. Convective Outlet Boundary Condition (<code>outletBC</code>)</a><a id="2.-Convective-Outlet-Boundary-Condition-(outletBC)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Convective-Outlet-Boundary-Condition-(outletBC)" title="Permalink"></a></h3><p>The outlet boundary (at <span>$x = L_x$</span>) is the most challenging because <strong>we don&#39;t know the flow state there in advance</strong>. Simple conditions like zero-gradient (<span>$\partial u/\partial x = 0$</span>) cause <strong>spurious reflections</strong> — pressure waves bounce back into the domain and contaminate the solution.</p><h4 id="The-Convective-BC-Approach"><a class="docs-heading-anchor" href="#The-Convective-BC-Approach">The Convective BC Approach</a><a id="The-Convective-BC-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-Convective-BC-Approach" title="Permalink"></a></h4><p>The convective (or advective) outlet condition assumes flow structures are <strong>transported out</strong> of the domain at a convection velocity <span>$U_c$</span>:</p><p class="math-container">\[\frac{\partial u}{\partial t} + U_c \frac{\partial u}{\partial x} = 0\]</p><p>This is a 1D wave equation that advects the local velocity pattern out of the domain.</p><h4 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h4><p>Using first-order upwind differencing:</p><p class="math-container">\[u_i^{n+1} = u_i^n - U_c \Delta t \frac{u_i^n - u_{i-1}^n}{\Delta x}\]</p><p>In BioFlows, <span>$U_c$</span> is taken as the mean inlet velocity to ensure mass conservation.</p><h4 id="Mass-Conservation-Correction"><a class="docs-heading-anchor" href="#Mass-Conservation-Correction">Mass Conservation Correction</a><a id="Mass-Conservation-Correction-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Conservation-Correction" title="Permalink"></a></h4><p>After applying the convective BC, a correction ensures global mass conservation:</p><p class="math-container">\[\oint u \, dA = 0 \quad \text{(for incompressible flow)}\]</p><p>The outlet velocity is adjusted so that mass flux out equals mass flux in:</p><pre><code class="language-julia hljs"># From src/util.jl - exitBC!
U = mean(u_inlet)           # Average inlet flux
u_outlet = u_outlet - Δt * U * ∂u/∂x  # Convective update
correction = mean(u_outlet) - U       # Mass imbalance
u_outlet = u_outlet - correction      # Enforce conservation</code></pre><h4 id="Why-Convective-BC-Works"><a class="docs-heading-anchor" href="#Why-Convective-BC-Works">Why Convective BC Works</a><a id="Why-Convective-BC-Works-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Convective-BC-Works" title="Permalink"></a></h4><pre><code class="nohighlight hljs">Without Convective BC:              With Convective BC:

    ────────────────────┐              ────────────────────→
    Vortex → → → ↩ ↩ ↩  │              Vortex → → → → → →
    ────────────────────┘              ────────────────────→
                ↑                                  ↑
          Reflection!                      Passes through</code></pre><p>The convective BC allows vortices, wakes, and other flow structures to exit smoothly without generating artificial reflections.</p><h4 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h4><pre><code class="language-julia hljs">sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (1.0, 0.0),
                 outletBC = true)      # Enable convective outlet</code></pre><h3 id="3.-Periodic-Boundary-Condition-(perdir)"><a class="docs-heading-anchor" href="#3.-Periodic-Boundary-Condition-(perdir)">3. Periodic Boundary Condition (<code>perdir</code>)</a><a id="3.-Periodic-Boundary-Condition-(perdir)-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Periodic-Boundary-Condition-(perdir)" title="Permalink"></a></h3><p>Periodic boundaries make the domain wrap around — flow exiting one side re-enters from the opposite side.</p><p class="math-container">\[u(x, 0, t) = u(x, L_y, t), \quad v(x, 0, t) = v(x, L_y, t)\]</p><h4 id="When-to-Use-Periodic-BC"><a class="docs-heading-anchor" href="#When-to-Use-Periodic-BC">When to Use Periodic BC</a><a id="When-to-Use-Periodic-BC-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Periodic-BC" title="Permalink"></a></h4><table><tr><th style="text-align: right">Scenario</th><th style="text-align: right">Direction</th><th style="text-align: right">Example</th></tr><tr><td style="text-align: right">Infinite span</td><td style="text-align: right">z (spanwise)</td><td style="text-align: right">Flow past cylinder</td></tr><tr><td style="text-align: right">Channel flow</td><td style="text-align: right">x (streamwise)</td><td style="text-align: right">Fully-developed pipe flow</td></tr><tr><td style="text-align: right">Homogeneous turbulence</td><td style="text-align: right">All</td><td style="text-align: right">Isotropic turbulence box</td></tr></table><h4 id="Usage-2"><a class="docs-heading-anchor" href="#Usage-2">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-2" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Periodic in z-direction (direction 2)
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (1.0, 0.0),
                 perdir = (2,))

# Periodic in both y and z (3D)
sim = Simulation((nx, ny, nz), (Lx, Ly, Lz);
                 inletBC = (1.0, 0.0, 0.0),
                 perdir = (2, 3))</code></pre><h3 id="4.-Default-(No-Flux)-Boundaries"><a class="docs-heading-anchor" href="#4.-Default-(No-Flux)-Boundaries">4. Default (No-Flux) Boundaries</a><a id="4.-Default-(No-Flux)-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Default-(No-Flux)-Boundaries" title="Permalink"></a></h3><p>Boundaries not explicitly set use a <strong>zero normal gradient</strong> (Neumann) condition:</p><p class="math-container">\[\frac{\partial u}{\partial n} = 0\]</p><p>This is appropriate for:</p><ul><li>Slip walls (free-slip, no penetration)</li><li>Symmetry planes</li><li>Far-field boundaries (approximate)</li></ul><h3 id="Boundary-Condition-Summary"><a class="docs-heading-anchor" href="#Boundary-Condition-Summary">Boundary Condition Summary</a><a id="Boundary-Condition-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Condition-Summary" title="Permalink"></a></h3><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Condition</th><th style="text-align: right">Mathematical Form</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right"><code>inletBC</code></td><td style="text-align: right">Dirichlet</td><td style="text-align: right"><span>$u = u_{prescribed}$</span></td><td style="text-align: right">Inflow boundaries</td></tr><tr><td style="text-align: right"><code>outletBC=true</code></td><td style="text-align: right">Convective</td><td style="text-align: right"><span>$\partial_t u + U \partial_x u = 0$</span></td><td style="text-align: right">Outflow (prevents reflections)</td></tr><tr><td style="text-align: right"><code>perdir=(d,)</code></td><td style="text-align: right">Periodic</td><td style="text-align: right"><span>$u(0) = u(L)$</span></td><td style="text-align: right">Infinite/repeating domains</td></tr><tr><td style="text-align: right">(default)</td><td style="text-align: right">Neumann</td><td style="text-align: right"><span>$\partial_n u = 0$</span></td><td style="text-align: right">Slip walls, symmetry</td></tr></table><h3 id="Common-Configurations"><a class="docs-heading-anchor" href="#Common-Configurations">Common Configurations</a><a id="Common-Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Configurations" title="Permalink"></a></h3><h4 id="External-Flow-(Wake-Problems)"><a class="docs-heading-anchor" href="#External-Flow-(Wake-Problems)">External Flow (Wake Problems)</a><a id="External-Flow-(Wake-Problems)-1"></a><a class="docs-heading-anchor-permalink" href="#External-Flow-(Wake-Problems)" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Flow past cylinder: inlet + convective outlet + periodic spanwise
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0),
                 outletBC = true,
                 perdir = (2,),
                 body = AutoBody(sdf))</code></pre><h4 id="Channel-Flow"><a class="docs-heading-anchor" href="#Channel-Flow">Channel Flow</a><a id="Channel-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Channel-Flow" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Fully-developed channel: periodic streamwise + no-slip walls
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0),
                 perdir = (1,))  # Periodic in x (streamwise)</code></pre><h4 id="Closed-Cavity"><a class="docs-heading-anchor" href="#Closed-Cavity">Closed Cavity</a><a id="Closed-Cavity-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-Cavity" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Lid-driven cavity: no outlet, no periodic
sim = Simulation((nx, nz), (Lx, Lz);
                 inletBC = (U, 0.0))  # Top wall moves at U</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li><p>Harlow, F.H. and Welch, J.E. (1965). &quot;Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface.&quot; <em>Physics of Fluids</em>, 8(12), 2182-2189.</p></li><li><p>Weymouth, G.D. and Yue, D.K.P. (2011). &quot;Boundary data immersion method for Cartesian-grid simulations of fluid-body interaction problems.&quot; <em>Journal of Computational Physics</em>, 230(16), 6233-6247.</p></li><li><p>Orlanski, I. (1976). &quot;A simple boundary condition for unbounded hyperbolic flows.&quot; <em>Journal of Computational Physics</em>, 21(3), 251-269.</p></li><li><p>Leonard, B.P. (1979). &quot;A stable and accurate convective modelling procedure based on quadratic upstream interpolation.&quot; <em>Computer Methods in Applied Mechanics and Engineering</em>, 19(1), 59-98. (QUICK scheme)</p></li><li><p>Van Leer, B. (1979). &quot;Towards the ultimate conservative difference scheme. V. A second-order sequel to Godunov&#39;s method.&quot; <em>Journal of Computational Physics</em>, 32(1), 101-136. (Van Leer limiter)</p></li><li><p>Versteeg, H.K. and Malalasekera, W. (2007). <em>An Introduction to Computational Fluid Dynamics: The Finite Volume Method</em>. Pearson Education.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../core_types/">Core Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 23 December 2025 17:40">Tuesday 23 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
