var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides a quick reference to all exported functions and types. See the linked pages for detailed documentation.","category":"section"},{"location":"api/#Simulation-Types","page":"API Reference","title":"Simulation Types","text":"See Core Types for details.\n\nType Description\nSimulation Main simulation container\nAMRSimulation Simulation with adaptive mesh refinement\nAMRConfig Configuration for AMR\nFlow Fluid field storage (velocity, pressure)\nAutoBody Implicit geometry via signed distance function","category":"section"},{"location":"api/#Simulation-Control","page":"API Reference","title":"Simulation Control","text":"See Core Types for details.\n\nFunction Description\nsim_step!(sim) Advance one time step\nsim_step!(sim, t_end) Advance to target time\nsim_time(sim) Get dimensionless time (t*U/L)\nmeasure!(sim) Update body coefficients\nperturb!(sim) Add velocity perturbations\nsim_info(sim) Print simulation status","category":"section"},{"location":"api/#AMR-Functions","page":"API Reference","title":"AMR Functions","text":"See Adaptive Mesh Refinement for details.\n\nFunction Description\namr_regrid!(sim) Force regridding\nset_amr_active!(sim, bool) Enable/disable AMR\nget_refinement_indicator(sim) Get current indicator field\nnum_refined_cells(grid) Count refined cells\nrefinement_level(grid, i, j) Query cell refinement level\namr_info(sim) Print AMR status and statistics\ncheck_divergence(sim) Check velocity divergence on all levels\namr_cfl(flow, cp) Compute CFL considering refined patches\nsynchronize_base_and_patches!(flow, cp) Sync data between base and patches","category":"section"},{"location":"api/#Force-Diagnostics","page":"API Reference","title":"Force Diagnostics","text":"See Diagnostics for details.\n\nFunction Description\npressure_force(sim) Pressure force vector\nviscous_force(sim) Viscous force vector\ntotal_force(sim) Total force vector\nforce_components(sim) All forces + coefficients\nforce_coefficients(sim) Dimensionless coefficients\nrecord_force!(history, sim) Append to force history","category":"section"},{"location":"api/#Vorticity-Functions","page":"API Reference","title":"Vorticity Functions","text":"See Diagnostics for details.\n\nFunction Description\nvorticity_component(sim, i) i-th vorticity component\nvorticity_magnitude(sim) Vorticity magnitude field\ncell_center_velocity(sim) Interpolated velocity at cell centers\ncell_center_vorticity(sim) Interpolated vorticity at cell centers\ncell_center_pressure(sim) Pressure at cell centers","category":"section"},{"location":"api/#Output","page":"API Reference","title":"Output","text":"Function Description\nCenterFieldWriter(file; interval) Create JLD2 snapshot writer\nForceWriter(file; interval) Create JLD2 force coefficient writer\nfile_save!(writer, sim) Save snapshot if interval elapsed","category":"section"},{"location":"api/#Exported-Symbols","page":"API Reference","title":"Exported Symbols","text":"","category":"section"},{"location":"api/#From-BioFlows.jl","page":"API Reference","title":"From BioFlows.jl","text":"# Simulation\nSimulation, AbstractSimulation, sim_step!, sim_time, measure!, sim_info, perturb!\n\n# AMR\nAMRSimulation, AMRConfig, amr_regrid!, set_amr_active!, get_refinement_indicator\n\n# Flow\nFlow, mom_step!, quick, cds\n\n# Pressure\nAbstractPoisson, Poisson, MultiLevelPoisson, solver!, mult!\n\n# Bodies\nAbstractBody, AutoBody, measure_sdf!, sdf, measure\n\n# Diagnostics\npressure_force, viscous_force, total_force, force_components, force_coefficients, record_force!\nvorticity_component, vorticity_magnitude, cell_center_velocity, cell_center_vorticity, cell_center_pressure\ncurl, ω, ω_mag\ncompute_diagnostics, summarize_force_history\n\n# Output\nCenterFieldWriter, ForceWriter, file_save!\n\n# AMR Types\nStaggeredGrid, SolutionState, RefinedGrid, GridType, TwoDimensional, ThreeDimensional\nis_2d, is_3d, num_refined_cells, refinement_level, domain_size, cell_volume\nFlowToGridAdapter, flow_to_staggered_grid, flow_to_solution_state, create_refined_grid\ncompute_body_refinement_indicator, compute_velocity_gradient_indicator\ncompute_vorticity_indicator, compute_combined_indicator\nmark_cells_for_refinement, apply_buffer_zone!\n\n# AMR Composite Solver\nCompositePoisson, PatchPoisson, RefinedVelocityField, RefinedVelocityPatch\nadd_patch!, remove_patch!, get_patch, clear_patches!, has_patches, num_patches\ncreate_patches!, update_patches!, ensure_proper_nesting!\namr_project!, amr_mom_step!, check_amr_divergence, regrid_amr!\namr_cfl, synchronize_base_and_patches!, interpolate_velocity_to_patches!\namr_info, check_divergence\n\n# Utilities\nL₂, BC!, @inside, inside, δ, apply!, loc, @log, set_backend, backend\n\n# Statistics\nMeanFlow, update!, uu!, uu","category":"section"},{"location":"amr/#Adaptive-Mesh-Refinement","page":"Adaptive Mesh Refinement","title":"Adaptive Mesh Refinement","text":"BioFlows includes an Adaptive Mesh Refinement (AMR) system that automatically refines the computational grid near immersed bodies and regions of high flow gradients.","category":"section"},{"location":"amr/#AMRSimulation","page":"Adaptive Mesh Refinement","title":"AMRSimulation","text":"The AMRSimulation type wraps a standard Simulation and adds AMR capability.","category":"section"},{"location":"amr/#Basic-Usage","page":"Adaptive Mesh Refinement","title":"Basic Usage","text":"using BioFlows\n\n# Define geometry\nradius = 8\ncenter = 64\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Configure AMR\nconfig = AMRConfig(\n    max_level = 2,                     # Max refinement (2x, 4x resolution)\n    body_distance_threshold = 3.0,     # Refine within 3 cells of body\n    velocity_gradient_threshold = 1.0,\n    vorticity_threshold = 1.0,\n    regrid_interval = 10,              # Check regridding every 10 steps\n    buffer_size = 1                    # Buffer cells around refined regions\n)\n\n# Create AMR simulation\nsim = AMRSimulation((128, 128), (1.0, 0.0), 2radius;\n                    ν = 2radius / 200,\n                    body = AutoBody(sdf),\n                    amr_config = config)\n\n# Time integration (regridding happens automatically)\nfor step in 1:1000\n    sim_step!(sim; remeasure=true)\nend\n\n# Check refinement\nprintln(\"Refined cells: \", num_refined_cells(sim.refined_grid))","category":"section"},{"location":"amr/#AMRConfig-Parameters","page":"Adaptive Mesh Refinement","title":"AMRConfig Parameters","text":"Parameter Default Description\nmax_level 2 Maximum refinement level (1=2x, 2=4x, etc.)\nbody_distance_threshold 3.0 Refine within this distance from body (cells)\nvelocity_gradient_threshold 1.0 Threshold for velocity gradient indicator\nvorticity_threshold 1.0 Threshold for vorticity-based refinement\nregrid_interval 10 Steps between regridding checks\nbuffer_size 1 Buffer cells around refined regions\nbody_weight 0.5 Weight for body proximity in combined indicator\ngradient_weight 0.3 Weight for velocity gradient\nvorticity_weight 0.2 Weight for vorticity","category":"section"},{"location":"amr/#Refinement-Indicators","page":"Adaptive Mesh Refinement","title":"Refinement Indicators","text":"The AMR system uses multiple indicators to decide where to refine:","category":"section"},{"location":"amr/#Body-Distance-Indicator","page":"Adaptive Mesh Refinement","title":"Body Distance Indicator","text":"Refines cells near the immersed body surface:\n\nindicator = compute_body_refinement_indicator(flow, body;\n    threshold=config.body_distance_threshold, t=t)","category":"section"},{"location":"amr/#Velocity-Gradient-Indicator","page":"Adaptive Mesh Refinement","title":"Velocity Gradient Indicator","text":"Refines regions of high velocity gradients:\n\nindicator = compute_velocity_gradient_indicator(flow;\n    threshold=config.velocity_gradient_threshold)","category":"section"},{"location":"amr/#Vorticity-Indicator","page":"Adaptive Mesh Refinement","title":"Vorticity Indicator","text":"Refines regions of high vorticity:\n\nindicator = compute_vorticity_indicator(flow;\n    threshold=config.vorticity_threshold)","category":"section"},{"location":"amr/#Combined-Indicator","page":"Adaptive Mesh Refinement","title":"Combined Indicator","text":"Combines all indicators with configurable weights:\n\nindicator = compute_combined_indicator(flow, body;\n    body_threshold=3.0,\n    gradient_threshold=1.0,\n    vorticity_threshold=1.0,\n    t=0.0,\n    body_weight=0.5,\n    gradient_weight=0.3,\n    vorticity_weight=0.2\n)","category":"section"},{"location":"amr/#AMR-Control","page":"Adaptive Mesh Refinement","title":"AMR Control","text":"","category":"section"},{"location":"amr/#Enable/Disable-AMR","page":"Adaptive Mesh Refinement","title":"Enable/Disable AMR","text":"# Disable regridding (keep current mesh)\nset_amr_active!(sim, false)\n\n# Re-enable\nset_amr_active!(sim, true)","category":"section"},{"location":"amr/#Force-Regridding","page":"Adaptive Mesh Refinement","title":"Force Regridding","text":"amr_regrid!(sim)","category":"section"},{"location":"amr/#Query-Refinement","page":"Adaptive Mesh Refinement","title":"Query Refinement","text":"# Number of refined cells\nn = num_refined_cells(sim.refined_grid)\n\n# Refinement level at specific cell (0 = base, 1+ = refined)\nlevel = refinement_level(sim.refined_grid, i, j)\n\n# Get current indicator field (for visualization)\nindicator = get_refinement_indicator(sim)","category":"section"},{"location":"amr/#Grid-Types","page":"Adaptive Mesh Refinement","title":"Grid Types","text":"","category":"section"},{"location":"amr/#StaggeredGrid","page":"Adaptive Mesh Refinement","title":"StaggeredGrid","text":"The base grid type using MAC (Marker-And-Cell) layout:\n\nVelocities at face centers\nPressure at cell centers\nSupports 2D (XZ plane) and 3D","category":"section"},{"location":"amr/#RefinedGrid","page":"Adaptive Mesh Refinement","title":"RefinedGrid","text":"Container for AMR data:\n\nTracks:\n\nBase (coarse) grid\nRefined cell locations and levels\nLocal refined sub-grids\nInterpolation weights","category":"section"},{"location":"amr/#Performance-Considerations","page":"Adaptive Mesh Refinement","title":"Performance Considerations","text":"Regrid Interval: Larger intervals reduce overhead but may miss features\nBuffer Size: Prevents refinement boundaries from affecting solution\nMax Level: Higher levels increase accuracy but add cost\nIndicator Weights: Tune based on flow physics","category":"section"},{"location":"amr/#Example:-Wake-Refinement","page":"Adaptive Mesh Refinement","title":"Example: Wake Refinement","text":"# Emphasize wake region (high vorticity) over body proximity\nconfig = AMRConfig(\n    max_level = 3,\n    body_weight = 0.2,        # Less emphasis on body\n    gradient_weight = 0.3,\n    vorticity_weight = 0.5,   # More emphasis on wake\n    regrid_interval = 20\n)","category":"section"},{"location":"amr/#Composite-Solver-(Advanced)","page":"Adaptive Mesh Refinement","title":"Composite Solver (Advanced)","text":"For advanced users, BioFlows exposes the internal composite solver types used for AMR pressure projection.","category":"section"},{"location":"amr/#CompositePoisson","page":"Adaptive Mesh Refinement","title":"CompositePoisson","text":"The composite Poisson solver combines a base multigrid solver with refined patches:\n\n# CompositePoisson manages:\n# - Base grid: MultiLevelPoisson for coarse solution\n# - Patches: PatchPoisson solvers for refined regions\n# - Velocity: RefinedVelocityField for patch velocities","category":"section"},{"location":"amr/#Patch-Types","page":"Adaptive Mesh Refinement","title":"Patch Types","text":"Type Description\nPatchPoisson Local Poisson solver for a refined patch\nRefinedVelocityPatch Velocity storage at refined resolution\nRefinedVelocityField Collection of velocity patches","category":"section"},{"location":"amr/#Patch-Operations","page":"Adaptive Mesh Refinement","title":"Patch Operations","text":"# Add/remove patches\nadd_patch!(field, anchor, patch)\nremove_patch!(field, anchor)\nget_patch(field, anchor)\nclear_patches!(field)\n\n# Query patches\nhas_patches(cp)\nnum_patches(cp)","category":"section"},{"location":"amr/#AMR-Projection","page":"Adaptive Mesh Refinement","title":"AMR Projection","text":"The amr_project! function performs divergence-free projection on all levels:\n\n# Full AMR projection workflow:\n# 1. Set divergence on base grid\n# 2. Set divergence on refined patches\n# 3. Interpolate velocity to patches\n# 4. Solve composite Poisson system\n# 5. Correct velocities at all levels\n# 6. Enforce interface consistency\n\namr_project!(flow, cp)","category":"section"},{"location":"amr/#Utility-Functions","page":"Adaptive Mesh Refinement","title":"Utility Functions","text":"Function Description\namr_cfl(flow, cp) CFL considering refined patches\ncheck_amr_divergence(flow, cp) Divergence at all levels\nsynchronize_base_and_patches!(flow, cp) Sync after regridding","category":"section"},{"location":"amr/#BioFlows.AMRSimulation","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRSimulation","text":"AMRSimulation\n\nSimulation with adaptive mesh refinement near immersed bodies.\n\nWraps a standard Simulation and adds AMR capability that automatically refines the mesh near the body and in regions of high gradients.\n\nFields\n\nsim: The underlying Simulation\nconfig: AMR configuration parameters\nrefined_grid: Current refined grid state\ncomposite_pois: CompositePoisson solver for AMR (manages base + patches)\nadapter: Flow-to-grid adapter\nlast_regrid_step: Step count at last regrid\namr_active: Whether AMR is currently active\n\nExample\n\nconfig = AMRConfig(max_level=3, body_distance_threshold=4.0, regrid_interval=5)\nsim = AMRSimulation((128, 128), (1.0, 0.0), 16.0;\n                    ν=0.01, body=AutoBody(sdf), amr_config=config)\nfor _ in 1:1000\n    sim_step!(sim; remeasure=true)  # AMR regridding happens automatically\nend\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.AMRConfig","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRConfig","text":"AMRConfig\n\nConfiguration for adaptive mesh refinement.\n\nFields\n\nmax_level: Maximum refinement level (1 = 2x finer, 2 = 4x finer, etc.)\nbody_distance_threshold: Refine within this distance (in grid cells) from body\nvelocity_gradient_threshold: Threshold for velocity gradient refinement\nvorticity_threshold: Threshold for vorticity-based refinement\nregrid_interval: Number of time steps between regridding checks\nbuffer_size: Number of buffer cells around refined regions\nbody_weight: Weight for body proximity in combined indicator\ngradient_weight: Weight for velocity gradient in combined indicator\nvorticity_weight: Weight for vorticity in combined indicator\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.StaggeredGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.StaggeredGrid","text":"StaggeredGrid\n\nRepresents a staggered (MAC) grid for CFD computations. Velocity components are stored at face centers, pressure at cell centers.\n\nFields\n\ngrid_type: Dimensionality (TwoDimensional or ThreeDimensional)\nnx, ny, nz: Number of cells in each direction (ny=1 for 2D)\ndx, dy, dz: Cell spacing in each direction\nx, y, z: Cell center coordinates\nxf, yf, zf: Face coordinates (staggered locations)\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.RefinedGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.RefinedGrid","text":"RefinedGrid\n\nContainer for adaptive mesh refinement data. Stores the base grid and tracking information for refined cells.\n\nFields\n\nbase_grid: The coarse/base level grid\nrefined_cells_2d/3d: Dict mapping cell indices to refinement level\nrefined_grids_2d/3d: Dict mapping cell indices to local refined StaggeredGrid\ninterpolation_weights_2d/3d: Pre-computed interpolation weights\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"BioFlows provides built-in diagnostics for forces, vorticity, and flow statistics.","category":"section"},{"location":"diagnostics/#Force-Computation","page":"Diagnostics","title":"Force Computation","text":"","category":"section"},{"location":"diagnostics/#Force-Components","page":"Diagnostics","title":"Force Components","text":"","category":"section"},{"location":"diagnostics/#Usage","page":"Diagnostics","title":"Usage","text":"using BioFlows\n\n# Get all force components\ncomponents = force_components(sim; ρ=1.0, reference_area=sim.L)\n\n# Access individual forces\npressure_force = components.pressure   # [Fx, Fz] or [Fx, Fy, Fz]\nviscous_force = components.viscous\ntotal_force = components.total\n\n# Dimensionless coefficients\nCd, Cl = components.coefficients[3]  # Total force coefficients","category":"section"},{"location":"diagnostics/#Force-History","page":"Diagnostics","title":"Force History","text":"Record forces over time for analysis:\n\nhistory = NamedTuple[]\n\nfor step in 1:1000\n    sim_step!(sim)\n    record_force!(history, sim; ρ=1.0, reference_area=sim.L)\nend\n\n# Access recorded data\ntimes = [h.time for h in history]\ndrag_coeffs = [h.total_coeff[1] for h in history]\nlift_coeffs = [h.total_coeff[2] for h in history]","category":"section"},{"location":"diagnostics/#Force-Statistics","page":"Diagnostics","title":"Force Statistics","text":"# Compute mean and RMS after discarding transient\nstats = summarize_force_history(history; discard=0.2)  # Discard first 20%\n\nprintln(\"Mean drag: \", stats.drag_mean)\nprintln(\"Drag std:  \", stats.drag_std)\nprintln(\"Mean lift: \", stats.lift_mean)\nprintln(\"Lift std:  \", stats.lift_std)","category":"section"},{"location":"diagnostics/#Automatic-Force-File-Output","page":"Diagnostics","title":"Automatic Force File Output","text":"Use ForceWriter to automatically save lift and drag coefficients to a JLD2 file at specified time intervals:\n\nusing BioFlows\n\n# Create simulation\nsim = Simulation((128, 128), (1.0, 0.0), 1.0; ν=0.001, body=AutoBody(sdf))\n\n# Create force writer - saves every 0.1 time units\nforce_writer = ForceWriter(\"forces.jld2\"; interval=0.1, reference_area=sim.L)\n\n# Time stepping loop\nfor _ in 1:5000\n    sim_step!(sim)\n    file_save!(force_writer, sim)  # Writes to JLD2 when interval elapsed\nend\n\nThe JLD2 file contains arrays: time, Cd, Cl, Cd_pressure, Cd_viscous, Cl_pressure, Cl_viscous.\n\n# Read the output file\nusing JLD2\ndata = load(\"forces.jld2\")\ntime = data[\"time\"]\nCd = data[\"Cd\"]\nCl = data[\"Cl\"]","category":"section"},{"location":"diagnostics/#Vorticity","page":"Diagnostics","title":"Vorticity","text":"","category":"section"},{"location":"diagnostics/#Vorticity-Fields","page":"Diagnostics","title":"Vorticity Fields","text":"","category":"section"},{"location":"diagnostics/#Usage-2","page":"Diagnostics","title":"Usage","text":"# Out-of-plane vorticity for 2D (ω₃ = ∂v/∂x - ∂u/∂z)\nω3 = vorticity_component(sim, 3)\n\n# Vorticity magnitude\nω_mag = vorticity_magnitude(sim)\n\n# For 3D simulations\nωx = vorticity_component(sim, 1)\nωy = vorticity_component(sim, 2)\nωz = vorticity_component(sim, 3)","category":"section"},{"location":"diagnostics/#Ghost-Layer-Handling","page":"Diagnostics","title":"Ghost Layer Handling","text":"By default, ghost layers are stripped from output:\n\n# With ghost layers stripped (default)\nω = vorticity_component(sim, 3; strip_ghosts=true)\n\n# Keep ghost layers\nω_with_ghosts = vorticity_component(sim, 3; strip_ghosts=false)","category":"section"},{"location":"diagnostics/#Cell-Centered-Fields","page":"Diagnostics","title":"Cell-Centered Fields","text":"For visualization and output, interpolate to cell centers:","category":"section"},{"location":"diagnostics/#Usage-3","page":"Diagnostics","title":"Usage","text":"# Cell-centered velocity [nx, nz, 2] or [nx, ny, nz, 3]\nvel = cell_center_velocity(sim)\n\n# Cell-centered vorticity\n# 2D: scalar field [nx, nz]\n# 3D: vector field [nx, ny, nz, 3]\nvort = cell_center_vorticity(sim)\n\n# Cell-centered pressure [nx, nz] or [nx, ny, nz]\npres = cell_center_pressure(sim)","category":"section"},{"location":"diagnostics/#Simulation-Diagnostics","page":"Diagnostics","title":"Simulation Diagnostics","text":"The compute_diagnostics function returns summary statistics for the current simulation state.","category":"section"},{"location":"diagnostics/#Usage-4","page":"Diagnostics","title":"Usage","text":"diag = compute_diagnostics(sim)\n\nprintln(\"Max u-velocity: \", diag.max_u)\nprintln(\"Max w-velocity: \", diag.max_w)\nprintln(\"CFL number:     \", diag.CFL)\nprintln(\"Time step:      \", diag.Δt)\nprintln(\"Grid size:      \", diag.grid)","category":"section"},{"location":"diagnostics/#Example:-Complete-Diagnostics-Loop","page":"Diagnostics","title":"Example: Complete Diagnostics Loop","text":"using BioFlows\nusing Statistics\n\n# Setup simulation\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\n# Storage\nforce_history = NamedTuple[]\nmax_cfl = 0.0\n\n# Main loop\nfor step in 1:5000\n    sim_step!(sim; remeasure=false)\n    record_force!(force_history, sim)\n\n    # Track CFL\n    diag = compute_diagnostics(sim)\n    max_cfl = max(max_cfl, diag.CFL)\n\n    # Print every 500 steps\n    if step % 500 == 0\n        stats = summarize_force_history(force_history; discard=0.3)\n        println(\"Step $step: t=$(round(sim_time(sim), digits=2)), \",\n                \"Cd=$(round(stats.drag_mean, digits=3)), \",\n                \"CFL=$(round(diag.CFL, digits=3))\")\n    end\nend\n\n# Final statistics\nfinal_stats = summarize_force_history(force_history; discard=0.3)\nprintln(\"\\nFinal Results:\")\nprintln(\"  Mean Cd = \", round(final_stats.drag_mean, digits=4))\nprintln(\"  Std Cd  = \", round(final_stats.drag_std, digits=4))\nprintln(\"  Mean Cl = \", round(final_stats.lift_mean, digits=4))\nprintln(\"  Max CFL = \", round(max_cfl, digits=3))","category":"section"},{"location":"diagnostics/#Visualization","page":"Diagnostics","title":"Visualization","text":"BioFlows integrates with Plots.jl via extensions:\n\nusing Plots\nusing BioFlows\n\n# Get vorticity field\nω = vorticity_component(sim, 3)\n\n# Plot with flood\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity field\")\n\nFor VTK output (ParaView compatible):\n\nusing WriteVTK\nusing BioFlows\n\n# VTK writer becomes available\nvtkWriter(sim, \"output_dir\")","category":"section"},{"location":"diagnostics/#BioFlows.force_components","page":"Diagnostics","title":"BioFlows.force_components","text":"force_components(sim; ρ=1.0, reference_area=sim.L, with_coefficients=true)\n\nCollect pressure, viscous, and total force vectors for sim. When with_coefficients=true, dimensionless coefficients are returned using the reference area ½ρU²A.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.force_coefficients","page":"Diagnostics","title":"BioFlows.force_coefficients","text":"force_coefficients(sim; ρ=1.0, reference_area=sim.L)\n\nConvenience wrapper returning only the total force coefficients.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.record_force!","page":"Diagnostics","title":"BioFlows.record_force!","text":"record_force!(history, sim; ρ=1.0, reference_area=sim.L)\n\nAppend a force sample to history, which should be a Vector of NamedTuples. Stores time, raw forces, and coefficients.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_component","page":"Diagnostics","title":"BioFlows.vorticity_component","text":"vorticity_component(sim, component; strip_ghosts=true)\n\nReturn the requested vorticity component evaluated at cell centres. For 2D simulations use component=3 to obtain the out-of-plane vorticity.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_magnitude","page":"Diagnostics","title":"BioFlows.vorticity_magnitude","text":"vorticity_magnitude(sim; strip_ghosts=true)\n\nCompute the vorticity magnitude field for the current simulation state.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_velocity","page":"Diagnostics","title":"BioFlows.cell_center_velocity","text":"cell_center_velocity(sim; strip_ghosts=true)\n\nReturn the velocity field averaged to cell centres for each component. The last dimension indexes the velocity components.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_vorticity","page":"Diagnostics","title":"BioFlows.cell_center_vorticity","text":"cell_center_vorticity(sim; strip_ghosts=true)\n\nReturn the vorticity at cell centres. For 2D simulations this returns a scalar field (the ω₃ component); for 3D it returns the full vector with the last dimension indexing components.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_pressure","page":"Diagnostics","title":"BioFlows.cell_center_pressure","text":"cell_center_pressure(sim; strip_ghosts=true)\n\nReturn the pressure field at cell centres. Pressure is already cell-centred in the staggered grid, so this simply returns the field with optional ghost cell stripping.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"BioFlows includes several example scripts in the examples/ directory.","category":"section"},{"location":"examples/#Flow-Past-Cylinder-(2D)","page":"Examples","title":"Flow Past Cylinder (2D)","text":"File: examples/flow_past_cylinder_2d.jl\n\nThe most comprehensive example with configurable parameters:\n\nusing BioFlows\n\ninclude(\"examples/flow_past_cylinder_2d.jl\")\n\n# Run with custom parameters\nsim, history, stats, writer, diagnostics = run_flow_past_cylinder(\n    nx = 256,           # Grid points in x\n    nz = 64,            # Grid points in z\n    Lx = 8.0,           # Domain length\n    Lz = 2.0,           # Domain height\n    Re = 150,           # Reynolds number\n    final_time = 10.0,  # Convective time units\n    save_center_fields = true,\n    center_filename = \"output.jld2\",\n    diagnostic_interval = 100\n)\n\nprintln(\"Mean Cd: \", stats.drag_mean)\nprintln(\"Lift RMS: \", stats.lift_rms)","category":"section"},{"location":"examples/#Command-Line","page":"Examples","title":"Command Line","text":"julia --project examples/flow_past_cylinder_2d.jl","category":"section"},{"location":"examples/#Output","page":"Examples","title":"Output","text":"Force history with Cd/Cl coefficients\nCell-centered velocity/vorticity snapshots (JLD2)\nDiagnostic statistics","category":"section"},{"location":"examples/#Circle-Benchmark","page":"Examples","title":"Circle Benchmark","text":"File: examples/circle_benchmark.jl\n\nSimple 2D cylinder for benchmarking:\n\nusing BioFlows\n\nradius = 8\ncenter = 4 * radius - 1\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\nsim = Simulation((6radius, 8radius), (1, 0), 2radius;\n                 ν = 2radius / 120,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-2","page":"Examples","title":"Command Line","text":"julia --project examples/circle_benchmark.jl","category":"section"},{"location":"examples/#Oscillating-Cylinder","page":"Examples","title":"Oscillating Cylinder","text":"File: examples/oscillating_cylinder.jl\n\nCylinder with sinusoidal cross-flow motion:\n\nusing BioFlows\n\nradius = 8\nA = radius / 2    # Oscillation amplitude\nSt = 0.2          # Strouhal number\nω = 2π * St       # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]\n\nbody = AutoBody(sdf, map)\n\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = body)\n\n# Must remeasure for moving bodies\nsim_step!(sim, 5.0; remeasure=true)","category":"section"},{"location":"examples/#Command-Line-3","page":"Examples","title":"Command Line","text":"julia --project examples/oscillating_cylinder.jl","category":"section"},{"location":"examples/#3D-Torus","page":"Examples","title":"3D Torus","text":"File: examples/torus_3d.jl\n\n3D torus in periodic inflow:\n\nusing BioFlows\n\nR = 16  # Major radius\nr = 4   # Minor radius\n\nfunction sdf_torus(x, t)\n    # Distance from torus centerline\n    d_ring = sqrt(x[1]^2 + x[2]^2) - R\n    sqrt(d_ring^2 + x[3]^2) - r\nend\n\nsim = Simulation((64, 64, 64), (1, 0, 0), 2r;\n                 ν = 2r / 50,\n                 body = AutoBody(sdf_torus),\n                 perdir = (1, 2))  # Periodic in x and y\n\nsim_step!(sim, 2.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-4","page":"Examples","title":"Command Line","text":"julia --project examples/torus_3d.jl","category":"section"},{"location":"examples/#3D-Sphere","page":"Examples","title":"3D Sphere","text":"File: examples/sphere_3d.jl\n\n3D sphere wake simulation:\n\nusing BioFlows\n\nradius = 8\ncenter = [32, 32, 32]\n\nsdf(x, t) = sqrt(sum((x .- center).^2)) - radius\n\nsim = Simulation((128, 64, 64), (1, 0, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-5","page":"Examples","title":"Command Line","text":"julia --project examples/sphere_3d.jl","category":"section"},{"location":"examples/#Visualization-Examples","page":"Examples","title":"Visualization Examples","text":"","category":"section"},{"location":"examples/#Plot-Vorticity","page":"Examples","title":"Plot Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup simulation\nradius = 8\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - radius\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\n# Run simulation\nsim_step!(sim, 5.0; remeasure=false)\n\n# Get vorticity\nω = vorticity_component(sim, 3)\n\n# Create plot\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        aspect_ratio=:equal,\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity ω_z\")\nsavefig(\"vorticity.png\")","category":"section"},{"location":"examples/#Animate-Vorticity","page":"Examples","title":"Animate Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - 8\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\nanim = @animate for step in 1:500\n    sim_step!(sim)\n\n    if step % 10 == 0\n        ω = vorticity_component(sim, 3)\n        heatmap(ω', c=:RdBu, clim=(-2, 2),\n                title=\"t = $(round(sim_time(sim), digits=2))\")\n    end\nend\n\ngif(anim, \"vorticity.gif\", fps=15)","category":"section"},{"location":"examples/#Loading-Saved-Data","page":"Examples","title":"Loading Saved Data","text":"Read JLD2 snapshots from CenterFieldWriter:\n\nusing JLD2\n\n# Load snapshot\njldopen(\"center_fields.jld2\", \"r\") do file\n    # List snapshots\n    for key in keys(file)\n        println(key)\n    end\n\n    # Read specific snapshot\n    t = file[\"snapshot_10/time\"]\n    vel = file[\"snapshot_10/velocity\"]\n    vort = file[\"snapshot_10/vorticity\"]\nend","category":"section"},{"location":"examples/#GPU-Execution","page":"Examples","title":"GPU Execution","text":"Run on NVIDIA GPU:\n\nusing CUDA\nusing BioFlows\n\nsim = Simulation((256, 128), (1, 0), 16.0;\n                 ν = 16.0 / 200,\n                 body = AutoBody(sdf),\n                 mem = CuArray)  # Use GPU arrays\n\nsim_step!(sim, 10.0)","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")","category":"section"},{"location":"getting_started/#Local-Development","page":"Getting Started","title":"Local Development","text":"Clone the repository and activate:\n\ngit clone https://github.com/subhk/BioFlows.jl.git\ncd BioFlows.jl\njulia --project\n\nThen instantiate dependencies:\n\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"getting_started/#Your-First-Simulation","page":"Getting Started","title":"Your First Simulation","text":"Here's a complete example of simulating flow past a 2D cylinder:\n\nusing BioFlows\n\n# Physical parameters\nRe = 100        # Reynolds number\nU = 1.0         # Inlet velocity\nD = 16.0        # Cylinder diameter (length scale)\n\n# Grid parameters\nnx, nz = 128, 64\n\n# Define cylinder geometry\ncenter_x = nx / 4\ncenter_z = nz / 2\nradius = D / 2\n\n# Signed distance function (negative inside body)\nsdf(x, t) = sqrt((x[1] - center_x)^2 + (x[2] - center_z)^2) - radius\n\n# Create simulation\nsim = Simulation((nx, nz), (U, 0), D;\n                 ν = U * D / Re,\n                 body = AutoBody(sdf))\n\n# Time integration\nfinal_time = 10.0  # Convective time units\n\nwhile sim_time(sim) < final_time\n    sim_step!(sim; remeasure=false)\n\n    # Print progress every 100 steps\n    if length(sim.flow.Δt) % 100 == 0\n        println(\"t = \", round(sim_time(sim), digits=2))\n    end\nend\n\nprintln(\"Simulation complete!\")","category":"section"},{"location":"getting_started/#Key-Concepts","page":"Getting Started","title":"Key Concepts","text":"","category":"section"},{"location":"getting_started/#Dimensionless-Time","page":"Getting Started","title":"Dimensionless Time","text":"BioFlows uses dimensionless (convective) time:\n\nt^* = fract cdot UL\n\nwhere U is the velocity scale and L is the length scale.\n\nsim_time(sim) returns the current dimensionless time t*\ntime(sim.flow) returns the raw simulation time t","category":"section"},{"location":"getting_started/#Signed-Distance-Functions","page":"Getting Started","title":"Signed Distance Functions","text":"Geometry is defined implicitly via signed distance functions (SDF):\n\nsdf(x, t) < 0: Inside the body\nsdf(x, t) = 0: On the body surface\nsdf(x, t) > 0: Outside the body\n\nExample SDFs:\n\n# Circle/Cylinder\nsdf_circle(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\n\n# Rectangle\nsdf_rect(x, t) = max(abs(x[1]) - width/2, abs(x[2]) - height/2)\n\n# Sphere (3D)\nsdf_sphere(x, t) = sqrt(x[1]^2 + x[2]^2 + x[3]^2) - radius","category":"section"},{"location":"getting_started/#Boundary-Conditions","page":"Getting Started","title":"Boundary Conditions","text":"Specify boundary conditions via uBC:\n\n# Constant inlet velocity\nsim = Simulation(dims, (1.0, 0.0), L; ...)\n\n# Time-varying boundary (function signature: uBC(i, x, t))\nuBC(i, x, t) = i == 1 ? 1.0 + 0.1*sin(t) : 0.0\nsim = Simulation(dims, uBC, L; U=1.0, ...)  # Must specify U for functions\n\nAdditional boundary options:\n\nperdir=(2,): Make direction 2 (z) periodic\nexitBC=true: Convective exit in x-direction","category":"section"},{"location":"getting_started/#Running-Examples","page":"Getting Started","title":"Running Examples","text":"The examples/ directory contains ready-to-run scripts:\n\njulia --project examples/flow_past_cylinder_2d.jl\njulia --project examples/circle_benchmark.jl\njulia --project examples/oscillating_cylinder.jl\n\nSee Examples for detailed descriptions.","category":"section"},{"location":"core_types/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"core_types/#Simulation","page":"Core Types","title":"Simulation","text":"The main container for a BioFlows simulation.","category":"section"},{"location":"core_types/#Constructor","page":"Core Types","title":"Constructor","text":"Simulation(dims::NTuple, uBC, L::Number;\n           U=norm(uBC), Δt=0.25, ν=0., ϵ=1, g=nothing,\n           perdir=(), exitBC=false,\n           body::AbstractBody=NoBody(),\n           T=Float32, mem=Array)\n\nArguments:\n\nParameter Type Description\ndims NTuple{N,Int} Grid dimensions (nx, nz) or (nx, ny, nz)\nuBC Tuple or Function Boundary velocity\nL Number Length scale for non-dimensionalization\nU Number Velocity scale (auto-computed if uBC is constant)\nΔt Number Initial time step (default: 0.25)\nν Number Kinematic viscosity (Re = U*L/ν)\nϵ Number BDIM kernel width (default: 1)\ng Function or Nothing Acceleration field g(i,x,t)\nperdir Tuple Periodic directions, e.g. (2,)\nexitBC Bool Convective exit in x-direction\nbody AbstractBody Immersed geometry\nT Type Float type (Float32 or Float64)\nmem Type Array backend (Array for CPU)","category":"section"},{"location":"core_types/#Fields","page":"Core Types","title":"Fields","text":"Field Description\nU Velocity scale\nL Length scale\nϵ BDIM kernel width\nflow Flow struct with velocity/pressure fields\nbody Immersed body geometry\npois Pressure Poisson solver","category":"section"},{"location":"core_types/#Flow","page":"Core Types","title":"Flow","text":"The Flow struct holds all fluid fields for the simulation.","category":"section"},{"location":"core_types/#Fields-2","page":"Core Types","title":"Fields","text":"Field Type Description\nu Array{T,D+1} Velocity vector field\nu⁰ Array{T,D+1} Previous velocity (for time stepping)\nf Array{T,D+1} Force vector field\np Array{T,D} Pressure scalar field\nσ Array{T,D} Divergence scalar field\nV Array{T,D+1} Body velocity vector (BDIM)\nμ₀ Array{T,D+1} Zeroth moment (BDIM)\nμ₁ Array{T,D+2} First moment tensor (BDIM)\nΔt Vector{T} Time step history\nν T Kinematic viscosity","category":"section"},{"location":"core_types/#AutoBody","page":"Core Types","title":"AutoBody","text":"Define geometry implicitly via signed distance functions.","category":"section"},{"location":"core_types/#Constructor-2","page":"Core Types","title":"Constructor","text":"AutoBody(sdf, map=(x,t)->x; compose=true)\n\nArguments:\n\nParameter Description\nsdf Signed distance function sdf(x, t)\nmap Coordinate mapping function map(x, t) for moving bodies\ncompose Auto-compose sdf∘map when true (default)","category":"section"},{"location":"core_types/#Example:-Static-Cylinder","page":"Core Types","title":"Example: Static Cylinder","text":"radius = 8\ncenter = [32, 32]\nsdf(x, t) = sqrt((x[1] - center[1])^2 + (x[2] - center[2])^2) - radius\nbody = AutoBody(sdf)","category":"section"},{"location":"core_types/#Example:-Oscillating-Cylinder","page":"Core Types","title":"Example: Oscillating Cylinder","text":"radius = 8\nA = 5.0  # Amplitude\nω = 0.5  # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]  # Vertical oscillation\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Example:-Rotating-Ellipse","page":"Core Types","title":"Example: Rotating Ellipse","text":"a, b = 10, 5  # Semi-axes\nω = 0.2       # Angular velocity\n\nsdf(x, t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\n\nfunction map(x, t)\n    θ = ω * t\n    c, s = cos(θ), sin(θ)\n    [c*x[1] + s*x[2], -s*x[1] + c*x[2]]\nend\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Simulation-Control-Functions","page":"Core Types","title":"Simulation Control Functions","text":"","category":"section"},{"location":"core_types/#Time-Stepping","page":"Core Types","title":"Time Stepping","text":"","category":"section"},{"location":"core_types/#Usage","page":"Core Types","title":"Usage","text":"# Single time step\nsim_step!(sim; remeasure=true)\n\n# Integrate to target time\nsim_step!(sim, 10.0; remeasure=false, verbose=true)\n\n# Query time\nt_star = sim_time(sim)  # Dimensionless time t*U/L\nt_raw = time(sim.flow)  # Raw simulation time\n\n# Update body for moving geometry\nmeasure!(sim)\n\n# Add perturbations for flow instability\nperturb!(sim; noise=0.1)\n\n# Print status\nsim_info(sim)  # Prints: tU/L=..., Δt=...","category":"section"},{"location":"core_types/#BioFlows.Simulation","page":"Core Types","title":"BioFlows.Simulation","text":"Simulation(dims::NTuple{N}, uBC, L::NTuple{N}; L_char=nothing, kwargs...)\n\nConstructor for a BioFlows simulation solving the dimensional incompressible Navier-Stokes equations:\n\n∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g\n∇·u = 0\n\nArguments\n\nRequired\n\ndims::NTuple{N,Int}: Number of grid cells in each direction, e.g., (nx, nz) or (nx, ny, nz)\nuBC: Boundary velocity. Either a Tuple for constant BCs, or Function(i,x,t) for space/time varying\nL::NTuple{N}: Physical domain size in each direction (e.g., (Lx, Lz) in meters)\nGrid spacing is computed as Δx = L[1]/dims[1] (must be uniform)\n\nOptional (keyword arguments)\n\nL_char: Characteristic length scale for dimensionless time and force coefficients\nDefaults to L[1] if not specified\nFor cylinder flows, typically use the diameter (2*radius)\nU: Velocity scale for dimensionless time reporting. Required if uBC is a Function\nΔt=0.25: Initial time step (seconds)\nν=0.: Kinematic viscosity (m²/s)\ng=nothing: Body acceleration function g(i,x,t) (m/s²)\nϵ=1: BDIM kernel width (in grid cells)\nperdir=(): Periodic directions, e.g., (2,) for y-periodic\nuλ=nothing: Initial velocity condition. Tuple or Function(i,x)\nexitBC=false: Enable convective exit BC in direction 1\nbody=NoBody(): Immersed body geometry\nT=Float32: Numeric type\nmem=Array: Memory backend (Array, CuArray, etc.)\n\nExample\n\n# 2D channel: 2m × 1m domain with 256 × 128 cells\n# Δx = 2.0/256 = 0.0078125 m\n# Inlet velocity 1 m/s, water viscosity\nsim = Simulation((256, 128), (1.0, 0.0), (2.0, 1.0); ν=1e-6)\n\n# With immersed cylinder of diameter 0.2m\ndiameter = 0.2\ncylinder = AutoBody((x,t) -> √(x[1]^2 + x[2]^2) - diameter/2)\nsim = Simulation((256, 128), (1.0, 0.0), (2.0, 1.0); ν=1e-6, body=cylinder, L_char=diameter)\n\nSee files in examples folder for more examples.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.Flow","page":"Core Types","title":"BioFlows.Flow","text":"Flow{D::Int, T::Float, Sf<:AbstractArray{T,D}, Vf<:AbstractArray{T,D+1}, Tf<:AbstractArray{T,D+2}}\n\nComposite type for a multidimensional immersed boundary flow simulation.\n\nFlow solves the unsteady incompressible Navier-Stokes equations on a Cartesian grid. Solid boundaries are modelled using the Boundary Data Immersion Method. The primary variables are the scalar pressure p (an array of dimension D) and the velocity vector field u (an array of dimension D+1).\n\nThe equations solved are the dimensional incompressible Navier-Stokes:     ∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g     ∇·u = 0\n\nwhere Δx is the uniform grid spacing (m), ν is kinematic viscosity (m²/s), and all spatial derivatives are properly scaled by Δx.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.AutoBody","page":"Core Types","title":"BioFlows.AutoBody","text":"AutoBody(sdf,map=(x,t)->x; compose=true) <: AbstractBody\n\nsdf(x::AbstractVector,t::Real)::Real: signed distance function\nmap(x::AbstractVector,t::Real)::AbstractVector: coordinate mapping function\ncompose::Bool=true: Flag for composing sdf=sdf∘map\n\nImplicitly define a geometry by its sdf and optional coordinate map. Note: the map is composed automatically if compose=true, i.e. sdf(x,t) = sdf(map(x,t),t). Both parameters remain independent otherwise. It can be particularly heplful to set compose=false when adding mulitple bodies together to create a more complex one.\n\nExamples\n\n# Static cylinder\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nbody = AutoBody(sdf)\n\n# Oscillating cylinder (vertical motion)\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x,t) = x .- [0, A*sin(ω*t)]  # Shift coordinate frame\nbody = AutoBody(sdf, map)\n\n# Rotating ellipse\nsdf(x,t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\nmap(x,t) = [cos(ω*t) sin(ω*t); -sin(ω*t) cos(ω*t)] * x\nbody = AutoBody(sdf, map)\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.sim_step!","page":"Core Types","title":"BioFlows.sim_step!","text":"sim_step!(sim::AbstractSimulation,t_end;remeasure=true,λ=quick,max_steps=typemax(Int),verbose=false,\n    udf=nothing,kwargs...)\n\nIntegrate the simulation sim up to dimensionless time t_end. If remeasure=true, the body is remeasured at every time step. Can be set to false for static geometries to speed up simulation. A user-defined function udf can be passed to arbitrarily modify the ::Flow during the predictor and corrector steps. If the udf user keyword arguments, these needs to be included in the sim_step! call as well. A λ::Function function can be passed as a custom convective scheme, following the interface of λ(u,c,d) (for upstream, central, downstream points).\n\n\n\n\n\nsim_step!(sim::AMRSimulation; remeasure=true, λ=quick, kwargs...)\n\nAdvance AMR simulation by one time step with automatic regridding. Uses CompositePoisson for pressure solve when AMR has refined patches.\n\n\n\n\n\nsim_step!(sim::AMRSimulation, t_end; kwargs...)\n\nAdvance AMR simulation up to dimensionless time t_end.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_time","page":"Core Types","title":"BioFlows.sim_time","text":"sim_time(sim::Simulation)\n\nReturn the current dimensionless time of the simulation tU/L where t=sum(Δt), and U,L are the simulation velocity and length scales.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.measure!","page":"Core Types","title":"BioFlows.measure!","text":"measure!(flow::Flow, body::AbstractBody; t=0, ϵ=1)\n\nQueries the body geometry to fill the arrays:\n\nflow.μ₀, Zeroth kernel moment\nflow.μ₁, First kernel moment scaled by the body normal\nflow.V,  Body velocity\n\nat time t using an immersion kernel of size ϵ.\n\nSee Maertens & Weymouth, doi:10.1016/j.cma.2014.09.007.\n\n\n\n\n\nmeasure!(sim::Simulation,t=timeNext(sim))\n\nMeasure a dynamic body to update the flow and pois coefficients.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.perturb!","page":"Core Types","title":"BioFlows.perturb!","text":"perturb!(sim; noise=0.1)\n\nPerturb the velocity field of a simulation with noise level with respect to velocity scale U.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_info","page":"Core Types","title":"BioFlows.sim_info","text":"sim_info(sim::AbstractSimulation)\n\nPrints information on the current state of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"#BioFlows.jl","page":"Home","title":"BioFlows.jl","text":"A Julia package for computational fluid dynamics with immersed boundary methods\n\nBioFlows.jl provides a complete solver for incompressible viscous flow on Cartesian grids using the Boundary Data Immersion Method (BDIM).","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Pure Julia solver for incompressible Navier-Stokes equations\nImmersed boundary method via BDIM (Boundary Data Immersion Method)\nImplicit geometry definition through signed distance functions\nAdaptive Mesh Refinement (AMR) near bodies and flow features\nCPU and GPU execution via KernelAbstractions.jl\nMPI support for distributed computing\nBuilt-in diagnostics: forces, vorticity, cell-centered fields\nJLD2 and VTK output (via extensions)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")\n\nOr activate the project locally:\n\njulia --project\njulia> ]instantiate","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using BioFlows\n\n# Define cylinder geometry via signed distance function\nradius = 8\ncenter = 32\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Create simulation: domain (nx, nz), boundary velocity, length scale\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,    # Re = 100\n                 body = AutoBody(sdf))\n\n# Advance to t*U/L = 1.0 (convective time units)\nsim_step!(sim, 1.0; remeasure=false)\n\n# Check simulation state\nprintln(\"Time: \", sim_time(sim))","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"numerical_methods.md\",\n    \"core_types.md\",\n    \"amr.md\",\n    \"diagnostics.md\",\n    \"examples.md\",\n    \"api.md\",\n]\nDepth = 2","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"Subhajit Kar\nDibyendu Ghosh","category":"section"},{"location":"numerical_methods/#Numerical-Methods","page":"Numerical Methods","title":"Numerical Methods","text":"This section describes the numerical methods used in BioFlows.jl for solving the incompressible Navier-Stokes equations.","category":"section"},{"location":"numerical_methods/#Governing-Equations","page":"Numerical Methods","title":"Governing Equations","text":"BioFlows.jl solves the incompressible Navier-Stokes equations in dimensional form:\n\nfracpartial mathbfupartial t + (mathbfu cdot nabla)mathbfu = -frac1rhonabla p + nu nabla^2 mathbfu\n\nnabla cdot mathbfu = 0\n\nwhere:\n\nmathbfu = (u v)\nis the velocity field (m/s)\np\nis the pressure (Pa)\nrho\nis the density (kg/m³)\nnu\nis the kinematic viscosity (m²/s)","category":"section"},{"location":"numerical_methods/#Staggered-Grid-(MAC-Grid)","page":"Numerical Methods","title":"Staggered Grid (MAC Grid)","text":"BioFlows.jl uses a staggered grid arrangement, also known as a Marker-And-Cell (MAC) grid. This arrangement naturally satisfies the discrete divergence-free condition and avoids spurious pressure oscillations (checkerboard modes).","category":"section"},{"location":"numerical_methods/#Variable-Locations-in-2D","page":"Numerical Methods","title":"Variable Locations in 2D","text":"On a staggered grid, different variables are stored at different locations within each cell:\n\nPressure (p): Cell centers\nx-velocity (u): Vertical cell faces (between left/right neighbors)\ny-velocity (v): Horizontal cell faces (between bottom/top neighbors)\n\n         Δx\n    ├─────────────┤\n\n    ┌─────────────┬─────────────┬─────────────┐  ─┬─\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │   │\n    │    p_i,j+1  │   p_i+1,j+1 │  p_i+2,j+1  │   │\n    │             │             │             │   Δy\n    u             u             u             u   │\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │  ─┴─\n    │    p_i,j    │   p_i+1,j   │  p_i+2,j    │\n    │             │             │             │\n    u             u             u             u\n    │             │             │             │\n    │      ●      v      ●      v      ●      │\n    │   p_i,j-1   │  p_i+1,j-1  │  p_i+2,j-1  │\n    │             │             │             │\n    └─────────────┴─────────────┴─────────────┘\n\n    Legend:\n    ●  = Pressure (p) at cell center\n    u  = x-velocity component at vertical faces\n    v  = y-velocity component at horizontal faces","category":"section"},{"location":"numerical_methods/#Detailed-Single-Cell-View","page":"Numerical Methods","title":"Detailed Single Cell View","text":"For a single cell (ij), the staggered arrangement is:\n\n                    v[i,j+1]\n                       ↑\n              ┌────────┼────────┐\n              │        │        │\n              │        │        │\n    u[i,j] ───┼───── p[i,j] ────┼─── u[i+1,j]\n      →       │        ●        │       →\n              │                 │\n              │                 │\n              └────────┼────────┘\n                       │\n                       ↓\n                    v[i,j]\n\n    Grid spacing: Δx (horizontal), Δy (vertical)\n    Cell center:  (i-½, j-½) in grid coordinates\n    u location:   (i, j-½) - on left/right faces\n    v location:   (i-½, j) - on bottom/top faces","category":"section"},{"location":"numerical_methods/#Indexing-Convention","page":"Numerical Methods","title":"Indexing Convention","text":"In BioFlows.jl, the arrays are indexed as follows:\n\nVariable Array Index Physical Location\np[i,j] Cell (ij) Center of cell (ij)\nu[i,j,1] Face (ij) Left face of cell (ij)\nu[i,j,2] Face (ij) Bottom face of cell (ij)\n\nThe velocity field is stored in a single array u[I,d] where I is the cell index and d is the direction (1=x, 2=y for 2D; 1=x, 2=y, 3=z for 3D).","category":"section"},{"location":"numerical_methods/#Extension-to-3D","page":"Numerical Methods","title":"Extension to 3D","text":"In three dimensions, the staggered grid extends naturally:\n\nPressure (p): Cell centers\nx-velocity (u): yz-faces (perpendicular to x)\ny-velocity (v): xz-faces (perpendicular to y)\nz-velocity (w): xy-faces (perpendicular to z)\n\n                        z\n                        │   y\n                        │  /\n                        │ /\n                        │/\n            ────────────┼──────────── x\n\n\n                    ┌───────────────────┐\n                   /│                  /│\n                  / │       w_top     / │\n                 /  │       ↑        /  │\n                ┌───────────────────┐   │\n                │   │      ●        │   │\n          u_L → │   │    p_ijk      │ → u_R\n                │   │               │   │\n                │   └ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ┘\n                │  /                │  /\n                │ /      ↓         │ /\n                │/    w_bottom     │/\n                └───────────────────┘\n                      ↗       ↘\n                   v_front   v_back\n\n\n    Legend:\n    ●     = Pressure at cell center (i,j,k)\n    u_L   = u[i,j,k,1] at left face\n    u_R   = u[i+1,j,k,1] at right face\n    v     = v[i,j,k,2] at front/back faces\n    w     = w[i,j,k,3] at top/bottom faces","category":"section"},{"location":"numerical_methods/#Finite-Difference-Operators","page":"Numerical Methods","title":"Finite Difference Operators","text":"","category":"section"},{"location":"numerical_methods/#Divergence","page":"Numerical Methods","title":"Divergence","text":"The discrete divergence operator at cell center (ij):\n\n(nabla cdot mathbfu)_ij = fracu_i+1j - u_ijDelta x + fracv_ij+1 - v_ijDelta y","category":"section"},{"location":"numerical_methods/#Gradient","page":"Numerical Methods","title":"Gradient","text":"The discrete pressure gradient at face locations:\n\nleft(fracpartial ppartial xright)_ij = fracp_ij - p_i-1jDelta x quad text(at u-location)\n\nleft(fracpartial ppartial yright)_ij = fracp_ij - p_ij-1Delta y quad text(at v-location)","category":"section"},{"location":"numerical_methods/#Laplacian","page":"Numerical Methods","title":"Laplacian","text":"The discrete Laplacian for the Poisson equation:\n\nnabla^2 p_ij = fracp_i+1j - 2p_ij + p_i-1jDelta x^2 + fracp_ij+1 - 2p_ij + p_ij-1Delta y^2","category":"section"},{"location":"numerical_methods/#Time-Integration","page":"Numerical Methods","title":"Time Integration","text":"BioFlows.jl uses a 2nd-order predictor-corrector (Heun's method) combined with pressure projection to ensure incompressibility. This provides 2nd-order temporal accuracy.","category":"section"},{"location":"numerical_methods/#Predictor-Step","page":"Numerical Methods","title":"Predictor Step","text":"First, compute a forward Euler prediction:\n\nmathbfu^* = mathbfu^n + Delta t left -(mathbfu^n cdot nabla)mathbfu^n + nu nabla^2 mathbfu^n + mathbfg right\n\nThen project onto divergence-free space:\n\nnabla^2 phi = nabla cdot mathbfu^*\n\nmathbfu = mathbfu^* - nabla phi","category":"section"},{"location":"numerical_methods/#Corrector-Step","page":"Numerical Methods","title":"Corrector Step","text":"Re-evaluate the right-hand side at the predicted velocity:\n\nmathbff = -(mathbfu cdot nabla)mathbfu + nu nabla^2 mathbfu + mathbfg\n\nAverage the predictor and corrector contributions (Heun's method):\n\nmathbfu^** = frac12left( mathbfu + mathbfu^n + Delta t  mathbff right)\n\nThis is equivalent to the trapezoidal rule:\n\nmathbfu^** = mathbfu^n + fracDelta t2 left( mathbff^n + mathbff right)\n\nFinally, project onto divergence-free space:\n\nnabla^2 psi = frac2Delta t nabla cdot mathbfu^**\n\nmathbfu^n+1 = mathbfu^** - fracDelta t2 nabla psi","category":"section"},{"location":"numerical_methods/#Summary-of-the-Algorithm","page":"Numerical Methods","title":"Summary of the Algorithm","text":"Algorithm: 2nd-order Predictor-Corrector with Pressure Projection\n─────────────────────────────────────────────────────────────────\nInput: uⁿ (divergence-free velocity at time tⁿ)\nOutput: uⁿ⁺¹ (divergence-free velocity at time tⁿ⁺¹)\n\n1. Save: u⁰ ← uⁿ\n\n2. PREDICTOR:\n   a. f ← RHS(u⁰)                    // Convection + diffusion\n   b. u* ← u⁰ + Δt·f                 // Forward Euler\n   c. Solve ∇²φ = ∇·u*               // Pressure Poisson\n   d. u' ← u* - ∇φ                   // Project to div-free\n\n3. CORRECTOR:\n   a. f' ← RHS(u')                   // Re-evaluate at predicted\n   b. u** ← u' + u⁰ + Δt·f'          // Accumulate\n   c. u** ← 0.5·u**                  // Average (Heun)\n   d. Solve ∇²ψ = (2/Δt)·∇·u**       // Pressure Poisson\n   e. uⁿ⁺¹ ← u** - (Δt/2)·∇ψ        // Final projection\n\n4. Compute Δt from CFL condition","category":"section"},{"location":"numerical_methods/#CFL-Condition","page":"Numerical Methods","title":"CFL Condition","text":"The time step is constrained by the CFL (Courant-Friedrichs-Lewy) condition:\n\nDelta t leq left( sum_d fracu_dDelta x_d + sum_d frac2nuDelta x_d^2 right)^-1\n\nwhere the first term is the convective constraint and the second is the diffusive constraint.","category":"section"},{"location":"numerical_methods/#Pressure-Solver","page":"Numerical Methods","title":"Pressure Solver","text":"The pressure Poisson equation is solved using a geometric multigrid method with:\n\nJacobi smoothing iterations\nFull-weighting restriction\nBilinear interpolation for prolongation\nV-cycle iteration until convergence\n\nThe multigrid solver operates on a hierarchy of progressively coarser grids, enabling efficient solution of the elliptic pressure equation.","category":"section"},{"location":"numerical_methods/#Immersed-Boundary-Method","page":"Numerical Methods","title":"Immersed Boundary Method","text":"BioFlows.jl implements the Boundary Data Immersion Method (BDIM) for handling complex geometries. Bodies are defined implicitly through signed distance functions (SDFs):\n\nphi(mathbfx t)  0 quad textinside body\n\nphi(mathbfx t) = 0 quad texton boundary\n\nphi(mathbfx t)  0 quad textin fluid\n\nThe SDF is used to:\n\nIdentify solid and fluid regions\nInterpolate boundary conditions\nCompute surface normals: mathbfn = nablaphi  nablaphi\nCalculate hydrodynamic forces on immersed bodies","category":"section"},{"location":"numerical_methods/#References","page":"Numerical Methods","title":"References","text":"Harlow, F.H. and Welch, J.E. (1965). \"Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface.\" Physics of Fluids, 8(12), 2182-2189.\nWeymouth, G.D. and Yue, D.K.P. (2011). \"Boundary data immersion method for Cartesian-grid simulations of fluid-body interaction problems.\" Journal of Computational Physics, 230(16), 6233-6247.","category":"section"}]
}
