var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides a quick reference to all exported functions and types. See the linked pages for detailed documentation.","category":"section"},{"location":"api/#Simulation-Types","page":"API Reference","title":"Simulation Types","text":"See Core Types for details.\n\nType Description\nSimulation Main simulation container\nAMRSimulation Simulation with adaptive mesh refinement\nAMRConfig Configuration for AMR\nFlow Fluid field storage (velocity, pressure)\nAutoBody Implicit geometry via signed distance function","category":"section"},{"location":"api/#Simulation-Control","page":"API Reference","title":"Simulation Control","text":"See Core Types for details.\n\nFunction Description\nsim_step!(sim) Advance one time step\nsim_step!(sim, t_end) Advance to target time\nsim_time(sim) Get dimensionless time (t*U/L)\nmeasure!(sim) Update body coefficients\nperturb!(sim) Add velocity perturbations\nsim_info(sim) Print simulation status","category":"section"},{"location":"api/#Finite-Volume-Method-(FVM)","page":"API Reference","title":"Finite Volume Method (FVM)","text":"See Numerical Methods for details.\n\nFunction Description\ncompute_face_flux!(F_conv, F_diff, u, λ; ν, Δx, perdir) Compute fluxes at cell faces\napply_fluxes!(r, F_conv, F_diff) Apply fluxes conservatively to RHS\nconv_diff_fvm!(r, u, F_conv, F_diff, λ; ν, Δx, perdir) FVM convection-diffusion\n\nEnable FVM mode by setting store_fluxes=true in Simulation or Flow constructor.","category":"section"},{"location":"api/#AMR-Functions","page":"API Reference","title":"AMR Functions","text":"See Adaptive Mesh Refinement for details.\n\nFunction Description\namr_regrid!(sim) Force regridding\nset_amr_active!(sim, bool) Enable/disable AMR\nget_refinement_indicator(sim) Get current indicator field\nnum_refined_cells(grid) Count refined cells\nrefinement_level(grid, i, j) Query cell refinement level\namr_info(sim) Print AMR status and statistics\ncheck_divergence(sim) Check velocity divergence on all levels\namr_cfl(flow, cp) Compute CFL considering refined patches\nsynchronize_base_and_patches!(flow, cp) Sync data between base and patches","category":"section"},{"location":"api/#Force-Diagnostics","page":"API Reference","title":"Force Diagnostics","text":"See Diagnostics for details.\n\nFunction Description\npressure_force(sim) Pressure force vector\nviscous_force(sim) Viscous force vector\ntotal_force(sim) Total force vector\nforce_components(sim) All forces + coefficients\nforce_coefficients(sim) Dimensionless coefficients\nrecord_force!(history, sim) Append to force history","category":"section"},{"location":"api/#Vorticity-Functions","page":"API Reference","title":"Vorticity Functions","text":"See Diagnostics for details.\n\nFunction Description\nvorticity_component(sim, i) i-th vorticity component\nvorticity_magnitude(sim) Vorticity magnitude field\ncell_center_velocity(sim) Interpolated velocity at cell centers\ncell_center_vorticity(sim) Interpolated vorticity at cell centers\ncell_center_pressure(sim) Pressure at cell centers","category":"section"},{"location":"api/#Output","page":"API Reference","title":"Output","text":"Function Description\nCenterFieldWriter(file; interval) Create JLD2 snapshot writer\nForceWriter(file; interval) Create JLD2 force coefficient writer\nfile_save!(writer, sim) Save snapshot if interval elapsed","category":"section"},{"location":"api/#Exported-Symbols","page":"API Reference","title":"Exported Symbols","text":"","category":"section"},{"location":"api/#From-BioFlows.jl","page":"API Reference","title":"From BioFlows.jl","text":"# Simulation\nSimulation, AbstractSimulation, sim_step!, sim_time, measure!, sim_info, perturb!\n\n# AMR\nAMRSimulation, AMRConfig, amr_regrid!, set_amr_active!, get_refinement_indicator\n\n# Flow\nFlow, mom_step!, quick, cds\ncompute_face_flux!, apply_fluxes!, conv_diff_fvm!\n\n# Pressure\nAbstractPoisson, Poisson, MultiLevelPoisson, solver!, mult!\n\n# Bodies\nAbstractBody, AutoBody, measure_sdf!, sdf, measure\n\n# Diagnostics\npressure_force, viscous_force, total_force, force_components, force_coefficients, record_force!\nvorticity_component, vorticity_magnitude, cell_center_velocity, cell_center_vorticity, cell_center_pressure\ncurl, ω, ω_mag\ncompute_diagnostics, summarize_force_history\n\n# Output\nCenterFieldWriter, ForceWriter, file_save!\n\n# AMR Types\nStaggeredGrid, SolutionState, RefinedGrid, GridType, TwoDimensional, ThreeDimensional\nis_2d, is_3d, num_refined_cells, refinement_level, domain_size, cell_volume\nFlowToGridAdapter, flow_to_staggered_grid, flow_to_solution_state, create_refined_grid\ncompute_body_refinement_indicator, compute_velocity_gradient_indicator\ncompute_vorticity_indicator, compute_combined_indicator\nmark_cells_for_refinement, apply_buffer_zone!\n\n# AMR Composite Solver\nCompositePoisson, PatchPoisson, RefinedVelocityField, RefinedVelocityPatch\nadd_patch!, remove_patch!, get_patch, clear_patches!, has_patches, num_patches\ncreate_patches!, update_patches!, ensure_proper_nesting!\namr_project!, amr_mom_step!, check_amr_divergence, regrid_amr!\namr_cfl, synchronize_base_and_patches!, interpolate_velocity_to_patches!\namr_info, check_divergence\n\n# Utilities\nL₂, BC!, @inside, inside, δ, apply!, loc, @log, set_backend, backend\n\n# Statistics\nMeanFlow, update!, uu!, uu","category":"section"},{"location":"amr/#Adaptive-Mesh-Refinement","page":"Adaptive Mesh Refinement","title":"Adaptive Mesh Refinement","text":"BioFlows includes an Adaptive Mesh Refinement (AMR) system that automatically refines the computational grid near immersed bodies and regions of high flow gradients.","category":"section"},{"location":"amr/#AMRSimulation","page":"Adaptive Mesh Refinement","title":"AMRSimulation","text":"The AMRSimulation type wraps a standard Simulation and adds AMR capability.","category":"section"},{"location":"amr/#Basic-Usage","page":"Adaptive Mesh Refinement","title":"Basic Usage","text":"using BioFlows\n\n# Define geometry\nradius = 8\ncenter = 64\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Configure AMR\nconfig = AMRConfig(\n    max_level = 2,                     # Max refinement (2x, 4x resolution)\n    body_distance_threshold = 3.0,     # Refine within 3 cells of body\n    velocity_gradient_threshold = 1.0,\n    vorticity_threshold = 1.0,\n    regrid_interval = 10,              # Check regridding every 10 steps\n    buffer_size = 1                    # Buffer cells around refined regions\n)\n\n# Create AMR simulation\nsim = AMRSimulation((128, 128), (128.0, 128.0);\n                    inletBC = (1.0, 0.0),\n                    ν = 2radius / 200,\n                    body = AutoBody(sdf),\n                    L_char = 2radius,\n                    amr_config = config)\n\n# Time integration (regridding happens automatically)\nfor step in 1:1000\n    sim_step!(sim; remeasure=true)\nend\n\n# Check refinement\nprintln(\"Refined cells: \", num_refined_cells(sim.refined_grid))","category":"section"},{"location":"amr/#AMRConfig-Parameters","page":"Adaptive Mesh Refinement","title":"AMRConfig Parameters","text":"Parameter Default Description\nmax_level 2 Maximum refinement level (1=2x, 2=4x, etc.)\nbody_distance_threshold 3.0 Refine within this distance from body (cells)\nvelocity_gradient_threshold 1.0 Threshold for velocity gradient indicator\nvorticity_threshold 1.0 Threshold for vorticity-based refinement\nregrid_interval 10 Steps between regridding checks\nbuffer_size 1 Buffer cells around refined regions\nbody_weight 0.5 Weight for body proximity in combined indicator\ngradient_weight 0.3 Weight for velocity gradient\nvorticity_weight 0.2 Weight for vorticity","category":"section"},{"location":"amr/#Refinement-Indicators","page":"Adaptive Mesh Refinement","title":"Refinement Indicators","text":"The AMR system uses multiple indicators to decide where to refine:","category":"section"},{"location":"amr/#Body-Distance-Indicator","page":"Adaptive Mesh Refinement","title":"Body Distance Indicator","text":"Refines cells near the immersed body surface:\n\nindicator = compute_body_refinement_indicator(flow, body;\n    threshold=config.body_distance_threshold, t=t)","category":"section"},{"location":"amr/#Velocity-Gradient-Indicator","page":"Adaptive Mesh Refinement","title":"Velocity Gradient Indicator","text":"Refines regions of high velocity gradients:\n\nindicator = compute_velocity_gradient_indicator(flow;\n    threshold=config.velocity_gradient_threshold)","category":"section"},{"location":"amr/#Vorticity-Indicator","page":"Adaptive Mesh Refinement","title":"Vorticity Indicator","text":"Refines regions of high vorticity:\n\nindicator = compute_vorticity_indicator(flow;\n    threshold=config.vorticity_threshold)","category":"section"},{"location":"amr/#Combined-Indicator","page":"Adaptive Mesh Refinement","title":"Combined Indicator","text":"Combines all indicators with configurable weights:\n\nindicator = compute_combined_indicator(flow, body;\n    body_threshold=3.0,\n    gradient_threshold=1.0,\n    vorticity_threshold=1.0,\n    t=0.0,\n    body_weight=0.5,\n    gradient_weight=0.3,\n    vorticity_weight=0.2\n)","category":"section"},{"location":"amr/#AMR-Control","page":"Adaptive Mesh Refinement","title":"AMR Control","text":"","category":"section"},{"location":"amr/#Enable/Disable-AMR","page":"Adaptive Mesh Refinement","title":"Enable/Disable AMR","text":"# Disable regridding (keep current mesh)\nset_amr_active!(sim, false)\n\n# Re-enable\nset_amr_active!(sim, true)","category":"section"},{"location":"amr/#Force-Regridding","page":"Adaptive Mesh Refinement","title":"Force Regridding","text":"amr_regrid!(sim)","category":"section"},{"location":"amr/#Query-Refinement","page":"Adaptive Mesh Refinement","title":"Query Refinement","text":"# Number of refined cells\nn = num_refined_cells(sim.refined_grid)\n\n# Refinement level at specific cell (0 = base, 1+ = refined)\nlevel = refinement_level(sim.refined_grid, i, j)\n\n# Get current indicator field (for visualization)\nindicator = get_refinement_indicator(sim)","category":"section"},{"location":"amr/#Grid-Types","page":"Adaptive Mesh Refinement","title":"Grid Types","text":"","category":"section"},{"location":"amr/#StaggeredGrid","page":"Adaptive Mesh Refinement","title":"StaggeredGrid","text":"The base grid type using MAC (Marker-And-Cell) layout:\n\nVelocities at face centers\nPressure at cell centers\nSupports 2D (XZ plane) and 3D","category":"section"},{"location":"amr/#RefinedGrid","page":"Adaptive Mesh Refinement","title":"RefinedGrid","text":"Container for AMR data:\n\nTracks:\n\nBase (coarse) grid\nRefined cell locations and levels\nLocal refined sub-grids\nInterpolation weights","category":"section"},{"location":"amr/#Performance-Considerations","page":"Adaptive Mesh Refinement","title":"Performance Considerations","text":"Regrid Interval: Larger intervals reduce overhead but may miss features\nBuffer Size: Prevents refinement boundaries from affecting solution\nMax Level: Higher levels increase accuracy but add cost\nIndicator Weights: Tune based on flow physics","category":"section"},{"location":"amr/#Example:-Wake-Refinement","page":"Adaptive Mesh Refinement","title":"Example: Wake Refinement","text":"# Emphasize wake region (high vorticity) over body proximity\nconfig = AMRConfig(\n    max_level = 3,\n    body_weight = 0.2,        # Less emphasis on body\n    gradient_weight = 0.3,\n    vorticity_weight = 0.5,   # More emphasis on wake\n    regrid_interval = 20\n)","category":"section"},{"location":"amr/#Composite-Solver-(Advanced)","page":"Adaptive Mesh Refinement","title":"Composite Solver (Advanced)","text":"For advanced users, BioFlows exposes the internal composite solver types used for AMR pressure projection.","category":"section"},{"location":"amr/#CompositePoisson","page":"Adaptive Mesh Refinement","title":"CompositePoisson","text":"The composite Poisson solver combines a base multigrid solver with refined patches:\n\n# CompositePoisson manages:\n# - Base grid: MultiLevelPoisson for coarse solution\n# - Patches: PatchPoisson solvers for refined regions\n# - Velocity: RefinedVelocityField for patch velocities","category":"section"},{"location":"amr/#Patch-Types","page":"Adaptive Mesh Refinement","title":"Patch Types","text":"Type Description\nPatchPoisson Local Poisson solver for a refined patch\nRefinedVelocityPatch Velocity storage at refined resolution\nRefinedVelocityField Collection of velocity patches","category":"section"},{"location":"amr/#Patch-Operations","page":"Adaptive Mesh Refinement","title":"Patch Operations","text":"# Add/remove patches\nadd_patch!(field, anchor, patch)\nremove_patch!(field, anchor)\nget_patch(field, anchor)\nclear_patches!(field)\n\n# Query patches\nhas_patches(cp)\nnum_patches(cp)","category":"section"},{"location":"amr/#AMR-Projection","page":"Adaptive Mesh Refinement","title":"AMR Projection","text":"The amr_project! function performs divergence-free projection on all levels:\n\n# Full AMR projection workflow:\n# 1. Set divergence on base grid\n# 2. Set divergence on refined patches\n# 3. Interpolate velocity to patches\n# 4. Solve composite Poisson system\n# 5. Correct velocities at all levels\n# 6. Enforce interface consistency\n\namr_project!(flow, cp)","category":"section"},{"location":"amr/#Utility-Functions","page":"Adaptive Mesh Refinement","title":"Utility Functions","text":"Function Description\namr_cfl(flow, cp) CFL considering refined patches\ncheck_amr_divergence(flow, cp) Divergence at all levels\nsynchronize_base_and_patches!(flow, cp) Sync after regridding","category":"section"},{"location":"amr/#BioFlows.AMRSimulation","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRSimulation","text":"AMRSimulation\n\nSimulation with adaptive mesh refinement near immersed bodies.\n\nWraps a standard Simulation and adds AMR capability that automatically refines the mesh near the body and in regions of high gradients.\n\nFields\n\nsim: The underlying Simulation\nconfig: AMR configuration parameters\nrefined_grid: Current refined grid state\ncomposite_pois: CompositePoisson solver for AMR (manages base + patches)\nadapter: Flow-to-grid adapter\nlast_regrid_step: Step count at last regrid\namr_active: Whether AMR is currently active\n\nExample\n\nconfig = AMRConfig(max_level=3, body_distance_threshold=4.0, regrid_interval=5)\nsim = AMRSimulation((128, 128), (1.0, 0.0), 16.0;\n                    ν=0.01, body=AutoBody(sdf), amr_config=config)\nfor _ in 1:1000\n    sim_step!(sim; remeasure=true)  # AMR regridding happens automatically\nend\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.AMRConfig","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRConfig","text":"AMRConfig\n\nConfiguration for adaptive mesh refinement.\n\nFields\n\nmax_level: Maximum refinement level (1 = 2x finer, 2 = 4x finer, etc.)\nbody_distance_threshold: Refine within this distance (in grid cells) from body\nvelocity_gradient_threshold: Threshold for velocity gradient refinement\nvorticity_threshold: Threshold for vorticity-based refinement\nregrid_interval: Number of time steps between regridding checks\nbuffer_size: Number of buffer cells around refined regions\nbody_weight: Weight for body proximity in combined indicator\ngradient_weight: Weight for velocity gradient in combined indicator\nvorticity_weight: Weight for vorticity in combined indicator\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.StaggeredGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.StaggeredGrid","text":"StaggeredGrid\n\nRepresents a staggered (MAC) grid for CFD computations. Velocity components are stored at face centers, pressure at cell centers.\n\nFields\n\ngrid_type: Dimensionality (TwoDimensional or ThreeDimensional)\nnx, ny, nz: Number of cells in each direction (ny=1 for 2D)\ndx, dy, dz: Cell spacing in each direction\nx, y, z: Cell center coordinates\nxf, yf, zf: Face coordinates (staggered locations)\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.RefinedGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.RefinedGrid","text":"RefinedGrid\n\nContainer for adaptive mesh refinement data. Stores the base grid and tracking information for refined cells.\n\nFields\n\nbase_grid: The coarse/base level grid\nrefined_cells_2d/3d: Dict mapping cell indices to refinement level\nrefined_grids_2d/3d: Dict mapping cell indices to local refined StaggeredGrid\ninterpolation_weights_2d/3d: Pre-computed interpolation weights\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"BioFlows provides built-in diagnostics for forces, vorticity, and flow statistics.","category":"section"},{"location":"diagnostics/#Force-Computation","page":"Diagnostics","title":"Force Computation","text":"","category":"section"},{"location":"diagnostics/#Force-Components","page":"Diagnostics","title":"Force Components","text":"","category":"section"},{"location":"diagnostics/#Usage","page":"Diagnostics","title":"Usage","text":"using BioFlows\n\n# Get all force components (uses simulation's ρ from sim.flow.ρ)\ncomponents = force_components(sim; reference_area=sim.L)\n\n# Access individual forces (in Newtons)\npressure_force = components.pressure   # [Fx, Fz] or [Fx, Fy, Fz]\nviscous_force = components.viscous\ntotal_force = components.total\n\n# Dimensionless coefficients (Cd, Cl, etc.)\nCd, Cl = components.coefficients[3]  # Total force coefficients\n\n# For air simulations, set ρ when creating the simulation:\nsim_air = Simulation((128, 64), (1.0, 0.5); ν=1.5e-5, ρ=1.2, body=cylinder)","category":"section"},{"location":"diagnostics/#Force-History","page":"Diagnostics","title":"Force History","text":"Record forces over time for analysis:\n\nhistory = NamedTuple[]\n\nfor step in 1:1000\n    sim_step!(sim)\n    record_force!(history, sim; reference_area=sim.L)  # Uses water density by default\nend\n\n# Access recorded data\ntimes = [h.time for h in history]\ndrag_coeffs = [h.total_coeff[1] for h in history]\nlift_coeffs = [h.total_coeff[2] for h in history]","category":"section"},{"location":"diagnostics/#Force-Statistics","page":"Diagnostics","title":"Force Statistics","text":"# Compute mean and RMS after discarding transient\nstats = summarize_force_history(history; discard=0.2)  # Discard first 20%\n\nprintln(\"Mean drag: \", stats.drag_mean)\nprintln(\"Drag std:  \", stats.drag_std)\nprintln(\"Mean lift: \", stats.lift_mean)\nprintln(\"Lift std:  \", stats.lift_std)","category":"section"},{"location":"diagnostics/#Automatic-Force-File-Output","page":"Diagnostics","title":"Automatic Force File Output","text":"Use ForceWriter to automatically save lift and drag coefficients to a JLD2 file at specified time intervals:\n\nusing BioFlows\n\n# Create simulation\nsim = Simulation((128, 128), (1.0, 0.0), 1.0; ν=0.001, body=AutoBody(sdf))\n\n# Create force writer - saves every 0.1 time units\nforce_writer = ForceWriter(\"forces.jld2\"; interval=0.1, reference_area=sim.L)\n\n# Time stepping loop\nfor _ in 1:5000\n    sim_step!(sim)\n    file_save!(force_writer, sim)  # Writes to JLD2 when interval elapsed\nend\n\nThe JLD2 file contains arrays: time, Cd, Cl, Cd_pressure, Cd_viscous, Cl_pressure, Cl_viscous.\n\n# Read the output file\nusing JLD2\ndata = load(\"forces.jld2\")\ntime = data[\"time\"]\nCd = data[\"Cd\"]\nCl = data[\"Cl\"]","category":"section"},{"location":"diagnostics/#Vorticity","page":"Diagnostics","title":"Vorticity","text":"","category":"section"},{"location":"diagnostics/#Vorticity-Fields","page":"Diagnostics","title":"Vorticity Fields","text":"","category":"section"},{"location":"diagnostics/#Usage-2","page":"Diagnostics","title":"Usage","text":"# Out-of-plane vorticity for 2D (ω₃ = ∂v/∂x - ∂u/∂z)\nω3 = vorticity_component(sim, 3)\n\n# Vorticity magnitude\nω_mag = vorticity_magnitude(sim)\n\n# For 3D simulations\nωx = vorticity_component(sim, 1)\nωy = vorticity_component(sim, 2)\nωz = vorticity_component(sim, 3)","category":"section"},{"location":"diagnostics/#Ghost-Layer-Handling","page":"Diagnostics","title":"Ghost Layer Handling","text":"By default, ghost layers are stripped from output:\n\n# With ghost layers stripped (default)\nω = vorticity_component(sim, 3; strip_ghosts=true)\n\n# Keep ghost layers\nω_with_ghosts = vorticity_component(sim, 3; strip_ghosts=false)","category":"section"},{"location":"diagnostics/#Cell-Centered-Fields","page":"Diagnostics","title":"Cell-Centered Fields","text":"For visualization and output, interpolate to cell centers:","category":"section"},{"location":"diagnostics/#Usage-3","page":"Diagnostics","title":"Usage","text":"# Cell-centered velocity [nx, nz, 2] or [nx, ny, nz, 3]\nvel = cell_center_velocity(sim)\n\n# Cell-centered vorticity\n# 2D: scalar field [nx, nz]\n# 3D: vector field [nx, ny, nz, 3]\nvort = cell_center_vorticity(sim)\n\n# Cell-centered pressure [nx, nz] or [nx, ny, nz]\npres = cell_center_pressure(sim)","category":"section"},{"location":"diagnostics/#Simulation-Diagnostics","page":"Diagnostics","title":"Simulation Diagnostics","text":"The compute_diagnostics function returns summary statistics for the current simulation state.","category":"section"},{"location":"diagnostics/#Usage-4","page":"Diagnostics","title":"Usage","text":"diag = compute_diagnostics(sim)\n\nprintln(\"Max u-velocity: \", diag.max_u)\nprintln(\"Max w-velocity: \", diag.max_w)\nprintln(\"CFL number:     \", diag.CFL)\nprintln(\"Time step:      \", diag.Δt)\nprintln(\"Grid size:      \", diag.grid)","category":"section"},{"location":"diagnostics/#Example:-Complete-Diagnostics-Loop","page":"Diagnostics","title":"Example: Complete Diagnostics Loop","text":"using BioFlows\nusing Statistics\n\n# Setup simulation\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\n# Storage\nforce_history = NamedTuple[]\nmax_cfl = 0.0\n\n# Main loop\nfor step in 1:5000\n    sim_step!(sim; remeasure=false)\n    record_force!(force_history, sim)\n\n    # Track CFL\n    diag = compute_diagnostics(sim)\n    max_cfl = max(max_cfl, diag.CFL)\n\n    # Print every 500 steps\n    if step % 500 == 0\n        stats = summarize_force_history(force_history; discard=0.3)\n        println(\"Step $step: t=$(round(sim_time(sim), digits=2)), \",\n                \"Cd=$(round(stats.drag_mean, digits=3)), \",\n                \"CFL=$(round(diag.CFL, digits=3))\")\n    end\nend\n\n# Final statistics\nfinal_stats = summarize_force_history(force_history; discard=0.3)\nprintln(\"\\nFinal Results:\")\nprintln(\"  Mean Cd = \", round(final_stats.drag_mean, digits=4))\nprintln(\"  Std Cd  = \", round(final_stats.drag_std, digits=4))\nprintln(\"  Mean Cl = \", round(final_stats.lift_mean, digits=4))\nprintln(\"  Max CFL = \", round(max_cfl, digits=3))","category":"section"},{"location":"diagnostics/#Visualization","page":"Diagnostics","title":"Visualization","text":"BioFlows integrates with Plots.jl via extensions:\n\nusing Plots\nusing BioFlows\n\n# Get vorticity field\nω = vorticity_component(sim, 3)\n\n# Plot with flood\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity field\")\n\nFor VTK output (ParaView compatible):\n\nusing WriteVTK\nusing BioFlows\n\n# VTK writer becomes available\nvtkWriter(sim, \"output_dir\")","category":"section"},{"location":"diagnostics/#BioFlows.force_components","page":"Diagnostics","title":"BioFlows.force_components","text":"force_components(sim; reference_area=sim.L, with_coefficients=true)\n\nCollect pressure, viscous, and total force vectors for sim in Newtons. When with_coefficients=true, dimensionless coefficients are returned using the reference area ½ρU²A. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.force_coefficients","page":"Diagnostics","title":"BioFlows.force_coefficients","text":"force_coefficients(sim; reference_area=sim.L)\n\nConvenience wrapper returning only the total force coefficients. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.record_force!","page":"Diagnostics","title":"BioFlows.record_force!","text":"record_force!(history, sim; reference_area=sim.L)\n\nAppend a force sample to history, which should be a Vector of NamedTuples. Stores time, raw forces (in Newtons), and dimensionless coefficients. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_component","page":"Diagnostics","title":"BioFlows.vorticity_component","text":"vorticity_component(sim, component; strip_ghosts=true)\n\nReturn the requested vorticity component evaluated at cell centres. For 2D simulations use component=3 to obtain the out-of-plane vorticity.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_magnitude","page":"Diagnostics","title":"BioFlows.vorticity_magnitude","text":"vorticity_magnitude(sim; strip_ghosts=true)\n\nCompute the vorticity magnitude field for the current simulation state.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_velocity","page":"Diagnostics","title":"BioFlows.cell_center_velocity","text":"cell_center_velocity(sim; strip_ghosts=true)\n\nReturn the velocity field averaged to cell centres for each component. The last dimension indexes the velocity components.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_vorticity","page":"Diagnostics","title":"BioFlows.cell_center_vorticity","text":"cell_center_vorticity(sim; strip_ghosts=true)\n\nReturn the vorticity at cell centres. For 2D simulations this returns a scalar field (the ω₃ component); for 3D it returns the full vector with the last dimension indexing components.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_pressure","page":"Diagnostics","title":"BioFlows.cell_center_pressure","text":"cell_center_pressure(sim; strip_ghosts=true)\n\nReturn the pressure field at cell centres. Pressure is already cell-centred in the staggered grid, so this simply returns the field with optional ghost cell stripping.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"BioFlows includes several example scripts in the examples/ directory.","category":"section"},{"location":"examples/#Flow-Past-Cylinder-(2D)","page":"Examples","title":"Flow Past Cylinder (2D)","text":"File: examples/flow_past_cylinder_2d.jl\n\nThe most comprehensive example with configurable parameters:\n\nusing BioFlows\n\ninclude(\"examples/flow_past_cylinder_2d.jl\")\n\n# Run with custom parameters\nsim, history, stats, writer, diagnostics = run_flow_past_cylinder(\n    nx = 256,           # Grid points in x\n    nz = 64,            # Grid points in z\n    Lx = 8.0,           # Domain length\n    Lz = 2.0,           # Domain height\n    Re = 150,           # Reynolds number\n    final_time = 10.0,  # Convective time units\n    save_center_fields = true,\n    center_filename = \"output.jld2\",\n    diagnostic_interval = 100\n)\n\nprintln(\"Mean Cd: \", stats.drag_mean)\nprintln(\"Lift RMS: \", stats.lift_rms)","category":"section"},{"location":"examples/#Command-Line","page":"Examples","title":"Command Line","text":"julia --project examples/flow_past_cylinder_2d.jl","category":"section"},{"location":"examples/#Output","page":"Examples","title":"Output","text":"Force history with Cd/Cl coefficients\nCell-centered velocity/vorticity snapshots (JLD2)\nDiagnostic statistics","category":"section"},{"location":"examples/#Circle-Benchmark","page":"Examples","title":"Circle Benchmark","text":"File: examples/circle_benchmark.jl\n\nSimple 2D cylinder for benchmarking:\n\nusing BioFlows\n\nradius = 8\ncenter = 4 * radius - 1\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\nsim = Simulation((6radius, 8radius), (1, 0), 2radius;\n                 ν = 2radius / 120,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-2","page":"Examples","title":"Command Line","text":"julia --project examples/circle_benchmark.jl","category":"section"},{"location":"examples/#Oscillating-Cylinder","page":"Examples","title":"Oscillating Cylinder","text":"File: examples/oscillating_cylinder.jl\n\nCylinder with sinusoidal cross-flow motion:\n\nusing BioFlows\n\nradius = 8\nA = radius / 2    # Oscillation amplitude\nSt = 0.2          # Strouhal number\nω = 2π * St       # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]\n\nbody = AutoBody(sdf, map)\n\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = body)\n\n# Must remeasure for moving bodies\nsim_step!(sim, 5.0; remeasure=true)","category":"section"},{"location":"examples/#Command-Line-3","page":"Examples","title":"Command Line","text":"julia --project examples/oscillating_cylinder.jl","category":"section"},{"location":"examples/#3D-Torus","page":"Examples","title":"3D Torus","text":"File: examples/torus_3d.jl\n\n3D torus in periodic inflow:\n\nusing BioFlows\n\nR = 16  # Major radius\nr = 4   # Minor radius\n\nfunction sdf_torus(x, t)\n    # Distance from torus centerline\n    d_ring = sqrt(x[1]^2 + x[2]^2) - R\n    sqrt(d_ring^2 + x[3]^2) - r\nend\n\nsim = Simulation((64, 64, 64), (1, 0, 0), 2r;\n                 ν = 2r / 50,\n                 body = AutoBody(sdf_torus),\n                 perdir = (1, 2))  # Periodic in x and y\n\nsim_step!(sim, 2.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-4","page":"Examples","title":"Command Line","text":"julia --project examples/torus_3d.jl","category":"section"},{"location":"examples/#3D-Sphere","page":"Examples","title":"3D Sphere","text":"File: examples/sphere_3d.jl\n\n3D sphere wake simulation:\n\nusing BioFlows\n\nradius = 8\ncenter = [32, 32, 32]\n\nsdf(x, t) = sqrt(sum((x .- center).^2)) - radius\n\nsim = Simulation((128, 64, 64), (1, 0, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-5","page":"Examples","title":"Command Line","text":"julia --project examples/sphere_3d.jl","category":"section"},{"location":"examples/#Visualization-Examples","page":"Examples","title":"Visualization Examples","text":"","category":"section"},{"location":"examples/#Plot-Vorticity","page":"Examples","title":"Plot Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup simulation\nradius = 8\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - radius\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\n# Run simulation\nsim_step!(sim, 5.0; remeasure=false)\n\n# Get vorticity\nω = vorticity_component(sim, 3)\n\n# Create plot\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        aspect_ratio=:equal,\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity ω_z\")\nsavefig(\"vorticity.png\")","category":"section"},{"location":"examples/#Animate-Vorticity","page":"Examples","title":"Animate Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - 8\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\nanim = @animate for step in 1:500\n    sim_step!(sim)\n\n    if step % 10 == 0\n        ω = vorticity_component(sim, 3)\n        heatmap(ω', c=:RdBu, clim=(-2, 2),\n                title=\"t = $(round(sim_time(sim), digits=2))\")\n    end\nend\n\ngif(anim, \"vorticity.gif\", fps=15)","category":"section"},{"location":"examples/#Loading-Saved-Data","page":"Examples","title":"Loading Saved Data","text":"Read JLD2 snapshots from CenterFieldWriter:\n\nusing JLD2\n\n# Load snapshot\njldopen(\"center_fields.jld2\", \"r\") do file\n    # List snapshots\n    for key in keys(file)\n        println(key)\n    end\n\n    # Read specific snapshot\n    t = file[\"snapshot_10/time\"]\n    vel = file[\"snapshot_10/velocity\"]\n    vort = file[\"snapshot_10/vorticity\"]\nend","category":"section"},{"location":"examples/#GPU-Execution","page":"Examples","title":"GPU Execution","text":"Run on NVIDIA GPU:\n\nusing CUDA\nusing BioFlows\n\nsim = Simulation((256, 128), (1, 0), 16.0;\n                 ν = 16.0 / 200,\n                 body = AutoBody(sdf),\n                 mem = CuArray)  # Use GPU arrays\n\nsim_step!(sim, 10.0)","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")","category":"section"},{"location":"getting_started/#Local-Development","page":"Getting Started","title":"Local Development","text":"Clone the repository and activate:\n\ngit clone https://github.com/subhk/BioFlows.jl.git\ncd BioFlows.jl\njulia --project\n\nThen instantiate dependencies:\n\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"getting_started/#Your-First-Simulation","page":"Getting Started","title":"Your First Simulation","text":"Here's a complete example of simulating flow past a 2D cylinder:\n\nusing BioFlows\n\n# Physical parameters\nRe = 100        # Reynolds number\nU = 1.0         # Inlet velocity\nD = 16.0        # Cylinder diameter (length scale)\n\n# Grid and domain parameters\nnx, nz = 128, 64\nLx, Lz = Float64(nx), Float64(nz)  # Domain size (Δx = 1)\n\n# Define cylinder geometry\ncenter_x = nx / 4\ncenter_z = nz / 2\nradius = D / 2\n\n# Signed distance function (negative inside body)\nsdf(x, t) = sqrt((x[1] - center_x)^2 + (x[2] - center_z)^2) - radius\n\n# Create simulation\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 ν = U * D / Re,\n                 body = AutoBody(sdf),\n                 L_char = D)\n\n# Time integration\nfinal_time = 10.0  # Convective time units\n\nwhile sim_time(sim) < final_time\n    sim_step!(sim; remeasure=false)\n\n    # Print progress every 100 steps\n    if length(sim.flow.Δt) % 100 == 0\n        println(\"t = \", round(sim_time(sim), digits=2))\n    end\nend\n\nprintln(\"Simulation complete!\")","category":"section"},{"location":"getting_started/#Key-Concepts","page":"Getting Started","title":"Key Concepts","text":"","category":"section"},{"location":"getting_started/#Dimensionless-Time","page":"Getting Started","title":"Dimensionless Time","text":"BioFlows uses dimensionless (convective) time:\n\nt^* = fract cdot UL\n\nwhere U is the velocity scale and L is the length scale.\n\nsim_time(sim) returns the current dimensionless time t*\ntime(sim.flow) returns the raw simulation time t","category":"section"},{"location":"getting_started/#Signed-Distance-Functions","page":"Getting Started","title":"Signed Distance Functions","text":"Geometry is defined implicitly via signed distance functions (SDF):\n\nsdf(x, t) < 0: Inside the body\nsdf(x, t) = 0: On the body surface\nsdf(x, t) > 0: Outside the body\n\nExample SDFs:\n\n# Circle/Cylinder\nsdf_circle(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\n\n# Rectangle\nsdf_rect(x, t) = max(abs(x[1]) - width/2, abs(x[2]) - height/2)\n\n# Sphere (3D)\nsdf_sphere(x, t) = sqrt(x[1]^2 + x[2]^2 + x[3]^2) - radius","category":"section"},{"location":"getting_started/#Boundary-Conditions","page":"Getting Started","title":"Boundary Conditions","text":"Specify inlet boundary conditions via the inletBC keyword argument:\n\n# Constant inlet velocity (uniform flow)\nsim = Simulation(dims, L; inletBC=(1.0, 0.0), ...)\n\n# Spatially-varying inlet (parabolic profile in z)\n# Function signature: inletBC(i, x, t) where i=component, x=position, t=time\nH = Lz / 2  # channel half-height\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\nsim = Simulation(dims, L; inletBC=inletBC, U=U_max, ...)  # Must specify U for functions\n\n# Time-varying inlet (oscillating)\ninletBC(i, x, t) = i == 1 ? 1.0 + 0.1*sin(2π*t) : 0.0\nsim = Simulation(dims, L; inletBC=inletBC, U=1.0, ...)\n\nAdditional boundary options:\n\nperdir=(2,): Make direction 2 (z) periodic\noutletBC=true: Convective outlet in x-direction","category":"section"},{"location":"getting_started/#Running-Examples","page":"Getting Started","title":"Running Examples","text":"The examples/ directory contains ready-to-run scripts:\n\njulia --project examples/flow_past_cylinder_2d.jl\njulia --project examples/circle_benchmark.jl\njulia --project examples/oscillating_cylinder.jl\n\nSee Examples for detailed descriptions.","category":"section"},{"location":"core_types/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"core_types/#Simulation","page":"Core Types","title":"Simulation","text":"The main container for a BioFlows simulation.","category":"section"},{"location":"core_types/#Constructor","page":"Core Types","title":"Constructor","text":"Simulation(dims::NTuple{N}, L::NTuple{N};\n           inletBC=nothing, U=nothing, Δt=0.25, fixed_Δt=nothing, ν=0., ϵ=1, g=nothing,\n           perdir=(), outletBC=false, L_char=nothing, store_fluxes=false,\n           body::AbstractBody=NoBody(),\n           T=Float32, mem=Array)\n\nArguments:\n\nParameter Type Description\ndims NTuple{N,Int} Grid dimensions (nx, nz) or (nx, ny, nz)\nL NTuple{N} Physical domain size (Lx, Lz) or (Lx, Ly, Lz) in meters\ninletBC Tuple or Function Inlet boundary velocity (see below). Default: (1, 0, ...)\nU Number Velocity scale (auto-computed if inletBC is constant, required if function)\nΔt Number Initial time step (default: 0.25)\nfixed_Δt Number or Nothing Fixed time step. If set, disables adaptive CFL (default: nothing)\nν Number Kinematic viscosity (Re = U*L/ν)\nρ Number Fluid density (default: 1000 kg/m³ for water)\nϵ Number BDIM kernel width (default: 1)\ng Function or Nothing Acceleration field g(i,x,t)\nperdir Tuple Periodic directions, e.g. (2,)\noutletBC Bool Convective outlet in x-direction\nL_char Number Characteristic length for force coefficients (default: L[1])\nstore_fluxes Bool Enable FVM flux storage for conservation analysis (default: false)\nbody AbstractBody Immersed geometry\nT Type Float type (Float32 or Float64)\nmem Type Array backend (Array for CPU)","category":"section"},{"location":"core_types/#Inlet-Boundary-Conditions","page":"Core Types","title":"Inlet Boundary Conditions","text":"The inletBC parameter specifies the inlet velocity and can be:\n\nConstant (Tuple): Uniform velocity across the inlet\ninletBC = (1.0, 0.0)  # U=1 in x, 0 in z\nSpatially-varying (Function): Velocity varies with position\n# Parabolic profile: u(z) = U_max * (1 - (z-H)²/H²)\nH = Lz / 2\ninletBC(i, x, t) = i == 1 ? 1.5 * (1 - ((x[2] - H) / H)^2) : 0.0\nTime-varying (Function): Velocity varies with time\n# Oscillating inlet\ninletBC(i, x, t) = i == 1 ? 1.0 + 0.1*sin(2π*t) : 0.0\n\nFunction signature: inletBC(i, x, t) where:\n\ni: Velocity component (1=x, 2=z in 2D; 1=x, 2=y, 3=z in 3D)\nx: Position vector [x, z] or [x, y, z]\nt: Time","category":"section"},{"location":"core_types/#Fields","page":"Core Types","title":"Fields","text":"Field Description\nU Velocity scale\nL Length scale\nϵ BDIM kernel width\nflow Flow struct with velocity/pressure fields\nbody Immersed body geometry\npois Pressure Poisson solver","category":"section"},{"location":"core_types/#Flow","page":"Core Types","title":"Flow","text":"The Flow struct holds all fluid fields for the simulation.","category":"section"},{"location":"core_types/#Fields-2","page":"Core Types","title":"Fields","text":"Field Type Description\nu Array{T,D+1} Velocity vector field (m/s)\nu⁰ Array{T,D+1} Previous velocity (for time stepping)\nf Array{T,D+1} Force/RHS vector field (m/s²)\np Array{T,D} Pressure scalar field (Pa = kg/(m·s²))\nσ Array{T,D} Divergence scalar field (work array)\nV Array{T,D+1} Body velocity vector (BDIM)\nμ₀ Array{T,D+1} Zeroth moment (BDIM)\nμ₁ Array{T,D+2} First moment tensor (BDIM)\nF_conv Array{T,D+2} or Nothing Convective flux tensor (FVM mode)\nF_diff Array{T,D+2} or Nothing Diffusive flux tensor (FVM mode)\nstore_fluxes Bool FVM flux storage enabled\nΔt Vector{T} Time step history (s)\nν T Kinematic viscosity (m²/s)\nρ T Fluid density (kg/m³), default 1000 (water)\nΔx NTuple{D,T} Grid spacing per direction (m)\nfixed_Δt T or Nothing Fixed time step (disables CFL)","category":"section"},{"location":"core_types/#FVM-Flux-Storage","page":"Core Types","title":"FVM Flux Storage","text":"When store_fluxes=true, the Flow stores explicit flux tensors for conservation analysis:\n\n# Enable FVM mode\nflow = Flow((nx, nz); L=(Lx, Lz), store_fluxes=true, ν=0.01)\n\n# Access flux tensors after time step\nF_conv = flow.F_conv  # Convective flux: F_conv[I, j, i]\nF_diff = flow.F_diff  # Diffusive flux: F_diff[I, j, i]\n\nThe flux tensor indices are:\n\nI = spatial cell index (D-dimensional CartesianIndex)\nj = face direction (1=x, 2=y, 3=z)\ni = momentum component being transported","category":"section"},{"location":"core_types/#AutoBody","page":"Core Types","title":"AutoBody","text":"Define geometry implicitly via signed distance functions.","category":"section"},{"location":"core_types/#Constructor-2","page":"Core Types","title":"Constructor","text":"AutoBody(sdf, map=(x,t)->x; compose=true)\n\nArguments:\n\nParameter Description\nsdf Signed distance function sdf(x, t)\nmap Coordinate mapping function map(x, t) for moving bodies\ncompose Auto-compose sdf∘map when true (default)","category":"section"},{"location":"core_types/#Example:-Static-Cylinder","page":"Core Types","title":"Example: Static Cylinder","text":"radius = 8\ncenter = [32, 32]\nsdf(x, t) = sqrt((x[1] - center[1])^2 + (x[2] - center[2])^2) - radius\nbody = AutoBody(sdf)","category":"section"},{"location":"core_types/#Example:-Oscillating-Cylinder","page":"Core Types","title":"Example: Oscillating Cylinder","text":"radius = 8\nA = 5.0  # Amplitude\nω = 0.5  # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]  # Vertical oscillation\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Example:-Rotating-Ellipse","page":"Core Types","title":"Example: Rotating Ellipse","text":"a, b = 10, 5  # Semi-axes\nω = 0.2       # Angular velocity\n\nsdf(x, t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\n\nfunction map(x, t)\n    θ = ω * t\n    c, s = cos(θ), sin(θ)\n    [c*x[1] + s*x[2], -s*x[1] + c*x[2]]\nend\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Simulation-Control-Functions","page":"Core Types","title":"Simulation Control Functions","text":"","category":"section"},{"location":"core_types/#Time-Stepping","page":"Core Types","title":"Time Stepping","text":"","category":"section"},{"location":"core_types/#Usage","page":"Core Types","title":"Usage","text":"# Single time step\nsim_step!(sim; remeasure=true)\n\n# Integrate to target time\nsim_step!(sim, 10.0; remeasure=false, verbose=true)\n\n# Query time\nt_star = sim_time(sim)  # Dimensionless time t*U/L\nt_raw = time(sim.flow)  # Raw simulation time\n\n# Update body for moving geometry\nmeasure!(sim)\n\n# Add perturbations for flow instability\nperturb!(sim; noise=0.1)\n\n# Print status\nsim_info(sim)  # Prints: tU/L=..., Δt=...","category":"section"},{"location":"core_types/#BioFlows.Simulation","page":"Core Types","title":"BioFlows.Simulation","text":"Simulation(dims::NTuple{N}, L::NTuple{N}; inletBC=(1,0,...), kwargs...)\n\nConstructor for a BioFlows simulation solving the dimensional incompressible Navier-Stokes equations:\n\n∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g\n∇·u = 0\n\nArguments\n\nRequired\n\ndims::NTuple{N,Int}: Number of grid cells in each direction, e.g., (nx, nz) or (nx, ny, nz)\nL::NTuple{N}: Physical domain size in each direction (e.g., (Lx, Lz) in meters)\n\nOptional (keyword arguments)\n\ninletBC: Inlet boundary velocity (default: unit velocity in x-direction)\nTuple: Constant velocity, e.g., (1.0, 0.0) for uniform flow\nFunction(i,x,t): Spatially/temporally varying (requires U to be specified)\noutletBC=false: Enable convective outlet BC in direction 1\nν=0.: Kinematic viscosity (m²/s)\nρ=1000.: Fluid density (kg/m³). Water = 1000, air ≈ 1.2\nbody=NoBody(): Immersed body geometry\nL_char: Characteristic length for force coefficients (default: L[1])\nU: Velocity scale. Auto-computed from inletBC if constant, required if function\nΔt=0.25: Initial time step (seconds)\nfixed_Δt=nothing: Fixed time step (seconds). If specified, disables adaptive CFL time stepping.\ng=nothing: Body acceleration function g(i,x,t) (m/s²)\nϵ=1: BDIM kernel width (in grid cells)\nperdir=(): Periodic directions, e.g., (2,) for z-periodic\nuλ=nothing: Initial velocity condition. Tuple or Function(i,x)\nT=Float32: Numeric type\nmem=Array: Memory backend (Array, CuArray, etc.)\nstore_fluxes=false: Enable FVM flux storage for conservation analysis\n\nExamples\n\nConstant inlet velocity\n\n# 2D channel with uniform inlet\nsim = Simulation((256, 128), (2.0, 1.0); inletBC=(1.0, 0.0), ν=1e-6)\n\n# With immersed cylinder\ndiameter = 0.2\ncylinder = AutoBody((x,t) -> √(x[1]^2 + x[2]^2) - diameter/2)\nsim = Simulation((256, 128), (2.0, 1.0);\n                 inletBC = (1.0, 0.0),\n                 ν = 1e-6,\n                 body = cylinder,\n                 L_char = diameter)\n\nSpatially-varying inlet (parabolic profile)\n\n# Parabolic inlet: u(z) = U_max * (1 - (z - H)²/H²)\nLx, Lz = 2.0, 1.0\nH = Lz / 2\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\n\nsim = Simulation((256, 128), (Lx, Lz);\n                 inletBC = inletBC,\n                 U = U_max,\n                 ν = 1e-6,\n                 outletBC = true)\n\nTime-varying inlet\n\nU₀, ω = 1.0, 2π\ninletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(ω*t)) : 0.0\n\nsim = Simulation((256, 128), (2.0, 1.0); inletBC=inletBC, U=U₀, ν=1e-6)\n\nSee files in examples folder for more examples.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.Flow","page":"Core Types","title":"BioFlows.Flow","text":"Flow{D::Int, T::Float, Sf<:AbstractArray{T,D}, Vf<:AbstractArray{T,D+1}, Tf<:AbstractArray{T,D+2}}\n\nComposite type for a multidimensional immersed boundary flow simulation.\n\nFlow solves the unsteady incompressible Navier-Stokes equations on a Cartesian grid. Solid boundaries are modelled using the Boundary Data Immersion Method. The primary variables are the scalar pressure p (an array of dimension D) and the velocity vector field u (an array of dimension D+1).\n\nThe equations solved are the dimensional incompressible Navier-Stokes:     ∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g     ∇·u = 0\n\nwhere Δx is the uniform grid spacing (m), ν is kinematic viscosity (m²/s), and all spatial derivatives are properly scaled by Δx.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.AutoBody","page":"Core Types","title":"BioFlows.AutoBody","text":"AutoBody(sdf,map=(x,t)->x; compose=true) <: AbstractBody\n\nsdf(x::AbstractVector,t::Real)::Real: signed distance function\nmap(x::AbstractVector,t::Real)::AbstractVector: coordinate mapping function\ncompose::Bool=true: Flag for composing sdf=sdf∘map\n\nImplicitly define a geometry by its sdf and optional coordinate map. Note: the map is composed automatically if compose=true, i.e. sdf(x,t) = sdf(map(x,t),t). Both parameters remain independent otherwise. It can be particularly heplful to set compose=false when adding mulitple bodies together to create a more complex one.\n\nExamples\n\n# Static cylinder\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nbody = AutoBody(sdf)\n\n# Oscillating cylinder (vertical motion)\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x,t) = x .- [0, A*sin(ω*t)]  # Shift coordinate frame\nbody = AutoBody(sdf, map)\n\n# Rotating ellipse\nsdf(x,t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\nmap(x,t) = [cos(ω*t) sin(ω*t); -sin(ω*t) cos(ω*t)] * x\nbody = AutoBody(sdf, map)\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.sim_step!","page":"Core Types","title":"BioFlows.sim_step!","text":"sim_step!(sim::AbstractSimulation,t_end;remeasure=true,λ=quick,max_steps=typemax(Int),verbose=false,\n    udf=nothing,kwargs...)\n\nIntegrate the simulation sim up to dimensionless time t_end. If remeasure=true, the body is remeasured at every time step. Can be set to false for static geometries to speed up simulation. A user-defined function udf can be passed to arbitrarily modify the ::Flow during the predictor and corrector steps. If the udf user keyword arguments, these needs to be included in the sim_step! call as well. A λ::Function function can be passed as a custom convective scheme, following the interface of λ(u,c,d) (for upstream, central, downstream points).\n\n\n\n\n\nsim_step!(sim::AMRSimulation; remeasure=true, λ=quick, kwargs...)\n\nAdvance AMR simulation by one time step with automatic regridding. Uses CompositePoisson for pressure solve when AMR has refined patches.\n\n\n\n\n\nsim_step!(sim::AMRSimulation, t_end; kwargs...)\n\nAdvance AMR simulation up to dimensionless time t_end.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_time","page":"Core Types","title":"BioFlows.sim_time","text":"sim_time(sim::Simulation)\n\nReturn the current dimensionless time of the simulation tU/L where t=sum(Δt), and U,L are the simulation velocity and length scales.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.measure!","page":"Core Types","title":"BioFlows.measure!","text":"measure!(flow::Flow, body::AbstractBody; t=0, ϵ=1)\n\nQueries the body geometry to fill the arrays:\n\nflow.μ₀, Zeroth kernel moment\nflow.μ₁, First kernel moment scaled by the body normal\nflow.V,  Body velocity\n\nat time t using an immersion kernel of size ϵ.\n\nSee Maertens & Weymouth, doi:10.1016/j.cma.2014.09.007.\n\n\n\n\n\nmeasure!(sim::Simulation,t=timeNext(sim))\n\nMeasure a dynamic body to update the flow and pois coefficients.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.perturb!","page":"Core Types","title":"BioFlows.perturb!","text":"perturb!(sim; noise=0.1)\n\nPerturb the velocity field of a simulation with noise level with respect to velocity scale U.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_info","page":"Core Types","title":"BioFlows.sim_info","text":"sim_info(sim::AbstractSimulation)\n\nPrints information on the current state of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"#BioFlows.jl","page":"Home","title":"BioFlows.jl","text":"A Julia package for computational fluid dynamics with immersed boundary methods\n\nBioFlows.jl provides a complete solver for incompressible viscous flow on Cartesian grids using the Boundary Data Immersion Method (BDIM).","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Pure Julia solver for incompressible Navier-Stokes equations\nImmersed boundary method via BDIM (Boundary Data Immersion Method)\nImplicit geometry definition through signed distance functions\nAdaptive Mesh Refinement (AMR) near bodies and flow features\nCPU and GPU execution via KernelAbstractions.jl\nMPI support for distributed computing\nBuilt-in diagnostics: forces, vorticity, cell-centered fields\nJLD2 and VTK output (via extensions)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")\n\nOr activate the project locally:\n\njulia --project\njulia> ]instantiate","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using BioFlows\n\n# Define cylinder geometry via signed distance function\nradius = 8\ncenter = 32\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Create simulation: domain (nx, nz), boundary velocity, length scale\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,    # Re = 100\n                 body = AutoBody(sdf))\n\n# Advance to t*U/L = 1.0 (convective time units)\nsim_step!(sim, 1.0; remeasure=false)\n\n# Check simulation state\nprintln(\"Time: \", sim_time(sim))","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"numerical_methods.md\",\n    \"core_types.md\",\n    \"amr.md\",\n    \"diagnostics.md\",\n    \"examples.md\",\n    \"api.md\",\n]\nDepth = 2","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"Subhajit Kar\nDibyendu Ghosh","category":"section"},{"location":"numerical_methods/#Numerical-Methods","page":"Numerical Methods","title":"Numerical Methods","text":"This section describes the numerical methods used in BioFlows.jl for solving the incompressible Navier-Stokes equations.","category":"section"},{"location":"numerical_methods/#Governing-Equations","page":"Numerical Methods","title":"Governing Equations","text":"BioFlows.jl solves the incompressible Navier-Stokes equations in dimensional form:\n\nfracpartial mathbfupartial t + (mathbfu cdot nabla)mathbfu = -frac1rhonabla p + nu nabla^2 mathbfu\n\nnabla cdot mathbfu = 0\n\nwhere:\n\nmathbfu = (u v)\nis the velocity field (m/s)\np\nis the pressure (Pa)\nrho\nis the density (kg/m³)\nnu\nis the kinematic viscosity (m²/s)","category":"section"},{"location":"numerical_methods/#Staggered-Grid-(MAC-Grid)","page":"Numerical Methods","title":"Staggered Grid (MAC Grid)","text":"BioFlows.jl uses a staggered grid arrangement, also known as a Marker-And-Cell (MAC) grid. This arrangement naturally satisfies the discrete divergence-free condition and avoids spurious pressure oscillations (checkerboard modes).","category":"section"},{"location":"numerical_methods/#Variable-Locations-in-2D","page":"Numerical Methods","title":"Variable Locations in 2D","text":"On a staggered grid, different variables are stored at different locations within each cell:\n\nPressure (p): Cell centers\nx-velocity (u): Vertical cell faces (between left/right neighbors)\ny-velocity (v): Horizontal cell faces (between bottom/top neighbors)\n\n         Δx\n    ├─────────────┤\n\n    ┌─────────────┬─────────────┬─────────────┐  ─┬─\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │   │\n    │    p_i,j+1  │   p_i+1,j+1 │  p_i+2,j+1  │   │\n    │             │             │             │   Δy\n    u             u             u             u   │\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │  ─┴─\n    │    p_i,j    │   p_i+1,j   │  p_i+2,j    │\n    │             │             │             │\n    u             u             u             u\n    │             │             │             │\n    │      ●      v      ●      v      ●      │\n    │   p_i,j-1   │  p_i+1,j-1  │  p_i+2,j-1  │\n    │             │             │             │\n    └─────────────┴─────────────┴─────────────┘\n\n    Legend:\n    ●  = Pressure (p) at cell center\n    u  = x-velocity component at vertical faces\n    v  = y-velocity component at horizontal faces","category":"section"},{"location":"numerical_methods/#Detailed-Single-Cell-View","page":"Numerical Methods","title":"Detailed Single Cell View","text":"For a single cell (ij), the staggered arrangement is:\n\n                    v[i,j+1]\n                       ↑\n              ┌────────┼────────┐\n              │        │        │\n              │        │        │\n    u[i,j] ───┼───── p[i,j] ────┼─── u[i+1,j]\n      →       │        ●        │       →\n              │                 │\n              │                 │\n              └────────┼────────┘\n                       │\n                       ↓\n                    v[i,j]\n\n    Grid spacing: Δx (horizontal), Δy (vertical)\n    Cell center:  (i-½, j-½) in grid coordinates\n    u location:   (i, j-½) - on left/right faces\n    v location:   (i-½, j) - on bottom/top faces","category":"section"},{"location":"numerical_methods/#Indexing-Convention","page":"Numerical Methods","title":"Indexing Convention","text":"In BioFlows.jl, the arrays are indexed as follows:\n\nVariable Array Index Physical Location\np[i,j] Cell (ij) Center of cell (ij)\nu[i,j,1] Face (ij) Left face of cell (ij)\nu[i,j,2] Face (ij) Bottom face of cell (ij)\n\nThe velocity field is stored in a single array u[I,d] where I is the cell index and d is the direction (1=x, 2=y for 2D; 1=x, 2=y, 3=z for 3D).","category":"section"},{"location":"numerical_methods/#Extension-to-3D","page":"Numerical Methods","title":"Extension to 3D","text":"In three dimensions, the staggered grid extends naturally:\n\nPressure (p): Cell centers\nx-velocity (u): yz-faces (perpendicular to x)\ny-velocity (v): xz-faces (perpendicular to y)\nz-velocity (w): xy-faces (perpendicular to z)\n\n                        z\n                        │   y\n                        │  /\n                        │ /\n                        │/\n            ────────────┼──────────── x\n\n\n                    ┌───────────────────┐\n                   /│                  /│\n                  / │       w_top     / │\n                 /  │       ↑        /  │\n                ┌───────────────────┐   │\n                │   │      ●        │   │\n          u_L → │   │    p_ijk      │ → u_R\n                │   │               │   │\n                │   └ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ┘\n                │  /                │  /\n                │ /      ↓         │ /\n                │/    w_bottom     │/\n                └───────────────────┘\n                      ↗       ↘\n                   v_front   v_back\n\n\n    Legend:\n    ●     = Pressure at cell center (i,j,k)\n    u_L   = u[i,j,k,1] at left face\n    u_R   = u[i+1,j,k,1] at right face\n    v     = v[i,j,k,2] at front/back faces\n    w     = w[i,j,k,3] at top/bottom faces","category":"section"},{"location":"numerical_methods/#Finite-Difference-Operators","page":"Numerical Methods","title":"Finite Difference Operators","text":"","category":"section"},{"location":"numerical_methods/#Divergence","page":"Numerical Methods","title":"Divergence","text":"The discrete divergence operator at cell center (ij):\n\n(nabla cdot mathbfu)_ij = fracu_i+1j - u_ijDelta x + fracv_ij+1 - v_ijDelta y","category":"section"},{"location":"numerical_methods/#Gradient","page":"Numerical Methods","title":"Gradient","text":"The discrete pressure gradient at face locations:\n\nleft(fracpartial ppartial xright)_ij = fracp_ij - p_i-1jDelta x quad text(at u-location)\n\nleft(fracpartial ppartial yright)_ij = fracp_ij - p_ij-1Delta y quad text(at v-location)","category":"section"},{"location":"numerical_methods/#Laplacian","page":"Numerical Methods","title":"Laplacian","text":"The discrete Laplacian for the Poisson equation:\n\nnabla^2 p_ij = fracp_i+1j - 2p_ij + p_i-1jDelta x^2 + fracp_ij+1 - 2p_ij + p_ij-1Delta y^2","category":"section"},{"location":"numerical_methods/#Convection-Diffusion-Discretization","page":"Numerical Methods","title":"Convection-Diffusion Discretization","text":"The momentum equation contains convection and diffusion terms that must be carefully discretized on the staggered grid.","category":"section"},{"location":"numerical_methods/#Momentum-Equation","page":"Numerical Methods","title":"Momentum Equation","text":"For velocity component u_i, the semi-discrete momentum equation is:\n\nfracpartial u_ipartial t = -sum_j fracpartial (u_j u_i)partial x_j + nu sum_j fracpartial^2 u_ipartial x_j^2 - frac1rhofracpartial ppartial x_i\n\nThe convection term partial(u_j u_i)partial x_j represents momentum flux in direction j, while the diffusion term nu partial^2 u_ipartial x_j^2 represents viscous stress.","category":"section"},{"location":"numerical_methods/#Finite-Volume-Formulation","page":"Numerical Methods","title":"Finite Volume Formulation","text":"BioFlows.jl uses a conservative finite volume method (FVM) where fluxes are computed at cell faces and applied symmetrically to adjacent cells. This ensures exact conservation of momentum.\n\nFor a control volume around velocity u_i at location I:\n\nfracd u_i^Id t = sum_j left( F_ij^I - F_ij^I-delta_j right)\n\nwhere F_ij^I is the total flux (convective + diffusive) of momentum component i through face j at index I.","category":"section"},{"location":"numerical_methods/#Flux-Computation-at-Cell-Faces","page":"Numerical Methods","title":"Flux Computation at Cell Faces","text":"At each face in direction j, two fluxes contribute to the momentum balance:","category":"section"},{"location":"numerical_methods/#1.-Convective-Flux","page":"Numerical Methods","title":"1. Convective Flux","text":"The convective flux transports momentum with the flow velocity:\n\nF_ij^conv = fracu_j^faceDelta x_j cdot phi(u_i)\n\nwhere:\n\nu_j^face\n= face-normal velocity (interpolated to face)\nphi(u_i)\n= upwind-biased reconstruction of u_i at the face\nDelta x_j\n= grid spacing in direction j\n\nThe face velocity u_j^face is computed by interpolation:\n\nu_j^face = frac12(u_j^L + u_j^R)","category":"section"},{"location":"numerical_methods/#2.-Diffusive-Flux","page":"Numerical Methods","title":"2. Diffusive Flux","text":"The diffusive flux represents viscous stress:\n\nF_ij^diff = -fracnuDelta x_j left( u_i^I - u_i^I-delta_j right)\n\nThis is a central difference approximation to -nu partial u_i  partial x_j.","category":"section"},{"location":"numerical_methods/#Total-Flux","page":"Numerical Methods","title":"Total Flux","text":"The total flux at face I in direction j for momentum component i:\n\nF_ij^I = F_ij^convI + F_ij^diffI","category":"section"},{"location":"numerical_methods/#Upwind-Schemes-for-Convection","page":"Numerical Methods","title":"Upwind Schemes for Convection","text":"BioFlows.jl implements several upwind schemes for reconstructing face values. Given the stencil values u_U (upwind), u_C (center), u_D (downwind), the schemes compute the face value phi.","category":"section"},{"location":"numerical_methods/#QUICK-with-Median-Limiter","page":"Numerical Methods","title":"QUICK with Median Limiter","text":"BioFlows uses a modified QUICK scheme with a median limiter for stability:\n\nphi_QUICK = textmedianleft( frac5u_C + 2u_D - u_U6  u_C  textmedian(10u_C - 9u_U  u_C  u_D) right)\n\nThe median limiter prevents spurious oscillations near discontinuities while maintaining high accuracy in smooth regions. For smooth monotonic profiles, this reduces to the quadratic interpolation (5u_C + 2u_D - u_U)6.\n\nCode: quick(u,c,d) = median((5c+2d-u)/6, c, median(10c-9u,c,d))","category":"section"},{"location":"numerical_methods/#Van-Leer-(TVD)","page":"Numerical Methods","title":"Van Leer (TVD)","text":"The van Leer scheme uses a monotonicity-preserving limiter:\n\nphi_vanLeer = begincases\nu_C  textif  u_C leq min(u_U u_D) text or  u_C geq max(u_U u_D) \nu_C + (u_D - u_C) cdot fracu_C - u_Uu_D - u_U  textotherwise\nendcases\n\nThis ensures the interpolated value lies between neighboring values, preventing oscillations.\n\nCode: vanLeer(u,c,d) = (c≤min(u,d) || c≥max(u,d)) ? c : c+(d-c)*(c-u)/(d-u)","category":"section"},{"location":"numerical_methods/#Central-Difference-(CDS)","page":"Numerical Methods","title":"Central Difference (CDS)","text":"The central difference scheme provides 2nd-order accuracy but may oscillate:\n\nphi_CDS = fracu_C + u_D2\n\nCode: cds(u,c,d) = (c+d)/2","category":"section"},{"location":"numerical_methods/#Stencil-Selection","page":"Numerical Methods","title":"Stencil Selection","text":"The upwind direction is determined by the face velocity u_j^face:\n\nphi(u_i) = begincases\nlambda(u_i^I-2delta u_i^I-delta u_i^I)  textif  u_j^face  0 \nlambda(u_i^I+delta u_i^I u_i^I-delta)  textif  u_j^face  0\nendcases\n\nwhere lambda is the chosen scheme (quick, vanLeer, or cds).","category":"section"},{"location":"numerical_methods/#Conservative-Flux-Application","page":"Numerical Methods","title":"Conservative Flux Application","text":"The key feature of FVM is that the same flux value is added to one cell and subtracted from its neighbor:\n\nCell I-1:    r[I-1] -= F[I]    (flux leaves)\nCell I:      r[I]   += F[I]    (flux enters)\n\nThis ensures that momentum is exactly conserved — no momentum is created or destroyed at internal faces.\n\n        Face I\n          ↓\n    ┌─────┼─────┐\n    │     │     │\n    │ I-1 │  I  │\n    │     │     │\n    └─────┼─────┘\n          │\n     -F ←─┼─→ +F","category":"section"},{"location":"numerical_methods/#Code-Implementation","page":"Numerical Methods","title":"Code Implementation","text":"The FVM is implemented in src/Flow.jl. Here's how the math maps to code:","category":"section"},{"location":"numerical_methods/#Flux-Storage-(Optional)","page":"Numerical Methods","title":"Flux Storage (Optional)","text":"# Flow struct fields for explicit flux storage\nF_conv :: Array{T,D+2}  # Convective flux F_conv[I,j,i]\nF_diff :: Array{T,D+2}  # Diffusive flux F_diff[I,j,i]\nstore_fluxes :: Bool    # Enable FVM mode\n\nThe flux tensor has indices:\n\nI = spatial cell index (D-dimensional)\nj = face direction (1=x, 2=y, 3=z)\ni = momentum component","category":"section"},{"location":"numerical_methods/#Computing-Fluxes","page":"Numerical Methods","title":"Computing Fluxes","text":"# From compute_face_flux! in src/Flow.jl\nfor i ∈ 1:n, j ∈ 1:n\n    inv_Δxj = 1/Δx[j]\n    ν_Δxj = ν/Δx[j]\n\n    # Interior faces\n    @loop (\n        # Convective flux: (1/Δx) * u_face * ϕ(u)\n        F_conv[I,j,i] = inv_Δxj * ϕu(j, CI(I,i), u, ϕ(i,CI(I,j),u), λ);\n        # Diffusive flux: -(ν/Δx) * ∂u/∂x\n        F_diff[I,j,i] = -ν_Δxj * ∂(j, CI(I,i), u)\n    ) over I ∈ inside_u(N,j)\n\n    # Boundary fluxes (one-sided stencils)\n    compute_boundary_flux!(...)\nend\n\nKey functions:\n\nϕ(i,I,u) — Interpolates velocity component i to face location\nϕu(j,I,u,u_face,λ) — Computes upwind flux using scheme λ (quick, vanLeer, cds)\n∂(j,I,u) — Central difference u^I - u^I-delta_j","category":"section"},{"location":"numerical_methods/#Applying-Fluxes-Conservatively","page":"Numerical Methods","title":"Applying Fluxes Conservatively","text":"# From apply_fluxes! in src/Flow.jl\nfor i ∈ 1:n, j ∈ 1:n\n    F_total = F_conv[I,j,i] + F_diff[I,j,i]\n\n    # Lower boundary: only flux INTO domain\n    @loop r[I,i] += F_total over I ∈ slice(N,2,j,2)\n\n    # Interior: flux enters I, leaves I-δ (CONSERVATIVE!)\n    @loop r[I,i] += F_total over I ∈ inside_u(N,j)\n    @loop r[I-δ(j,I),i] -= F_total over I ∈ inside_u(N,j)\n\n    # Upper boundary: only flux OUT OF domain\n    @loop r[I-δ(j,I),i] -= F_total over I ∈ slice(N,N[j],j,2)\nend","category":"section"},{"location":"numerical_methods/#Enabling-FVM-Mode","page":"Numerical Methods","title":"Enabling FVM Mode","text":"To use explicit flux storage and verification:\n\n# Enable FVM with flux storage\nsim = Simulation((nx, ny), (Lx, Ly);\n                 store_fluxes = true,  # Enable FVM mode\n                 ν = 0.01)\n\n# Run simulation\nsim_step!(sim)\n\n# Access stored fluxes for analysis\nF_conv = sim.flow.F_conv  # Convective fluxes\nF_diff = sim.flow.F_diff  # Diffusive fluxes\n\n# Verify conservation (sum of internal fluxes = 0)\n\nWhen store_fluxes=false (default), the original method is used which computes fluxes on-the-fly without storing them.","category":"section"},{"location":"numerical_methods/#Boundary-Flux-Treatment","page":"Numerical Methods","title":"Boundary Flux Treatment","text":"At domain boundaries, fluxes are handled specially since there's no neighbor cell outside:\n\nBoundary Treatment Stencil\nLower (index 2) One-sided upwind ϕuL\nUpper (index N) One-sided upwind ϕuR\nPeriodic Wrap-around ϕuP\n\n# Lower boundary: use left-biased stencil\nF_conv[I,j,i] = ϕuL(j, I, u, u_face, λ)\n\n# Upper boundary: use right-biased stencil\nF_conv[I,j,i] = ϕuR(j, I, u, u_face, λ)\n\n# Periodic: wrap to opposite boundary\nF_conv[I,j,i] = ϕuP(j, I_wrapped, I, u, u_face, λ)","category":"section"},{"location":"numerical_methods/#Conservation-Verification","page":"Numerical Methods","title":"Conservation Verification","text":"The FVM ensures exact momentum conservation. For a closed system with no external forces:\n\nfracddt sum_I u_i^I cdot Delta V = sum_textboundaries F_i^boundary\n\nInterior fluxes cancel exactly because each internal face contributes:\n\n+F\nto cell I\n-F\nto cell I-delta\n\nThis property is crucial for accurate long-time simulations and proper vortex dynamics.","category":"section"},{"location":"numerical_methods/#Time-Integration","page":"Numerical Methods","title":"Time Integration","text":"BioFlows.jl uses a 2nd-order predictor-corrector (Heun's method) combined with pressure projection to ensure incompressibility. This provides 2nd-order temporal accuracy.","category":"section"},{"location":"numerical_methods/#Predictor-Step","page":"Numerical Methods","title":"Predictor Step","text":"First, compute a forward Euler prediction:\n\nmathbfu^* = mathbfu^n + Delta t left -(mathbfu^n cdot nabla)mathbfu^n + nu nabla^2 mathbfu^n + mathbfg right\n\nThen project onto divergence-free space:\n\nnabla^2 phi = nabla cdot mathbfu^*\n\nmathbfu = mathbfu^* - nabla phi","category":"section"},{"location":"numerical_methods/#Corrector-Step","page":"Numerical Methods","title":"Corrector Step","text":"Re-evaluate the right-hand side at the predicted velocity:\n\nmathbff = -(mathbfu cdot nabla)mathbfu + nu nabla^2 mathbfu + mathbfg\n\nAverage the predictor and corrector contributions (Heun's method):\n\nmathbfu^** = frac12left( mathbfu + mathbfu^n + Delta t  mathbff right)\n\nThis is equivalent to the trapezoidal rule:\n\nmathbfu^** = mathbfu^n + fracDelta t2 left( mathbff^n + mathbff right)\n\nFinally, project onto divergence-free space:\n\nnabla^2 psi = frac2Delta t nabla cdot mathbfu^**\n\nmathbfu^n+1 = mathbfu^** - fracDelta t2 nabla psi","category":"section"},{"location":"numerical_methods/#Summary-of-the-Algorithm","page":"Numerical Methods","title":"Summary of the Algorithm","text":"Algorithm: 2nd-order Predictor-Corrector with Pressure Projection\n─────────────────────────────────────────────────────────────────\nInput: uⁿ (divergence-free velocity at time tⁿ)\nOutput: uⁿ⁺¹ (divergence-free velocity at time tⁿ⁺¹)\n\n1. Save: u⁰ ← uⁿ\n\n2. PREDICTOR:\n   a. f ← RHS(u⁰)                    // Convection + diffusion\n   b. u* ← u⁰ + Δt·f                 // Forward Euler\n   c. Solve ∇²φ = ∇·u*               // Pressure Poisson\n   d. u' ← u* - ∇φ                   // Project to div-free\n\n3. CORRECTOR:\n   a. f' ← RHS(u')                   // Re-evaluate at predicted\n   b. u** ← u' + u⁰ + Δt·f'          // Accumulate\n   c. u** ← 0.5·u**                  // Average (Heun)\n   d. Solve ∇²ψ = (2/Δt)·∇·u**       // Pressure Poisson\n   e. uⁿ⁺¹ ← u** - (Δt/2)·∇ψ        // Final projection\n\n4. Compute Δt from CFL condition","category":"section"},{"location":"numerical_methods/#CFL-Condition","page":"Numerical Methods","title":"CFL Condition","text":"The time step is constrained by the CFL (Courant-Friedrichs-Lewy) condition:\n\nDelta t leq left( sum_d fracu_dDelta x_d + sum_d frac2nuDelta x_d^2 right)^-1\n\nwhere the first term is the convective constraint and the second is the diffusive constraint.","category":"section"},{"location":"numerical_methods/#Pressure-Solver","page":"Numerical Methods","title":"Pressure Solver","text":"The pressure Poisson equation is solved using a geometric multigrid method with:\n\nJacobi smoothing iterations\nFull-weighting restriction\nBilinear interpolation for prolongation\nV-cycle iteration until convergence\n\nThe multigrid solver operates on a hierarchy of progressively coarser grids, enabling efficient solution of the elliptic pressure equation.","category":"section"},{"location":"numerical_methods/#Immersed-Boundary-Method","page":"Numerical Methods","title":"Immersed Boundary Method","text":"BioFlows.jl implements the Boundary Data Immersion Method (BDIM) for handling complex geometries. Bodies are defined implicitly through signed distance functions (SDFs):\n\nphi(mathbfx t)  0 quad textinside body\n\nphi(mathbfx t) = 0 quad texton boundary\n\nphi(mathbfx t)  0 quad textin fluid\n\nThe SDF is used to:\n\nIdentify solid and fluid regions\nInterpolate boundary conditions\nCompute surface normals: mathbfn = nablaphi  nablaphi\nCalculate hydrodynamic forces on immersed bodies","category":"section"},{"location":"numerical_methods/#Boundary-Conditions","page":"Numerical Methods","title":"Boundary Conditions","text":"BioFlows.jl supports three types of boundary conditions for the domain boundaries (not to be confused with immersed body boundaries handled by BDIM).","category":"section"},{"location":"numerical_methods/#Domain-Boundary-Overview","page":"Numerical Methods","title":"Domain Boundary Overview","text":"                    Top boundary (j = nz)\n                    ─────────────────────\n                    │                   │\n                    │                   │\n    Inlet           │                   │    Outlet\n    (i = 1)         │     Domain        │    (i = nx)\n    inletBC         │                   │    outletBC\n                    │                   │\n                    │                   │\n                    ─────────────────────\n                    Bottom boundary (j = 1)","category":"section"},{"location":"numerical_methods/#1.-Inlet-Boundary-Condition-(inletBC)","page":"Numerical Methods","title":"1. Inlet Boundary Condition (inletBC)","text":"The inlet boundary (at x = 0) uses a Dirichlet condition where velocity is prescribed.","category":"section"},{"location":"numerical_methods/#Constant-Inlet","page":"Numerical Methods","title":"Constant Inlet","text":"For uniform inflow, specify a tuple:\n\ninletBC = (U, 0.0)  # u = U, v = 0 at inlet\n\nThis sets:\n\nu(0 y t) = U quad v(0 y t) = 0","category":"section"},{"location":"numerical_methods/#Spatially-Varying-Inlet","page":"Numerical Methods","title":"Spatially-Varying Inlet","text":"For non-uniform profiles (e.g., parabolic channel flow), use a function:\n\n# Parabolic profile: u(y) = U_max * (1 - (y-H)²/H²)\nH = Ly / 2  # channel half-height\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\n\nThe function signature is inletBC(i, x, t) where:\n\ni = velocity component (1 = x, 2 = y/z)\nx = position vector\nt = time","category":"section"},{"location":"numerical_methods/#Time-Varying-Inlet","page":"Numerical Methods","title":"Time-Varying Inlet","text":"For pulsatile or oscillating inflow:\n\n# Oscillating inlet: u(t) = U₀(1 + A·sin(ωt))\ninletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(2π*t)) : 0.0\n\nnote: Velocity Scale Required\nWhen using a function for inletBC, you must specify U (velocity scale) explicitly since it cannot be auto-computed.","category":"section"},{"location":"numerical_methods/#2.-Convective-Outlet-Boundary-Condition-(outletBC)","page":"Numerical Methods","title":"2. Convective Outlet Boundary Condition (outletBC)","text":"The outlet boundary (at x = L_x) is the most challenging because we don't know the flow state there in advance. Simple conditions like zero-gradient (partial upartial x = 0) cause spurious reflections — pressure waves bounce back into the domain and contaminate the solution.","category":"section"},{"location":"numerical_methods/#The-Convective-BC-Approach","page":"Numerical Methods","title":"The Convective BC Approach","text":"The convective (or advective) outlet condition assumes flow structures are transported out of the domain at a convection velocity U_c:\n\nfracpartial upartial t + U_c fracpartial upartial x = 0\n\nThis is a 1D wave equation that advects the local velocity pattern out of the domain.","category":"section"},{"location":"numerical_methods/#Discretization","page":"Numerical Methods","title":"Discretization","text":"Using first-order upwind differencing:\n\nu_i^n+1 = u_i^n - U_c Delta t fracu_i^n - u_i-1^nDelta x\n\nIn BioFlows, U_c is taken as the mean inlet velocity to ensure mass conservation.","category":"section"},{"location":"numerical_methods/#Mass-Conservation-Correction","page":"Numerical Methods","title":"Mass Conservation Correction","text":"After applying the convective BC, a correction ensures global mass conservation:\n\noint u  dA = 0 quad text(for incompressible flow)\n\nThe outlet velocity is adjusted so that mass flux out equals mass flux in:\n\n# From src/util.jl - exitBC!\nU = mean(u_inlet)           # Average inlet flux\nu_outlet = u_outlet - Δt * U * ∂u/∂x  # Convective update\ncorrection = mean(u_outlet) - U       # Mass imbalance\nu_outlet = u_outlet - correction      # Enforce conservation","category":"section"},{"location":"numerical_methods/#Why-Convective-BC-Works","page":"Numerical Methods","title":"Why Convective BC Works","text":"Without Convective BC:              With Convective BC:\n\n    ────────────────────┐              ────────────────────→\n    Vortex → → → ↩ ↩ ↩  │              Vortex → → → → → →\n    ────────────────────┘              ────────────────────→\n                ↑                                  ↑\n          Reflection!                      Passes through\n\nThe convective BC allows vortices, wakes, and other flow structures to exit smoothly without generating artificial reflections.","category":"section"},{"location":"numerical_methods/#Usage","page":"Numerical Methods","title":"Usage","text":"sim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (1.0, 0.0),\n                 outletBC = true)      # Enable convective outlet","category":"section"},{"location":"numerical_methods/#3.-Periodic-Boundary-Condition-(perdir)","page":"Numerical Methods","title":"3. Periodic Boundary Condition (perdir)","text":"Periodic boundaries make the domain wrap around — flow exiting one side re-enters from the opposite side.\n\nu(x 0 t) = u(x L_y t) quad v(x 0 t) = v(x L_y t)","category":"section"},{"location":"numerical_methods/#When-to-Use-Periodic-BC","page":"Numerical Methods","title":"When to Use Periodic BC","text":"Scenario Direction Example\nInfinite span z (spanwise) Flow past cylinder\nChannel flow x (streamwise) Fully-developed pipe flow\nHomogeneous turbulence All Isotropic turbulence box","category":"section"},{"location":"numerical_methods/#Usage-2","page":"Numerical Methods","title":"Usage","text":"# Periodic in z-direction (direction 2)\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (1.0, 0.0),\n                 perdir = (2,))\n\n# Periodic in both y and z (3D)\nsim = Simulation((nx, ny, nz), (Lx, Ly, Lz);\n                 inletBC = (1.0, 0.0, 0.0),\n                 perdir = (2, 3))","category":"section"},{"location":"numerical_methods/#4.-Default-(No-Flux)-Boundaries","page":"Numerical Methods","title":"4. Default (No-Flux) Boundaries","text":"Boundaries not explicitly set use a zero normal gradient (Neumann) condition:\n\nfracpartial upartial n = 0\n\nThis is appropriate for:\n\nSlip walls (free-slip, no penetration)\nSymmetry planes\nFar-field boundaries (approximate)","category":"section"},{"location":"numerical_methods/#Boundary-Condition-Summary","page":"Numerical Methods","title":"Boundary Condition Summary","text":"Parameter Condition Mathematical Form Use Case\ninletBC Dirichlet u = u_prescribed Inflow boundaries\noutletBC=true Convective partial_t u + U partial_x u = 0 Outflow (prevents reflections)\nperdir=(d,) Periodic u(0) = u(L) Infinite/repeating domains\n(default) Neumann partial_n u = 0 Slip walls, symmetry","category":"section"},{"location":"numerical_methods/#Common-Configurations","page":"Numerical Methods","title":"Common Configurations","text":"","category":"section"},{"location":"numerical_methods/#External-Flow-(Wake-Problems)","page":"Numerical Methods","title":"External Flow (Wake Problems)","text":"# Flow past cylinder: inlet + convective outlet + periodic spanwise\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 outletBC = true,\n                 perdir = (2,),\n                 body = AutoBody(sdf))","category":"section"},{"location":"numerical_methods/#Channel-Flow","page":"Numerical Methods","title":"Channel Flow","text":"# Fully-developed channel: periodic streamwise + no-slip walls\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 perdir = (1,))  # Periodic in x (streamwise)","category":"section"},{"location":"numerical_methods/#Closed-Cavity","page":"Numerical Methods","title":"Closed Cavity","text":"# Lid-driven cavity: no outlet, no periodic\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0))  # Top wall moves at U","category":"section"},{"location":"numerical_methods/#References","page":"Numerical Methods","title":"References","text":"Harlow, F.H. and Welch, J.E. (1965). \"Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface.\" Physics of Fluids, 8(12), 2182-2189.\nWeymouth, G.D. and Yue, D.K.P. (2011). \"Boundary data immersion method for Cartesian-grid simulations of fluid-body interaction problems.\" Journal of Computational Physics, 230(16), 6233-6247.\nOrlanski, I. (1976). \"A simple boundary condition for unbounded hyperbolic flows.\" Journal of Computational Physics, 21(3), 251-269.\nLeonard, B.P. (1979). \"A stable and accurate convective modelling procedure based on quadratic upstream interpolation.\" Computer Methods in Applied Mechanics and Engineering, 19(1), 59-98. (QUICK scheme)\nVan Leer, B. (1979). \"Towards the ultimate conservative difference scheme. V. A second-order sequel to Godunov's method.\" Journal of Computational Physics, 32(1), 101-136. (Van Leer limiter)\nVersteeg, H.K. and Malalasekera, W. (2007). An Introduction to Computational Fluid Dynamics: The Finite Volume Method. Pearson Education.","category":"section"}]
}
