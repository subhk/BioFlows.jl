var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides a quick reference to all exported functions and types. See the linked pages for detailed documentation.","category":"section"},{"location":"api/#Simulation-Types","page":"API Reference","title":"Simulation Types","text":"See Core Types for details.\n\nType Description\nSimulation Main simulation container\nAMRSimulation Simulation with adaptive mesh refinement\nAMRConfig Configuration for AMR\nFlow Fluid field storage (velocity, pressure)\nAutoBody Implicit geometry via signed distance function","category":"section"},{"location":"api/#Simulation-Control","page":"API Reference","title":"Simulation Control","text":"See Core Types for details.\n\nFunction Description\nsim_step!(sim) Advance one time step\nsim_step!(sim, t_end) Advance to target time\nsim_time(sim) Get dimensionless time (t*U/L)\nmeasure!(sim) Update body coefficients\nperturb!(sim) Add velocity perturbations\nsim_info(sim) Print simulation status","category":"section"},{"location":"api/#Finite-Volume-Method-(FVM)","page":"API Reference","title":"Finite Volume Method (FVM)","text":"See Numerical Methods for details.\n\nFunction Description\ncompute_face_flux!(F_conv, F_diff, u, λ; ν, Δx, perdir) Compute fluxes at cell faces\napply_fluxes!(r, F_conv, F_diff) Apply fluxes conservatively to RHS\nconv_diff_fvm!(r, u, F_conv, F_diff, λ; ν, Δx, perdir) FVM convection-diffusion\n\nEnable FVM mode by setting store_fluxes=true in Simulation or Flow constructor.","category":"section"},{"location":"api/#AMR-Functions","page":"API Reference","title":"AMR Functions","text":"See Adaptive Mesh Refinement for details.\n\nFunction Description\namr_regrid!(sim) Force regridding\nset_amr_active!(sim, bool) Enable/disable AMR\nget_refinement_indicator(sim) Get current indicator field\nnum_refined_cells(grid) Count refined cells\nrefinement_level(grid, i, j) Query cell refinement level\namr_info(sim) Print AMR status and statistics\ncheck_divergence(sim) Check velocity divergence on all levels\namr_cfl(flow, cp) Compute CFL considering refined patches\nsynchronize_base_and_patches!(flow, cp) Sync data between base and patches","category":"section"},{"location":"api/#Fluid-Structure-Interaction-(FSI)","page":"API Reference","title":"Fluid-Structure Interaction (FSI)","text":"See Numerical Methods for details.","category":"section"},{"location":"api/#FSI-Types","page":"API Reference","title":"FSI Types","text":"Type Description\nBeamMaterial Material properties (ρ, E, ν)\nBeamGeometry Beam geometry (L, n, thickness, width)\nEulerBernoulliBeam Hermite FEM beam solver\nBeamBoundaryCondition Boundary condition enum","category":"section"},{"location":"api/#Boundary-Conditions","page":"API Reference","title":"Boundary Conditions","text":"Constant Description\nCLAMPED Fixed position and slope (w=0, θ=0)\nFREE No constraints\nPINNED Fixed position only (w=0)\nPRESCRIBED Time-varying position","category":"section"},{"location":"api/#Beam-Functions","page":"API Reference","title":"Beam Functions","text":"Function Description\nstep!(beam, dt) Advance beam by one time step\nreset!(beam) Reset beam to zero state\nkinetic_energy(beam) Compute kinetic energy\npotential_energy(beam) Compute potential energy\ntotal_energy(beam) Compute total mechanical energy\nget_curvature(beam) Get curvature field κ(s)\nget_bending_moment(beam) Get bending moment M(s)\nget_displacement(beam) Get displacement field w(s)\nget_velocity(beam) Get velocity field ∂w/∂t\nget_rotation(beam) Get rotation field θ(s)\nset_active_forcing!(beam, f, t) Apply active muscle forcing","category":"section"},{"location":"api/#Forcing-Functions","page":"API Reference","title":"Forcing Functions","text":"Function Description\ntraveling_wave_forcing(; kwargs...) Create traveling wave muscle activation\nheave_pitch_forcing(; kwargs...) Create heave/pitch leading-edge motion\nfish_thickness_profile(L, h_max) NACA-like fish body thickness","category":"section"},{"location":"api/#Beam-State-Output","page":"API Reference","title":"Beam State Output","text":"Type/Function Description\nBeamStateWriter(filename; interval) Writer for single beam state to JLD2\nBeamStateWriterGroup(prefix, n; interval) Writers for multiple beams\nfile_save!(writer, beam, t) Record beam state if interval elapsed\nclose!(writer, beam) Finalize and write data to file","category":"section"},{"location":"api/#AMR-for-Flexible-Bodies","page":"API Reference","title":"AMR for Flexible Bodies","text":"Type/Function Description\nFlexibleBodySDF(beam, x, z) Time-dependent SDF from beam state\nBeamAMRConfig(; kwargs...) Beam-specific AMR configuration\nFlexibleBodyAMRConfig(; kwargs...) AMR configuration for flexible bodies (returns AMRConfig)\nBeamAMRTracker(beam_sdf) Motion tracker for regrid decisions\ncreate_beam_body(beam, x, z) Create AutoBody from beam\nupdate!(beam_sdf) Update SDF with current beam state\nshould_regrid(tracker, step) Check if regrid needed\nregrid_for_beam!(sim, sdf, tracker, step, config) Perform beam-aware regridding\ncompute_beam_refinement_indicator(flow, sdf) Compute beam proximity indicator\ncompute_beam_combined_indicator(flow, sdf) Combined indicator with flow features\nget_beam_bounding_box(sdf) Get beam bounding box","category":"section"},{"location":"api/#BeamAMRSimulation","page":"API Reference","title":"BeamAMRSimulation","text":"Type/Function Description\nBeamAMRSimulation(dims, L, beam, x, z; config, kwargs...) Integrated beam-fluid AMR simulation\nset_forcing!(sim, f) Set active forcing function f(s, t)\nsim_step!(sim::BeamAMRSimulation) Advance coupled beam-fluid step\nbeam_info(sim) Print beam and AMR status\nget_flow(sim) Get underlying Flow struct\nget_beam(sim) Get EulerBernoulliBeam\nperform_beam_regrid!(sim) Force regridding based on beam position\nswimming_fish_simulation(; kwargs...) Create ready-to-run fish simulation","category":"section"},{"location":"api/#Force-Diagnostics","page":"API Reference","title":"Force Diagnostics","text":"See Diagnostics for details.\n\nFunction Description\npressure_force(sim) Pressure force vector\nviscous_force(sim) Viscous force vector\ntotal_force(sim) Total force vector\nforce_components(sim) All forces + coefficients\nforce_coefficients(sim) Dimensionless coefficients\nrecord_force!(history, sim) Append to force history","category":"section"},{"location":"api/#Vorticity-Functions","page":"API Reference","title":"Vorticity Functions","text":"See Diagnostics for details.\n\nFunction Description\nvorticity_component(sim, i) i-th vorticity component\nvorticity_magnitude(sim) Vorticity magnitude field\ncell_center_velocity(sim) Interpolated velocity at cell centers\ncell_center_vorticity(sim) Interpolated vorticity at cell centers\ncell_center_pressure(sim) Pressure at cell centers","category":"section"},{"location":"api/#Output","page":"API Reference","title":"Output","text":"Function Description\nCenterFieldWriter(file; interval) Create JLD2 snapshot writer\nForceWriter(file; interval) Create JLD2 force coefficient writer\nfile_save!(writer, sim) Save snapshot if interval elapsed","category":"section"},{"location":"api/#Exported-Symbols","page":"API Reference","title":"Exported Symbols","text":"","category":"section"},{"location":"api/#From-BioFlows.jl","page":"API Reference","title":"From BioFlows.jl","text":"# Simulation\nSimulation, AbstractSimulation, sim_step!, sim_time, measure!, sim_info, perturb!\n\n# AMR\nAMRSimulation, AMRConfig, amr_regrid!, set_amr_active!, get_refinement_indicator\n\n# Flow\nFlow, mom_step!, quick, cds\ncompute_face_flux!, apply_fluxes!, conv_diff_fvm!\n\n# Pressure\nAbstractPoisson, Poisson, MultiLevelPoisson, solver!, mult!\n\n# Bodies\nAbstractBody, AutoBody, measure_sdf!, sdf, measure\n\n# Diagnostics\npressure_force, viscous_force, total_force, force_components, force_coefficients, record_force!\nvorticity_component, vorticity_magnitude, cell_center_velocity, cell_center_vorticity, cell_center_pressure\ncurl, ω, ω_mag\ncompute_diagnostics, summarize_force_history\n\n# Output\nCenterFieldWriter, ForceWriter, file_save!\n\n# AMR Types\nStaggeredGrid, SolutionState, RefinedGrid, GridType, TwoDimensional, ThreeDimensional\nis_2d, is_3d, num_refined_cells, refinement_level, domain_size, cell_volume\nFlowToGridAdapter, flow_to_staggered_grid, flow_to_solution_state, create_refined_grid\ncompute_body_refinement_indicator, compute_velocity_gradient_indicator\ncompute_vorticity_indicator, compute_combined_indicator\nmark_cells_for_refinement, apply_buffer_zone!\n\n# AMR Composite Solver\nCompositePoisson, PatchPoisson, RefinedVelocityField, RefinedVelocityPatch\nadd_patch!, remove_patch!, get_patch, clear_patches!, has_patches, num_patches\ncreate_patches!, update_patches!, ensure_proper_nesting!\namr_project!, amr_mom_step!, check_amr_divergence, regrid_amr!\namr_cfl, synchronize_base_and_patches!, interpolate_velocity_to_patches!\namr_info, check_divergence\n\n# Utilities\nL₂, BC!, @inside, inside, δ, apply!, loc, @log, set_backend, backend\n\n# Statistics\nMeanFlow, update!, uu!, uu\n\n# FSI (Fluid-Structure Interaction)\nBeamMaterial, BeamGeometry, EulerBernoulliBeam, BeamBoundaryCondition\nCLAMPED, FREE, PINNED, PRESCRIBED\nstep!, reset!, kinetic_energy, potential_energy, total_energy\nget_curvature, get_bending_moment, get_displacement, get_velocity, get_rotation\nset_active_forcing!, traveling_wave_forcing, heave_pitch_forcing, fish_thickness_profile","category":"section"},{"location":"amr/#Adaptive-Mesh-Refinement","page":"Adaptive Mesh Refinement","title":"Adaptive Mesh Refinement","text":"BioFlows includes an Adaptive Mesh Refinement (AMR) system that automatically refines the computational grid near immersed bodies and regions of high flow gradients.","category":"section"},{"location":"amr/#AMRSimulation","page":"Adaptive Mesh Refinement","title":"AMRSimulation","text":"The AMRSimulation type wraps a standard Simulation and adds AMR capability.","category":"section"},{"location":"amr/#Basic-Usage","page":"Adaptive Mesh Refinement","title":"Basic Usage","text":"using BioFlows\n\n# Define geometry\nradius = 8\ncenter = 64\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Configure AMR\nconfig = AMRConfig(\n    max_level = 2,                     # Max refinement (2x, 4x resolution)\n    body_distance_threshold = 3.0,     # Refine within 3 cells of body\n    velocity_gradient_threshold = 1.0,\n    vorticity_threshold = 1.0,\n    regrid_interval = 10,              # Check regridding every 10 steps\n    buffer_size = 1                    # Buffer cells around refined regions\n)\n\n# Create AMR simulation\nsim = AMRSimulation((128, 128), (128.0, 128.0);\n                    inletBC = (1.0, 0.0),\n                    ν = 2radius / 200,\n                    body = AutoBody(sdf),\n                    L_char = 2radius,\n                    amr_config = config)\n\n# Time integration (regridding happens automatically)\nfor step in 1:1000\n    sim_step!(sim; remeasure=true)\nend\n\n# Check refinement\nprintln(\"Refined cells: \", num_refined_cells(sim.refined_grid))","category":"section"},{"location":"amr/#AMRConfig-Parameters","page":"Adaptive Mesh Refinement","title":"AMRConfig Parameters","text":"Parameter Default Description\nmax_level 2 Maximum refinement level (1=2x, 2=4x, etc.)\nbody_distance_threshold 3.0 Refine within this distance from body (cells)\nvelocity_gradient_threshold 1.0 Threshold for velocity gradient indicator\nvorticity_threshold 1.0 Threshold for vorticity-based refinement\nregrid_interval 10 Steps between regridding checks\nbuffer_size 1 Buffer cells around refined regions\nbody_weight 0.5 Weight for body proximity in combined indicator\ngradient_weight 0.3 Weight for velocity gradient\nvorticity_weight 0.2 Weight for vorticity","category":"section"},{"location":"amr/#Refinement-Indicators","page":"Adaptive Mesh Refinement","title":"Refinement Indicators","text":"The AMR system uses multiple indicators to decide where to refine:","category":"section"},{"location":"amr/#Body-Distance-Indicator","page":"Adaptive Mesh Refinement","title":"Body Distance Indicator","text":"Refines cells near the immersed body surface:\n\nindicator = compute_body_refinement_indicator(flow, body;\n    threshold=config.body_distance_threshold, t=t)","category":"section"},{"location":"amr/#Velocity-Gradient-Indicator","page":"Adaptive Mesh Refinement","title":"Velocity Gradient Indicator","text":"Refines regions of high velocity gradients:\n\nindicator = compute_velocity_gradient_indicator(flow;\n    threshold=config.velocity_gradient_threshold)","category":"section"},{"location":"amr/#Vorticity-Indicator","page":"Adaptive Mesh Refinement","title":"Vorticity Indicator","text":"Refines regions of high vorticity:\n\nindicator = compute_vorticity_indicator(flow;\n    threshold=config.vorticity_threshold)","category":"section"},{"location":"amr/#Combined-Indicator","page":"Adaptive Mesh Refinement","title":"Combined Indicator","text":"Combines all indicators with configurable weights:\n\nindicator = compute_combined_indicator(flow, body;\n    body_threshold=3.0,\n    gradient_threshold=1.0,\n    vorticity_threshold=1.0,\n    t=0.0,\n    body_weight=0.5,\n    gradient_weight=0.3,\n    vorticity_weight=0.2\n)","category":"section"},{"location":"amr/#AMR-Control","page":"Adaptive Mesh Refinement","title":"AMR Control","text":"","category":"section"},{"location":"amr/#Enable/Disable-AMR","page":"Adaptive Mesh Refinement","title":"Enable/Disable AMR","text":"# Disable regridding (keep current mesh)\nset_amr_active!(sim, false)\n\n# Re-enable\nset_amr_active!(sim, true)","category":"section"},{"location":"amr/#Force-Regridding","page":"Adaptive Mesh Refinement","title":"Force Regridding","text":"amr_regrid!(sim)","category":"section"},{"location":"amr/#Query-Refinement","page":"Adaptive Mesh Refinement","title":"Query Refinement","text":"# Number of refined cells\nn = num_refined_cells(sim.refined_grid)\n\n# Refinement level at specific cell (0 = base, 1+ = refined)\nlevel = refinement_level(sim.refined_grid, i, j)\n\n# Get current indicator field (for visualization)\nindicator = get_refinement_indicator(sim)","category":"section"},{"location":"amr/#Grid-Types","page":"Adaptive Mesh Refinement","title":"Grid Types","text":"","category":"section"},{"location":"amr/#StaggeredGrid","page":"Adaptive Mesh Refinement","title":"StaggeredGrid","text":"The base grid type using MAC (Marker-And-Cell) layout:\n\nVelocities at face centers\nPressure at cell centers\nSupports 2D (XZ plane) and 3D","category":"section"},{"location":"amr/#RefinedGrid","page":"Adaptive Mesh Refinement","title":"RefinedGrid","text":"Container for AMR data:\n\nTracks:\n\nBase (coarse) grid\nRefined cell locations and levels\nLocal refined sub-grids\nInterpolation weights","category":"section"},{"location":"amr/#Performance-Considerations","page":"Adaptive Mesh Refinement","title":"Performance Considerations","text":"Regrid Interval: Larger intervals reduce overhead but may miss features\nBuffer Size: Prevents refinement boundaries from affecting solution\nMax Level: Higher levels increase accuracy but add cost\nIndicator Weights: Tune based on flow physics","category":"section"},{"location":"amr/#Example:-Wake-Refinement","page":"Adaptive Mesh Refinement","title":"Example: Wake Refinement","text":"# Emphasize wake region (high vorticity) over body proximity\nconfig = AMRConfig(\n    max_level = 3,\n    body_weight = 0.2,        # Less emphasis on body\n    gradient_weight = 0.3,\n    vorticity_weight = 0.5,   # More emphasis on wake\n    regrid_interval = 20\n)","category":"section"},{"location":"amr/#Composite-Solver-(Advanced)","page":"Adaptive Mesh Refinement","title":"Composite Solver (Advanced)","text":"For advanced users, BioFlows exposes the internal composite solver types used for AMR pressure projection.","category":"section"},{"location":"amr/#CompositePoisson","page":"Adaptive Mesh Refinement","title":"CompositePoisson","text":"The composite Poisson solver combines a base multigrid solver with refined patches:\n\n# CompositePoisson manages:\n# - Base grid: MultiLevelPoisson for coarse solution\n# - Patches: PatchPoisson solvers for refined regions\n# - Velocity: RefinedVelocityField for patch velocities","category":"section"},{"location":"amr/#Patch-Types","page":"Adaptive Mesh Refinement","title":"Patch Types","text":"Type Description\nPatchPoisson Local Poisson solver for a refined patch\nRefinedVelocityPatch Velocity storage at refined resolution\nRefinedVelocityField Collection of velocity patches","category":"section"},{"location":"amr/#Patch-Operations","page":"Adaptive Mesh Refinement","title":"Patch Operations","text":"# Add/remove patches\nadd_patch!(field, anchor, patch)\nremove_patch!(field, anchor)\nget_patch(field, anchor)\nclear_patches!(field)\n\n# Query patches\nhas_patches(cp)\nnum_patches(cp)","category":"section"},{"location":"amr/#AMR-Projection","page":"Adaptive Mesh Refinement","title":"AMR Projection","text":"The amr_project! function performs divergence-free projection on all levels:\n\n# Full AMR projection workflow:\n# 1. Set divergence on base grid\n# 2. Set divergence on refined patches\n# 3. Interpolate velocity to patches\n# 4. Solve composite Poisson system\n# 5. Correct velocities at all levels\n# 6. Enforce interface consistency\n\namr_project!(flow, cp)","category":"section"},{"location":"amr/#Utility-Functions","page":"Adaptive Mesh Refinement","title":"Utility Functions","text":"Function Description\namr_cfl(flow, cp) CFL considering refined patches\ncheck_amr_divergence(flow, cp) Divergence at all levels\nsynchronize_base_and_patches!(flow, cp) Sync after regridding","category":"section"},{"location":"amr/#Moving-Bodies-with-AMR","page":"Adaptive Mesh Refinement","title":"Moving Bodies with AMR","text":"BioFlows supports AMR for both rigid and flexible moving bodies. The mesh automatically tracks body motion and regrids when necessary.","category":"section"},{"location":"amr/#Body-Types","page":"Adaptive Mesh Refinement","title":"Body Types","text":"Type Description Example\nRigid Shape unchanged, position/orientation varies Oscillating cylinder, rotating ellipse\nFlexible Shape deforms over time Swimming fish, flapping wing","category":"section"},{"location":"amr/#Convenience-Configurations","page":"Adaptive Mesh Refinement","title":"Convenience Configurations","text":"BioFlows provides pre-configured settings for common use cases:","category":"section"},{"location":"amr/#FlexibleBodyAMRConfig","page":"Adaptive Mesh Refinement","title":"FlexibleBodyAMRConfig","text":"Optimized for deforming bodies like swimming fish:\n\nconfig = FlexibleBodyAMRConfig(\n    max_level = 2,                    # 4x refinement\n    body_distance_threshold = 4.0,    # Larger region for moving bodies\n    indicator_change_threshold = 0.05, # 5% change triggers regrid\n    min_regrid_interval = 2           # Allow frequent regridding\n)\n\nDefault settings:\n\nflexible_body = true - Enable motion-adaptive regridding\nindicator_change_threshold = 0.05 - 5% cell change triggers regrid\nmin_regrid_interval = 2 - Allow regridding every 2 steps\nregrid_interval = 5 - Check regridding at least every 5 steps\nbody_distance_threshold = 4.0 - Larger refinement region\nbody_weight = 0.6 - Higher weight for body proximity","category":"section"},{"location":"amr/#RigidBodyAMRConfig","page":"Adaptive Mesh Refinement","title":"RigidBodyAMRConfig","text":"Optimized for moving rigid bodies:\n\nconfig = RigidBodyAMRConfig(\n    max_level = 2,\n    body_distance_threshold = 3.0,\n    indicator_change_threshold = 0.08,  # Less sensitive (8%)\n    min_regrid_interval = 3             # Less frequent\n)\n\nDefault settings:\n\nflexible_body = true - Enable motion-adaptive regridding\nindicator_change_threshold = 0.08 - 8% cell change triggers regrid\nmin_regrid_interval = 3 - Allow regridding every 3 steps\nregrid_interval = 8 - Check regridding every 8 steps\nbody_distance_threshold = 3.0 - Standard refinement region\nbody_weight = 0.5 - Standard weight for body proximity","category":"section"},{"location":"amr/#Motion-Detection","page":"Adaptive Mesh Refinement","title":"Motion Detection","text":"The AMR system automatically detects body motion by comparing refinement indicators between time steps:\n\n# Get motion statistics\nstats = get_body_motion_stats(sim)\nprintln(\"Indicator stored: \", stats.indicator_stored)\nprintln(\"Patches: \", stats.n_patches)\nprintln(\"Steps since regrid: \", stats.steps_since_regrid)\n\nWhen the indicator change exceeds indicator_change_threshold, regridding is triggered (subject to min_regrid_interval).","category":"section"},{"location":"amr/#Helper-Functions","page":"Adaptive Mesh Refinement","title":"Helper Functions","text":"# Force immediate regridding\nforce_regrid!(sim)\n\n# Reset body tracking (after sudden position changes)\nreset_body_tracking!(sim)\n\n# Get AMR status\ninfo = amr_info(sim)\nprintln(\"Active: \", info.active)\nprintln(\"Flexible body: \", info.flexible_body)\nprintln(\"Refined cells: \", info.refined_cells)\nprintln(\"Patches: \", info.num_patches)","category":"section"},{"location":"amr/#Swimming-Fish-with-AMR","page":"Adaptive Mesh Refinement","title":"Swimming Fish with AMR","text":"BioFlows includes comprehensive support for flexible swimming bodies.","category":"section"},{"location":"amr/#Single-Fish","page":"Adaptive Mesh Refinement","title":"Single Fish","text":"using BioFlows\ninclude(\"examples/swimming_fish.jl\")\n\n# Create AMR-enabled swimming fish simulation\nsim = swimming_fish_amr_sim(\n    nx = 256, nz = 128,          # Grid dimensions\n    fish_length = 0.2,           # Fish body length\n    amplitude = 0.1,             # Tail amplitude (relative to length)\n    frequency = 1.0,             # Oscillation frequency (Hz)\n    amplitude_envelope = :carangiform,  # Swimming mode\n    amr_max_level = 2            # Refinement level\n)\n\n# Run simulation - patches follow the fish automatically\nfor step in 1:1000\n    sim_step!(sim; remeasure=true)\n\n    if step % 100 == 0\n        info = amr_info(sim; verbose=false)\n        println(\"Step $step: patches=$(info.num_patches)\")\n    end\nend","category":"section"},{"location":"amr/#Swimming-Modes","page":"Adaptive Mesh Refinement","title":"Swimming Modes","text":"BioFlows supports multiple swimming modes with different amplitude envelopes:\n\nMode Envelope Description\n:carangiform A(s) = A_tail * (s/L)² Tail-dominated (tuna, mackerel)\n:anguilliform A(s) = A_head + (A_tail - A_head) * s/L Whole-body (eel, lamprey)\n:subcarangiform A(s) = A_tail * (s/L)^1.5 Intermediate (trout, carp)\n:uniform A(s) = A_uniform Constant amplitude\n\n# Anguilliform swimming (eel-like, whole-body motion)\nsim = swimming_fish_amr_sim(\n    amplitude_envelope = :anguilliform,\n    head_amplitude = 0.05,    # Non-zero head motion\n    amplitude = 0.12,         # Tail amplitude\n    wavelength = 0.8          # Shorter wavelength\n)","category":"section"},{"location":"amr/#Leading-Edge-Motion","page":"Adaptive Mesh Refinement","title":"Leading Edge Motion","text":"Fish can have additional heave (vertical oscillation) and pitch (angular oscillation) at the leading edge:\n\n# Fish with combined heave + pitch motion\nsim = swimming_fish_amr_sim(\n    heave_amplitude = 0.05,   # Vertical oscillation at head\n    heave_phase = 0.0,        # In phase with body wave\n    pitch_amplitude = 0.15,   # Angular oscillation (radians)\n    pitch_phase = π/2         # 90° phase lead for optimal thrust\n)\n\nThe body centerline follows:\n\ny(x,t) = y_head(t) + A(x) * sin(k*x - ω*t + φ) + pitch_contribution(x,t)\n\nwhere:\n\ny_head(t) = heave_amplitude * sin(ω*t + heave_phase) - leading edge heave\nA(x) = amplitude envelope (varies based on swimming mode)\nk = 2π/λ = wave number\nω = 2π*f = angular frequency","category":"section"},{"location":"amr/#Fish-School-with-AMR","page":"Adaptive Mesh Refinement","title":"Fish School with AMR","text":"Simulate multiple swimming fish with individual phase offsets:\n\nusing BioFlows\ninclude(\"examples/swimming_fish.jl\")\n\n# Create fish school with AMR\nsim, fish_configs = fish_school_amr_sim(\n    nx = 512, nz = 256,\n    Lx = 2.0, Lz = 1.0,\n    n_fish = 3,                    # Number of fish\n    formation = :staggered,        # Formation type\n    phase_offset = π/3,            # Phase difference between fish\n    fish_length = 0.15,\n    amplitude = 0.1,\n    amr_max_level = 2\n)\n\n# Run simulation\nfor step in 1:500\n    sim_step!(sim; remeasure=true)\nend\n\n# Check AMR status\namr_info(sim)","category":"section"},{"location":"amr/#School-Formations","page":"Adaptive Mesh Refinement","title":"School Formations","text":"Formation Description\n:staggered Diagonal arrangement (default)\n:inline Tandem (one behind another)\n:side_by_side Lateral arrangement\n:diamond Diamond pattern (4+ fish)\n:custom User-defined positions\n\n# Diamond formation with 4 fish\nsim, configs = fish_school_amr_sim(\n    n_fish = 4,\n    formation = :diamond,\n    spacing = 0.15          # Lateral spacing\n)","category":"section"},{"location":"amr/#Custom-Fish-Positions","page":"Adaptive Mesh Refinement","title":"Custom Fish Positions","text":"# Define custom positions\ncustom = [\n    FishConfig(0.2, 0.4, 0.0),      # x_pos, z_pos, phase\n    FishConfig(0.2, 0.6, π/4),\n    FishConfig(0.4, 0.5, π/2),\n]\n\nsim, _ = fish_school_amr_sim(\n    custom_positions = custom,\n    formation = :custom\n)","category":"section"},{"location":"amr/#Phase-Synchronization","page":"Adaptive Mesh Refinement","title":"Phase Synchronization","text":"Control phase relationships between fish:\n\n# Synchronized school (all same phase)\nsim, _ = fish_school_amr_sim(\n    n_fish = 3,\n    phase_offset = 0.0,        # No phase difference\n    formation = :side_by_side\n)\n\n# Wave-like phase progression\nsim, _ = fish_school_amr_sim(\n    n_fish = 5,\n    phase_offset = π/4,        # Progressive phase delay\n    formation = :inline\n)","category":"section"},{"location":"amr/#Oscillating-Cylinder-with-AMR","page":"Adaptive Mesh Refinement","title":"Oscillating Cylinder with AMR","text":"For rigid body motion like oscillating cylinders:\n\nusing BioFlows\ninclude(\"examples/oscillating_cylinder.jl\")\n\n# Create oscillating cylinder with AMR\nsim = oscillating_cylinder_amr_sim(\n    n = 128, m = 64,\n    St = 0.2,              # Strouhal number\n    amplitude = 0.3,       # Oscillation amplitude (relative to diameter)\n    max_level = 2\n)\n\n# Run simulation\nfor step in 1:500\n    sim_step!(sim; remeasure=true)\nend\n\namr_info(sim)","category":"section"},{"location":"amr/#Other-Rigid-Body-Examples","page":"Adaptive Mesh Refinement","title":"Other Rigid Body Examples","text":"# Rotating cylinder\nsim = rotating_cylinder_amr_sim(\n    n = 64, m = 64,\n    ω = 0.5,               # Angular velocity (rad/time)\n    max_level = 2\n)\n\n# Orbiting cylinder (large motion)\nsim = orbiting_cylinder_amr_sim(\n    n = 96, m = 96,\n    orbit_radius = 12,     # Orbit radius (grid cells)\n    orbit_period = 80,     # Orbit period (time units)\n    max_level = 2\n)","category":"section"},{"location":"amr/#Best-Practices-for-Moving-Bodies","page":"Adaptive Mesh Refinement","title":"Best Practices for Moving Bodies","text":"","category":"section"},{"location":"amr/#1.-Always-Use-remeasuretrue","page":"Adaptive Mesh Refinement","title":"1. Always Use remeasure=true","text":"# Moving bodies require remeasuring the SDF each step\nsim_step!(sim; remeasure=true)","category":"section"},{"location":"amr/#2.-Choose-Appropriate-Configuration","page":"Adaptive Mesh Refinement","title":"2. Choose Appropriate Configuration","text":"# Flexible body (swimming fish, flapping wings)\nconfig = FlexibleBodyAMRConfig(max_level=2)\n\n# Rigid body (oscillating cylinder, rotating ellipse)\nconfig = RigidBodyAMRConfig(max_level=2)","category":"section"},{"location":"amr/#3.-Tune-Indicator-Threshold","page":"Adaptive Mesh Refinement","title":"3. Tune Indicator Threshold","text":"For fast-moving bodies, use lower thresholds:\n\nconfig = FlexibleBodyAMRConfig(\n    indicator_change_threshold = 0.03,  # More sensitive\n    min_regrid_interval = 1             # Allow every step\n)\n\nFor slower motion, higher thresholds reduce overhead:\n\nconfig = RigidBodyAMRConfig(\n    indicator_change_threshold = 0.15,  # Less sensitive\n    min_regrid_interval = 5             # Less frequent\n)","category":"section"},{"location":"amr/#4.-Monitor-Regridding","page":"Adaptive Mesh Refinement","title":"4. Monitor Regridding","text":"for step in 1:1000\n    sim_step!(sim; remeasure=true)\n\n    # Check regridding frequency\n    stats = get_body_motion_stats(sim)\n    if stats.steps_since_regrid == 0\n        println(\"Regrid at step $step\")\n    end\nend","category":"section"},{"location":"amr/#5.-Force-Coefficient-Computation","page":"Adaptive Mesh Refinement","title":"5. Force Coefficient Computation","text":"# Compute forces on moving body\nforces = total_force(sim)  # Returns (Fx, Fz) or (Fx, Fy, Fz)\n\n# Normalize to coefficients\nCd = forces[1] / (0.5 * sim.L * sim.U^2)\nCl = forces[2] / (0.5 * sim.L * sim.U^2)","category":"section"},{"location":"amr/#Troubleshooting","page":"Adaptive Mesh Refinement","title":"Troubleshooting","text":"","category":"section"},{"location":"amr/#NaN-Values","page":"Adaptive Mesh Refinement","title":"NaN Values","text":"If velocity becomes NaN:\n\nReduce time step (decrease CFL number)\nIncrease min_regrid_interval if regridding too frequently\nCheck body SDF is smooth and continuous","category":"section"},{"location":"amr/#Excessive-Regridding","page":"Adaptive Mesh Refinement","title":"Excessive Regridding","text":"If regridding every step:\n\nIncrease indicator_change_threshold\nIncrease min_regrid_interval\nUse RigidBodyAMRConfig for rigid bodies","category":"section"},{"location":"amr/#Missing-Refinement","page":"Adaptive Mesh Refinement","title":"Missing Refinement","text":"If patches don't follow body:\n\nIncrease body_distance_threshold\nDecrease indicator_change_threshold\nEnsure remeasure=true is set","category":"section"},{"location":"amr/#Memory-Issues","page":"Adaptive Mesh Refinement","title":"Memory Issues","text":"For large simulations:\n\nReduce max_level\nIncrease regrid_interval\nUse smaller buffer_size","category":"section"},{"location":"amr/#BioFlows.AMRSimulation","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRSimulation","text":"AMRSimulation\n\nSimulation with adaptive mesh refinement near immersed bodies.\n\nWraps a standard Simulation and adds AMR capability that automatically refines the mesh near the body and in regions of high gradients.\n\nFields\n\nsim: The underlying Simulation\nconfig: AMR configuration parameters\nrefined_grid: Current refined grid state\ncomposite_pois: CompositePoisson solver for AMR (manages base + patches)\nadapter: Flow-to-grid adapter\nlast_regrid_step: Step count at last regrid\namr_active: Whether AMR is currently active\n\nExample\n\nconfig = AMRConfig(max_level=3, body_distance_threshold=4.0, regrid_interval=5)\nsim = AMRSimulation((128, 128), (1.0, 0.0), 16.0;\n                    ν=0.01, body=AutoBody(sdf), amr_config=config)\nfor _ in 1:1000\n    sim_step!(sim; remeasure=true)  # AMR regridding happens automatically\nend\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.AMRConfig","page":"Adaptive Mesh Refinement","title":"BioFlows.AMRConfig","text":"AMRConfig\n\nConfiguration for adaptive mesh refinement.\n\nFields\n\nmax_level: Maximum refinement level (1 = 2x finer, 2 = 4x finer, etc.)\nbody_distance_threshold: Refine within this distance (in grid cells) from body\nvelocity_gradient_threshold: Threshold for velocity gradient refinement\nvorticity_threshold: Threshold for vorticity-based refinement\nregrid_interval: Number of time steps between regridding checks\nbuffer_size: Number of buffer cells around refined regions\nbody_weight: Weight for body proximity in combined indicator\ngradient_weight: Weight for velocity gradient in combined indicator\nvorticity_weight: Weight for vorticity in combined indicator\n\nFlexible Body Support (for moving/deforming bodies)\n\nflexible_body: Enable adaptive regridding for time-varying bodies\nindicator_change_threshold: Regrid when indicator changes by this fraction (0-1)\nregrid_on_measure: Always regrid after body remeasurement (most accurate but expensive)\nmin_regrid_interval: Minimum steps between regrids (prevents excessive regridding)\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.StaggeredGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.StaggeredGrid","text":"StaggeredGrid\n\nRepresents a staggered (MAC) grid for CFD computations. Velocity components are stored at face centers, pressure at cell centers.\n\nFields\n\ngrid_type: Dimensionality (TwoDimensional or ThreeDimensional)\nnx, ny, nz: Number of cells in each direction (ny=1 for 2D)\ndx, dy, dz: Cell spacing in each direction\nx, y, z: Cell center coordinates\nxf, yf, zf: Face coordinates (staggered locations)\n\n\n\n\n\n","category":"type"},{"location":"amr/#BioFlows.RefinedGrid","page":"Adaptive Mesh Refinement","title":"BioFlows.RefinedGrid","text":"RefinedGrid\n\nContainer for adaptive mesh refinement data. Stores the base grid and tracking information for refined cells.\n\nFields\n\nbase_grid: The coarse/base level grid\nrefined_cells_2d/3d: Dict mapping Flow indices (including ghost offset) to refinement level\nrefined_grids_2d/3d: Dict mapping cell indices to local refined StaggeredGrid\nrefined_states_2d/3d: Dict mapping cell indices to local refined SolutionState\ninterpolation_weights_2d/3d: Pre-computed interpolation weights\n\n\n\n\n\n","category":"type"},{"location":"codebase_structure/#Codebase-Structure","page":"Codebase Structure","title":"Codebase Structure","text":"This document provides an overview of the BioFlows.jl source code organization, module dependencies, and key components.","category":"section"},{"location":"codebase_structure/#Directory-Layout","page":"Codebase Structure","title":"Directory Layout","text":"BioFlows.jl/\n├── src/                          # Source code\n│   ├── BioFlows.jl               # Main module file\n│   ├── Flow.jl                   # Flow solver, BDIM, time stepping\n│   ├── Poisson.jl                # Base Poisson pressure solver\n│   ├── MultiLevelPoisson.jl      # Multigrid pressure solver\n│   ├── Body.jl                   # Abstract body types and SDF utilities\n│   ├── AutoBody.jl               # Implicit geometry via SDFs\n│   ├── util.jl                   # Utilities, macros, boundary conditions\n│   ├── Diagnostics.jl            # Force computation, vorticity\n│   ├── Metrics.jl                # Flow statistics (mean flow, Reynolds stress)\n│   ├── Output.jl                 # I/O utilities (JLD2 writers)\n│   ├── amr/                      # Adaptive Mesh Refinement\n│   │   ├── amr_types.jl          # Core AMR data structures\n│   │   ├── amr_project.jl        # AMR projection and momentum step\n│   │   ├── amr_adapter.jl           # Flow-to-grid adapters\n│   │   ├── body_refinement_indicator.jl  # Refinement criteria\n│   │   ├── composite_poisson.jl  # Multi-level pressure solver\n│   │   ├── composite_solver.jl   # Composite grid solver\n│   │   ├── interface_operators.jl # Coarse-fine interface operators\n│   │   ├── patch_creation.jl     # AMR patch management\n│   │   ├── patch_poisson.jl      # Patch-level pressure solver\n│   │   └── refined_fields.jl     # Refined velocity field storage\n│   └── fsi/                      # Fluid-Structure Interaction\n│       ├── EulerBernoulliBeam.jl # Beam dynamics solver\n│       ├── FluidStructureCoupling.jl  # Beam-fluid coupling (FSISimulation)\n│       └── BeamAMR.jl            # BeamAMRSimulation for flexible bodies with AMR\n├── examples/                     # Example scripts\n│   ├── circle_benchmark.jl       # Simple cylinder benchmark\n│   ├── flow_past_cylinder_2d.jl  # Comprehensive 2D cylinder example\n│   ├── oscillating_cylinder.jl   # Moving cylinder with sinusoidal motion\n│   ├── sphere_3d.jl              # 3D sphere wake simulation\n│   ├── torus_3d.jl               # 3D torus in periodic flow\n│   ├── swimming_fish.jl          # Flexible swimming fish (FSI)\n│   └── swimming_fish_amr.jl      # Swimming fish with adaptive mesh refinement\n├── test/                         # Test suite\n│   ├── runtests.jl               # Main test runner\n│   ├── test_amr.jl               # AMR functionality tests\n│   ├── test_composite_poisson.jl # Composite Poisson solver tests\n│   ├── test_fvm.jl               # Finite volume method tests\n│   └── test_pressure_solver.jl   # Pressure solver tests\n└── docs/                         # Documentation (Documenter.jl)","category":"section"},{"location":"codebase_structure/#Core-Modules","page":"Codebase Structure","title":"Core Modules","text":"","category":"section"},{"location":"codebase_structure/#Main-Module-(BioFlows.jl)","page":"Codebase Structure","title":"Main Module (BioFlows.jl)","text":"The entry point that:\n\nImports all dependencies (KernelAbstractions, MPI, ForwardDiff, JLD2, etc.)\nIncludes all source files in dependency order\nDefines core simulation types: Simulation, AMRSimulation, FSISimulation, BeamAMRSimulation\nExports public API for flow solving, AMR, and FSI","category":"section"},{"location":"codebase_structure/#Flow-Solver-(Flow.jl)","page":"Codebase Structure","title":"Flow Solver (Flow.jl)","text":"The heart of the CFD solver implementing:\n\nFunction Description\nFlow() Constructor for flow state (velocity, pressure, coefficients)\nmom_step!() Full momentum step: predictor + pressure projection + corrector\nBDIM!() Boundary Data Immersion Method for immersed boundaries\nconv_diff!() Convection-diffusion operator (advection + viscous terms)\naccelerate!() Apply body forces (gravity, prescribed accelerations)\nexitBC!() Convective outlet boundary condition\nproject!() Pressure projection for divergence-free velocity\nscale_u!() Velocity scaling for time stepping\n\nKey data structures in Flow:\n\nstruct Flow{T,D}\n    u::Array{T,D+1}     # Velocity field (staggered)\n    u⁰::Array{T,D+1}    # Previous velocity\n    p::Array{T,D}       # Pressure\n    f::Array{T,D+1}     # RHS / forcing\n    σ::Array{T,D}       # Divergence\n    μ₀::Array{T,D+1}    # BDIM volume fraction\n    μ₁::Array{T,D+2}    # BDIM first moment (gradient correction)\n    V::Array{T,D+1}     # Body velocity\n    Δx::NTuple{D,T}     # Grid spacing\n    Δt::Vector{T}       # Time step history\n    # ... additional fields\nend","category":"section"},{"location":"codebase_structure/#Pressure-Solvers","page":"Codebase Structure","title":"Pressure Solvers","text":"","category":"section"},{"location":"codebase_structure/#Poisson.jl-Base-Solver","page":"Codebase Structure","title":"Poisson.jl - Base Solver","text":"Conjugate gradient (CG) solver with geometric multigrid preconditioner\nHandles periodic and Neumann boundary conditions\nKey functions: solver!(), mult!(), residual!()","category":"section"},{"location":"codebase_structure/#MultiLevelPoisson.jl-Multigrid-Solver","page":"Codebase Structure","title":"MultiLevelPoisson.jl - Multigrid Solver","text":"V-cycle multigrid preconditioner\nAutomatic coarsening up to 4x4 base grid\nRestriction and prolongation operators","category":"section"},{"location":"codebase_structure/#Boundary-Conditions-(util.jl)","page":"Codebase Structure","title":"Boundary Conditions (util.jl)","text":"Function Description\nBC!() Apply velocity boundary conditions\nexitBC!() Convective outlet BC (1D upwind advection)\nperBC!() Periodic boundary conditions for scalars\n\nBC Types:\n\nDirichlet: Normal velocity component at domain boundaries\nNeumann: Zero-gradient for tangential components (stress-free)\nPeriodic: Ghost cell copying for cyclic boundaries\nBDIM: No-slip on immersed bodies via μ₀/μ₁ weighting","category":"section"},{"location":"codebase_structure/#Body-Definitions","page":"Codebase Structure","title":"Body Definitions","text":"","category":"section"},{"location":"codebase_structure/#Body.jl","page":"Codebase Structure","title":"Body.jl","text":"AbstractBody type hierarchy\nNoBody() for flows without immersed objects\nmeasure_sdf!() for computing signed distance fields","category":"section"},{"location":"codebase_structure/#AutoBody.jl","page":"Codebase Structure","title":"AutoBody.jl","text":"Implicit geometry via signed distance functions (SDFs)\nSupports CSG operations: union (+), subtraction (-)\nTime-dependent geometry via map(x, t) transformations\n\n# Example: Cylinder at (cx, cz) with radius R\nsdf(x, t) = sqrt((x[1] - cx)^2 + (x[2] - cz)^2) - R\nbody = AutoBody(sdf)\n\n# Moving cylinder with velocity (Vx, Vz)\nmap(x, t) = x .- (Vx*t, Vz*t)\nbody = AutoBody(sdf, map)","category":"section"},{"location":"codebase_structure/#Adaptive-Mesh-Refinement-(AMR)","page":"Codebase Structure","title":"Adaptive Mesh Refinement (AMR)","text":"","category":"section"},{"location":"codebase_structure/#Architecture","page":"Codebase Structure","title":"Architecture","text":"AMRSimulation\n    ├── Simulation (base grid)\n    ├── AMRConfig (refinement parameters)\n    ├── RefinedGrid (cell tracking)\n    ├── CompositePoisson (multi-level pressure solver)\n    │   ├── base_pois (MultiLevelPoisson)\n    │   └── patches (Dict of PatchPoisson)\n    └── FlowToGridAdapter","category":"section"},{"location":"codebase_structure/#AMR-Files","page":"Codebase Structure","title":"AMR Files","text":"File Purpose\namr_types.jl StaggeredGrid, RefinedGrid, SolutionState types\namr_project.jl amr_project!(), amr_mom_step!()\nbody_refinement_indicator.jl Refinement criteria based on body distance, gradients, vorticity\ncomposite_poisson.jl CompositePoisson multi-level solver\ncomposite_solver.jl Composite grid iteration\ninterface_operators.jl Coarse-fine interpolation, restriction\npatch_creation.jl Create/manage PatchPoisson instances\npatch_poisson.jl Individual patch pressure solver\nrefined_fields.jl RefinedVelocityField for storing fine-level data","category":"section"},{"location":"codebase_structure/#Key-AMR-Functions","page":"Codebase Structure","title":"Key AMR Functions","text":"# Create AMR-enabled simulation\nsim = AMRSimulation((nx, nz), (Lx, Lz);\n    body=body,\n    amr_config=AMRConfig(max_level=2))\n\n# Time stepping with automatic regridding\nsim_step!(sim; remeasure=true)\n\n# Force immediate regrid\nforce_regrid!(sim)\n\n# Check divergence at all levels\ncheck_divergence(sim; verbose=true)","category":"section"},{"location":"codebase_structure/#Fluid-Structure-Interaction-(FSI)","page":"Codebase Structure","title":"Fluid-Structure Interaction (FSI)","text":"","category":"section"},{"location":"codebase_structure/#FSI-Files","page":"Codebase Structure","title":"FSI Files","text":"File Purpose\nEulerBernoulliBeam.jl Beam dynamics with Hermite finite elements, BeamMaterial, BeamGeometry\nFluidStructureCoupling.jl FlexibleBodyFSI, FSISimulation, fluid-beam coupling\nBeamAMR.jl BeamAMRSimulation, FlexibleBodySDF, AMR for flexible swimming bodies","category":"section"},{"location":"codebase_structure/#Beam-Model","page":"Codebase Structure","title":"Beam Model","text":"Euler-Bernoulli beam theory (small deflections)\nHermite cubic shape functions (C1 continuity)\nNewmark-beta time integration\nBoundary conditions: CLAMPED, FREE, PINNED, PRESCRIBED\n\n# Create beam material and geometry\nmaterial = BeamMaterial(ρ=1050.0, E=5e5)\ngeometry = BeamGeometry(0.2, 51; thickness=0.01, width=0.05)\n\n# Create a flexible beam\nbeam = EulerBernoulliBeam(geometry, material;\n    bc_left = CLAMPED,\n    bc_right = FREE,\n    damping = 0.1)\n\n# Apply traveling wave muscle activation\nf_wave = traveling_wave_forcing(\n    amplitude=100.0,\n    frequency=2.0,\n    wavelength=1.0,\n    envelope=:carangiform,\n    L=0.2\n)","category":"section"},{"location":"codebase_structure/#BeamAMRSimulation","page":"Codebase Structure","title":"BeamAMRSimulation","text":"For flexible swimming bodies with adaptive mesh refinement:\n\n# Create swimming fish simulation with AMR\nsim = BeamAMRSimulation((256, 128), (2.0, 1.0);\n    L_fish = 0.2,\n    h_max = 0.02,\n    E = 5e5,\n    ρ_fish = 1050.0,\n    amr_config = FlexibleBodyAMRConfig(max_level=2),\n    ν = 1e-3)\n\n# Time stepping with automatic regridding\nfor _ in 1:1000\n    sim_step!(sim; remeasure=true)\nend\n\n# Check AMR status\nbeam_info(sim)","category":"section"},{"location":"codebase_structure/#Diagnostics-(Diagnostics.jl)","page":"Codebase Structure","title":"Diagnostics (Diagnostics.jl)","text":"","category":"section"},{"location":"codebase_structure/#Force-Computation","page":"Codebase Structure","title":"Force Computation","text":"Function Description\npressure_force(sim) Pressure contribution to force\nviscous_force(sim) Viscous contribution to force\ntotal_force(sim) Sum of pressure and viscous forces\nforce_coefficients(sim) Cd, Cl (drag and lift coefficients)","category":"section"},{"location":"codebase_structure/#Flow-Quantities","page":"Codebase Structure","title":"Flow Quantities","text":"Function Description\nω(flow) Vorticity field (2D: scalar, 3D: vector)\nω_mag(flow) Vorticity magnitude\ncell_center_velocity(flow) Interpolate staggered velocity to cell centers\ncell_center_pressure(flow) Cell-centered pressure","category":"section"},{"location":"codebase_structure/#Memory-and-Backends","page":"Codebase Structure","title":"Memory and Backends","text":"BioFlows.jl supports multiple compute backends via KernelAbstractions.jl:\n\n# CPU (default)\nsim = Simulation(dims, L; mem=Array, ...)\n\n# GPU (requires CUDA.jl)\nusing CUDA\nsim = Simulation(dims, L; mem=CuArray, ...)","category":"section"},{"location":"codebase_structure/#Backend-Selection","page":"Codebase Structure","title":"Backend Selection","text":"# Check current backend\nBioFlows.backend\n\n# Set backend\nBioFlows.set_backend(\"KernelAbstractions\")  # Default, multi-threaded\nBioFlows.set_backend(\"SIMD\")                # Single-threaded, optimized","category":"section"},{"location":"codebase_structure/#Module-Dependency-Graph","page":"Codebase Structure","title":"Module Dependency Graph","text":"BioFlows.jl\n    │\n    ├── util.jl (macros, BC functions)\n    │\n    ├── Poisson.jl\n    │   └── MultiLevelPoisson.jl\n    │\n    ├── Body.jl\n    │   └── AutoBody.jl\n    │\n    ├── Flow.jl (depends on Poisson, Body, util)\n    │\n    ├── amr/ (depends on Flow, Poisson)\n    │   ├── amr_types.jl\n    │   ├── amr_adapter.jl\n    │   ├── body_refinement_indicator.jl\n    │   ├── refined_fields.jl\n    │   ├── patch_poisson.jl\n    │   ├── interface_operators.jl\n    │   ├── composite_poisson.jl\n    │   ├── composite_solver.jl\n    │   ├── patch_creation.jl\n    │   └── amr_project.jl\n    │\n    ├── fsi/ (depends on Flow, amr/)\n    │   ├── EulerBernoulliBeam.jl\n    │   ├── FluidStructureCoupling.jl\n    │   └── BeamAMR.jl\n    │\n    ├── Metrics.jl (depends on Flow)\n    ├── Diagnostics.jl (depends on Flow, Body)\n    └── Output.jl (depends on Flow, Diagnostics)","category":"section"},{"location":"codebase_structure/#Key-Conventions","page":"Codebase Structure","title":"Key Conventions","text":"","category":"section"},{"location":"codebase_structure/#Indexing","page":"Codebase Structure","title":"Indexing","text":"Staggered grid: Velocity stored at face centers\nGhost cells: 1-cell layer at domain boundaries\nInterior indices: 2:N+1 for N interior cells\n@inside macro: Generates loops over interior cells","category":"section"},{"location":"codebase_structure/#Coordinate-System","page":"Codebase Structure","title":"Coordinate System","text":"2D: (x, z) where x is streamwise, z is vertical\n3D: (x, y, z) standard Cartesian\nSDF convention: Negative inside body, positive outside","category":"section"},{"location":"codebase_structure/#Naming-Conventions","page":"Codebase Structure","title":"Naming Conventions","text":"Suffix Meaning\n! Mutating function (modifies arguments)\n_u Operates on velocity fields\n_p Operates on pressure fields\n⁰ Previous time step value\nμ₀, μ₁ BDIM moments","category":"section"},{"location":"codebase_structure/#Extending-BioFlows","page":"Codebase Structure","title":"Extending BioFlows","text":"","category":"section"},{"location":"codebase_structure/#Adding-New-Body-Types","page":"Codebase Structure","title":"Adding New Body Types","text":"# Define custom body\nstruct MyBody <: AbstractBody\n    # fields\nend\n\n# Implement required methods\nBioFlows.measure!(flow::Flow, body::MyBody; kwargs...) = ...","category":"section"},{"location":"codebase_structure/#Adding-New-Diagnostics","page":"Codebase Structure","title":"Adding New Diagnostics","text":"# Add to Diagnostics.jl or create extension\nfunction my_diagnostic(sim::Simulation)\n    flow = sim.flow\n    # Compute diagnostic from flow fields\nend","category":"section"},{"location":"codebase_structure/#Using-I/O-Features","page":"Codebase Structure","title":"Using I/O Features","text":"BioFlows includes JLD2 for saving simulation data:\n\nusing BioFlows\nusing JLD2\n\n# Create diagnostic writers\nwriter = CenterFieldWriter(\"fields.jld2\"; interval=0.1)\nforce_writer = ForceWriter(\"forces.jld2\")\n\n# In simulation loop\nfile_save!(writer, sim, t)\nrecord_force!(force_writer, sim, t)\n\n# Close writers when done\nclose!(writer)\nclose!(force_writer)","category":"section"},{"location":"codebase_structure/#Using-Plots/Makie-(Optional)","page":"Codebase Structure","title":"Using Plots/Makie (Optional)","text":"If you load Plots.jl or Makie.jl, visualization functions become available:\n\nusing BioFlows\nusing Plots  # Enables flood, addbody, body_plot!, sim_gif!\n\n# Or with Makie\nusing GLMakie  # Enables viz!, get_body, plot_body_obs!","category":"section"},{"location":"codebase_structure/#Performance-Tips","page":"Codebase Structure","title":"Performance Tips","text":"Use remeasure=false for static bodies to skip SDF recomputation\nSet JULIA_NUM_THREADS=auto for multi-threaded CPU execution\nUse GPU arrays (CuArray) for large 3D simulations\nTune AMR parameters: Lower regrid_interval for fast-moving bodies\nUse store_fluxes=false (default) unless debugging conservation","category":"section"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"BioFlows provides built-in diagnostics for forces, vorticity, and flow statistics.","category":"section"},{"location":"diagnostics/#Force-Computation","page":"Diagnostics","title":"Force Computation","text":"","category":"section"},{"location":"diagnostics/#Force-Components","page":"Diagnostics","title":"Force Components","text":"","category":"section"},{"location":"diagnostics/#Usage","page":"Diagnostics","title":"Usage","text":"using BioFlows\n\n# Get all force components (uses simulation's ρ from sim.flow.ρ)\ncomponents = force_components(sim; reference_area=sim.L)\n\n# Access individual forces (in Newtons)\npressure_force = components.pressure   # [Fx, Fz] or [Fx, Fy, Fz]\nviscous_force = components.viscous\ntotal_force = components.total\n\n# Dimensionless coefficients (Cd, Cl, etc.)\nCd, Cl = components.coefficients[3]  # Total force coefficients\n\n# For air simulations, set ρ when creating the simulation:\nsim_air = Simulation((128, 64), (1.0, 0.5); ν=1.5e-5, ρ=1.2, body=cylinder)","category":"section"},{"location":"diagnostics/#Force-History","page":"Diagnostics","title":"Force History","text":"Record forces over time for analysis:\n\nhistory = NamedTuple[]\n\nfor step in 1:1000\n    sim_step!(sim)\n    record_force!(history, sim; reference_area=sim.L)  # Uses water density by default\nend\n\n# Access recorded data\ntimes = [h.time for h in history]\ndrag_coeffs = [h.total_coeff[1] for h in history]\nlift_coeffs = [h.total_coeff[2] for h in history]","category":"section"},{"location":"diagnostics/#Force-Statistics","page":"Diagnostics","title":"Force Statistics","text":"# Compute mean and RMS after discarding transient\nstats = summarize_force_history(history; discard=0.2)  # Discard first 20%\n\nprintln(\"Mean drag: \", stats.drag_mean)\nprintln(\"Drag std:  \", stats.drag_std)\nprintln(\"Mean lift: \", stats.lift_mean)\nprintln(\"Lift std:  \", stats.lift_std)","category":"section"},{"location":"diagnostics/#Automatic-Force-File-Output","page":"Diagnostics","title":"Automatic Force File Output","text":"Use ForceWriter to automatically save lift and drag coefficients to a JLD2 file at specified time intervals:\n\nusing BioFlows\n\n# Create simulation\nsim = Simulation((128, 128), (1.0, 0.0), 1.0; ν=0.001, body=AutoBody(sdf))\n\n# Create force writer - saves every 0.1 time units\nforce_writer = ForceWriter(\"forces.jld2\"; interval=0.1, reference_area=sim.L)\n\n# Time stepping loop\nfor _ in 1:5000\n    sim_step!(sim)\n    file_save!(force_writer, sim)  # Writes to JLD2 when interval elapsed\nend\n\nThe JLD2 file contains arrays: time, Cd, Cl, Cd_pressure, Cd_viscous, Cl_pressure, Cl_viscous.\n\n# Read the output file\nusing JLD2\ndata = load(\"forces.jld2\")\ntime = data[\"time\"]\nCd = data[\"Cd\"]\nCl = data[\"Cl\"]","category":"section"},{"location":"diagnostics/#Vorticity","page":"Diagnostics","title":"Vorticity","text":"","category":"section"},{"location":"diagnostics/#Vorticity-Fields","page":"Diagnostics","title":"Vorticity Fields","text":"","category":"section"},{"location":"diagnostics/#Usage-2","page":"Diagnostics","title":"Usage","text":"# Out-of-plane vorticity for 2D (ω₃ = ∂v/∂x - ∂u/∂z)\nω3 = vorticity_component(sim, 3)\n\n# Vorticity magnitude\nω_mag = vorticity_magnitude(sim)\n\n# For 3D simulations\nωx = vorticity_component(sim, 1)\nωy = vorticity_component(sim, 2)\nωz = vorticity_component(sim, 3)","category":"section"},{"location":"diagnostics/#Ghost-Layer-Handling","page":"Diagnostics","title":"Ghost Layer Handling","text":"By default, ghost layers are stripped from output:\n\n# With ghost layers stripped (default)\nω = vorticity_component(sim, 3; strip_ghosts=true)\n\n# Keep ghost layers\nω_with_ghosts = vorticity_component(sim, 3; strip_ghosts=false)","category":"section"},{"location":"diagnostics/#Cell-Centered-Fields","page":"Diagnostics","title":"Cell-Centered Fields","text":"For visualization and output, interpolate to cell centers:","category":"section"},{"location":"diagnostics/#Usage-3","page":"Diagnostics","title":"Usage","text":"# Cell-centered velocity [nx, nz, 2] or [nx, ny, nz, 3]\nvel = cell_center_velocity(sim)\n\n# Cell-centered vorticity\n# 2D: scalar field [nx, nz]\n# 3D: vector field [nx, ny, nz, 3]\nvort = cell_center_vorticity(sim)\n\n# Cell-centered pressure [nx, nz] or [nx, ny, nz]\npres = cell_center_pressure(sim)","category":"section"},{"location":"diagnostics/#Simulation-Diagnostics","page":"Diagnostics","title":"Simulation Diagnostics","text":"The compute_diagnostics function returns summary statistics for the current simulation state.","category":"section"},{"location":"diagnostics/#Usage-4","page":"Diagnostics","title":"Usage","text":"diag = compute_diagnostics(sim)\n\nprintln(\"Max u-velocity: \", diag.max_u)\nprintln(\"Max w-velocity: \", diag.max_w)\nprintln(\"CFL number:     \", diag.CFL)\nprintln(\"Time step:      \", diag.Δt)\nprintln(\"Grid size:      \", diag.grid)","category":"section"},{"location":"diagnostics/#Example:-Complete-Diagnostics-Loop","page":"Diagnostics","title":"Example: Complete Diagnostics Loop","text":"using BioFlows\nusing Statistics\n\n# Setup simulation\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\n# Storage\nforce_history = NamedTuple[]\nmax_cfl = 0.0\n\n# Main loop\nfor step in 1:5000\n    sim_step!(sim; remeasure=false)\n    record_force!(force_history, sim)\n\n    # Track CFL\n    diag = compute_diagnostics(sim)\n    max_cfl = max(max_cfl, diag.CFL)\n\n    # Print every 500 steps\n    if step % 500 == 0\n        stats = summarize_force_history(force_history; discard=0.3)\n        println(\"Step $step: t=$(round(sim_time(sim), digits=2)), \",\n                \"Cd=$(round(stats.drag_mean, digits=3)), \",\n                \"CFL=$(round(diag.CFL, digits=3))\")\n    end\nend\n\n# Final statistics\nfinal_stats = summarize_force_history(force_history; discard=0.3)\nprintln(\"\\nFinal Results:\")\nprintln(\"  Mean Cd = \", round(final_stats.drag_mean, digits=4))\nprintln(\"  Std Cd  = \", round(final_stats.drag_std, digits=4))\nprintln(\"  Mean Cl = \", round(final_stats.lift_mean, digits=4))\nprintln(\"  Max CFL = \", round(max_cfl, digits=3))","category":"section"},{"location":"diagnostics/#Visualization","page":"Diagnostics","title":"Visualization","text":"BioFlows integrates with Plots.jl via extensions:\n\nusing Plots\nusing BioFlows\n\n# Get vorticity field\nω = vorticity_component(sim, 3)\n\n# Plot with flood\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity field\")\n\nFor VTK output (ParaView compatible):\n\nusing WriteVTK\nusing BioFlows\n\n# VTK writer becomes available\nvtkWriter(sim, \"output_dir\")","category":"section"},{"location":"diagnostics/#BioFlows.force_components","page":"Diagnostics","title":"BioFlows.force_components","text":"force_components(sim; reference_area=sim.L, with_coefficients=true)\n\nCollect pressure, viscous, and total force vectors for sim in Newtons. When with_coefficients=true, dimensionless coefficients are returned using the reference area ½ρU²A. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.force_coefficients","page":"Diagnostics","title":"BioFlows.force_coefficients","text":"force_coefficients(sim; reference_area=sim.L)\n\nConvenience wrapper returning only the total force coefficients. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.record_force!","page":"Diagnostics","title":"BioFlows.record_force!","text":"record_force!(history, sim; reference_area=sim.L)\n\nAppend a force sample to history, which should be a Vector of NamedTuples. Stores time, raw forces (in Newtons), and dimensionless coefficients. Uses the density from the simulation (sim.flow.ρ).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_component","page":"Diagnostics","title":"BioFlows.vorticity_component","text":"vorticity_component(sim, component; strip_ghosts=true, physical=false)\n\nReturn the requested vorticity component evaluated at cell centres. For 2D simulations use component=3 to obtain the out-of-plane vorticity.\n\nArguments\n\nphysical=false: If true, return physical vorticity in units of 1/s (scaled by Δx).                   If false, return unit-spacing vorticity (raw differences).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.vorticity_magnitude","page":"Diagnostics","title":"BioFlows.vorticity_magnitude","text":"vorticity_magnitude(sim; strip_ghosts=true, physical=false)\n\nCompute the vorticity magnitude field for the current simulation state.\n\nArguments\n\nphysical=false: If true, return physical vorticity magnitude in units of 1/s (scaled by Δx).                   If false, return unit-spacing vorticity magnitude (raw differences).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_velocity","page":"Diagnostics","title":"BioFlows.cell_center_velocity","text":"cell_center_velocity(sim; strip_ghosts=true)\n\nReturn the velocity field averaged to cell centres for each component. The last dimension indexes the velocity components.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_vorticity","page":"Diagnostics","title":"BioFlows.cell_center_vorticity","text":"cell_center_vorticity(sim; strip_ghosts=true, physical=false)\n\nReturn the vorticity at cell centres. For 2D simulations this returns a scalar field (the ω₃ component); for 3D it returns the full vector with the last dimension indexing components.\n\nArguments\n\nphysical=false: If true, return physical vorticity in units of 1/s (scaled by Δx).                   If false, return unit-spacing vorticity (raw differences).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BioFlows.cell_center_pressure","page":"Diagnostics","title":"BioFlows.cell_center_pressure","text":"cell_center_pressure(sim; strip_ghosts=true)\n\nReturn the pressure field at cell centres. Pressure is already cell-centred in the staggered grid, so this simply returns the field with optional ghost cell stripping.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"BioFlows includes several example scripts in the examples/ directory.","category":"section"},{"location":"examples/#Flow-Past-Cylinder-(2D)","page":"Examples","title":"Flow Past Cylinder (2D)","text":"File: examples/flow_past_cylinder_2d.jl\n\nThe most comprehensive example with configurable parameters:\n\nusing BioFlows\n\ninclude(\"examples/flow_past_cylinder_2d.jl\")\n\n# Run with custom parameters\nsim, history, stats, writer, diagnostics = run_flow_past_cylinder(\n    nx = 256,           # Grid points in x\n    nz = 64,            # Grid points in z\n    Lx = 8.0,           # Domain length\n    Lz = 2.0,           # Domain height\n    Re = 150,           # Reynolds number\n    final_time = 10.0,  # Convective time units\n    save_center_fields = true,\n    center_filename = \"output.jld2\",\n    diagnostic_interval = 100\n)\n\nprintln(\"Mean Cd: \", stats.drag_mean)\nprintln(\"Lift RMS: \", stats.lift_rms)","category":"section"},{"location":"examples/#Command-Line","page":"Examples","title":"Command Line","text":"julia --project examples/flow_past_cylinder_2d.jl","category":"section"},{"location":"examples/#Output","page":"Examples","title":"Output","text":"Force history with Cd/Cl coefficients\nCell-centered velocity/vorticity snapshots (JLD2)\nDiagnostic statistics","category":"section"},{"location":"examples/#Circle-Benchmark","page":"Examples","title":"Circle Benchmark","text":"File: examples/circle_benchmark.jl\n\nSimple 2D cylinder for benchmarking:\n\nusing BioFlows\n\nradius = 8\ncenter = 4 * radius - 1\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\nsim = Simulation((6radius, 8radius), (1, 0), 2radius;\n                 ν = 2radius / 120,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-2","page":"Examples","title":"Command Line","text":"julia --project examples/circle_benchmark.jl","category":"section"},{"location":"examples/#Oscillating-Cylinder","page":"Examples","title":"Oscillating Cylinder","text":"File: examples/oscillating_cylinder.jl\n\nCylinder with sinusoidal cross-flow motion:\n\nusing BioFlows\n\nradius = 8\nA = radius / 2    # Oscillation amplitude\nSt = 0.2          # Strouhal number\nω = 2π * St       # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]\n\nbody = AutoBody(sdf, map)\n\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = body)\n\n# Must remeasure for moving bodies\nsim_step!(sim, 5.0; remeasure=true)","category":"section"},{"location":"examples/#Command-Line-3","page":"Examples","title":"Command Line","text":"julia --project examples/oscillating_cylinder.jl","category":"section"},{"location":"examples/#3D-Torus","page":"Examples","title":"3D Torus","text":"File: examples/torus_3d.jl\n\n3D torus in periodic inflow:\n\nusing BioFlows\n\nR = 16  # Major radius\nr = 4   # Minor radius\n\nfunction sdf_torus(x, t)\n    # Distance from torus centerline\n    d_ring = sqrt(x[1]^2 + x[2]^2) - R\n    sqrt(d_ring^2 + x[3]^2) - r\nend\n\nsim = Simulation((64, 64, 64), (1, 0, 0), 2r;\n                 ν = 2r / 50,\n                 body = AutoBody(sdf_torus),\n                 perdir = (1, 2))  # Periodic in x and y\n\nsim_step!(sim, 2.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-4","page":"Examples","title":"Command Line","text":"julia --project examples/torus_3d.jl","category":"section"},{"location":"examples/#3D-Sphere","page":"Examples","title":"3D Sphere","text":"File: examples/sphere_3d.jl\n\n3D sphere wake simulation:\n\nusing BioFlows\n\nradius = 8\ncenter = [32, 32, 32]\n\nsdf(x, t) = sqrt(sum((x .- center).^2)) - radius\n\nsim = Simulation((128, 64, 64), (1, 0, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\nsim_step!(sim, 1.0; remeasure=false)","category":"section"},{"location":"examples/#Command-Line-5","page":"Examples","title":"Command Line","text":"julia --project examples/sphere_3d.jl","category":"section"},{"location":"examples/#Visualization-Examples","page":"Examples","title":"Visualization Examples","text":"","category":"section"},{"location":"examples/#Plot-Vorticity","page":"Examples","title":"Plot Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup simulation\nradius = 8\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - radius\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,\n                 body = AutoBody(sdf))\n\n# Run simulation\nsim_step!(sim, 5.0; remeasure=false)\n\n# Get vorticity\nω = vorticity_component(sim, 3)\n\n# Create plot\nheatmap(ω', c=:RdBu, clim=(-2, 2),\n        aspect_ratio=:equal,\n        xlabel=\"x\", ylabel=\"z\",\n        title=\"Vorticity ω_z\")\nsavefig(\"vorticity.png\")","category":"section"},{"location":"examples/#Animate-Vorticity","page":"Examples","title":"Animate Vorticity","text":"using BioFlows\nusing Plots\n\n# Setup\nsdf(x, t) = sqrt((x[1] - 32)^2 + (x[2] - 32)^2) - 8\nsim = Simulation((128, 64), (1, 0), 16.0;\n                 ν = 16.0 / 100,\n                 body = AutoBody(sdf))\n\nanim = @animate for step in 1:500\n    sim_step!(sim)\n\n    if step % 10 == 0\n        ω = vorticity_component(sim, 3)\n        heatmap(ω', c=:RdBu, clim=(-2, 2),\n                title=\"t = $(round(sim_time(sim), digits=2))\")\n    end\nend\n\ngif(anim, \"vorticity.gif\", fps=15)","category":"section"},{"location":"examples/#Loading-Saved-Data","page":"Examples","title":"Loading Saved Data","text":"Read JLD2 snapshots from CenterFieldWriter:\n\nusing JLD2\n\n# Load snapshot\njldopen(\"center_fields.jld2\", \"r\") do file\n    # List snapshots\n    for key in keys(file)\n        println(key)\n    end\n\n    # Read specific snapshot\n    t = file[\"snapshot_10/time\"]\n    vel = file[\"snapshot_10/velocity\"]\n    vort = file[\"snapshot_10/vorticity\"]\nend","category":"section"},{"location":"examples/#Swimming-Fish-(Flexible-Body)","page":"Examples","title":"Swimming Fish (Flexible Body)","text":"File: examples/swimming_fish.jl\n\nFlexible swimming fish with traveling wave motion:\n\nusing BioFlows\ninclude(\"examples/swimming_fish.jl\")\n\n# Single carangiform swimmer (tail-dominated, like tuna)\nsim, history = run_swimming_fish(\n    steps = 500,\n    nx = 256, nz = 128,\n    fish_length = 0.2,\n    amplitude = 0.1,           # Tail amplitude\n    frequency = 1.0,           # Hz\n    amplitude_envelope = :carangiform\n)\n\n# Get force statistics\nstats = summarize_force_history(history; discard=0.2)\nprintln(\"Mean Cd: \", stats.drag_mean)\nprintln(\"Mean Cl: \", stats.lift_mean)","category":"section"},{"location":"examples/#Swimming-Modes","page":"Examples","title":"Swimming Modes","text":"# Anguilliform (eel-like, whole-body motion)\nsim = swimming_fish_sim(\n    amplitude_envelope = :anguilliform,\n    head_amplitude = 0.05,\n    wavelength = 0.8\n)\n\n# Subcarangiform (trout-like)\nsim = swimming_fish_sim(\n    amplitude_envelope = :subcarangiform\n)","category":"section"},{"location":"examples/#Leading-Edge-Motion","page":"Examples","title":"Leading Edge Motion","text":"# Fish with heave motion at head\nsim = swimming_fish_sim(\n    heave_amplitude = 0.05,\n    heave_phase = 0.0\n)\n\n# Fish with pitch motion at head\nsim = swimming_fish_sim(\n    pitch_amplitude = 0.15,   # radians\n    pitch_phase = π/2         # 90° phase lead\n)\n\n# Combined heave + pitch\nsim = swimming_fish_sim(\n    heave_amplitude = 0.03,\n    pitch_amplitude = 0.1\n)","category":"section"},{"location":"examples/#Command-Line-6","page":"Examples","title":"Command Line","text":"julia --project examples/swimming_fish.jl","category":"section"},{"location":"examples/#Fish-School","page":"Examples","title":"Fish School","text":"File: examples/swimming_fish.jl\n\nMultiple swimming fish with configurable formations:\n\nusing BioFlows\ninclude(\"examples/swimming_fish.jl\")\n\n# Staggered formation with 3 fish\nsim, history, configs = run_fish_school(\n    steps = 500,\n    n_fish = 3,\n    formation = :staggered,\n    phase_offset = π/3,        # Phase difference between fish\n    spacing = 0.15             # Lateral spacing\n)","category":"section"},{"location":"examples/#Formations","page":"Examples","title":"Formations","text":"# Inline (tandem)\nsim, _ = fish_school_sim(n_fish=4, formation=:inline)\n\n# Side by side\nsim, _ = fish_school_sim(n_fish=3, formation=:side_by_side)\n\n# Diamond (4+ fish)\nsim, _ = fish_school_sim(n_fish=4, formation=:diamond)","category":"section"},{"location":"examples/#Synchronized-vs-Wave-Motion","page":"Examples","title":"Synchronized vs Wave Motion","text":"# Synchronized (all same phase)\nsim, _ = synchronized_school_sim(n_fish=3)\n\n# Wave-like phase progression\nsim, _ = wave_school_sim(n_fish=5, phase_offset=π/4)","category":"section"},{"location":"examples/#Swimming-Fish-with-AMR","page":"Examples","title":"Swimming Fish with AMR","text":"File: examples/swimming_fish.jl\n\nAdaptive mesh refinement for swimming fish:\n\nusing BioFlows\ninclude(\"examples/swimming_fish.jl\")\n\n# Single fish with AMR\nsim = swimming_fish_amr_sim(\n    nx = 256, nz = 128,\n    amplitude_envelope = :carangiform,\n    amr_max_level = 2\n)\n\nfor step in 1:500\n    sim_step!(sim; remeasure=true)\nend\n\namr_info(sim)","category":"section"},{"location":"examples/#Fish-School-with-AMR","page":"Examples","title":"Fish School with AMR","text":"# Multiple fish with AMR\nsim, configs = fish_school_amr_sim(\n    n_fish = 3,\n    formation = :staggered,\n    amr_max_level = 2\n)\n\nfor step in 1:500\n    sim_step!(sim; remeasure=true)\nend","category":"section"},{"location":"examples/#Fluid-Structure-Interaction-(FSI)","page":"Examples","title":"Fluid-Structure Interaction (FSI)","text":"","category":"section"},{"location":"examples/#Flexible-Beam-(Euler-Bernoulli)","page":"Examples","title":"Flexible Beam (Euler-Bernoulli)","text":"File: test_fsi.jl\n\nThe Euler-Bernoulli beam solver uses Hermite finite elements for accurate structural dynamics:\n\nusing BioFlows\n\n# Material properties\nmaterial = BeamMaterial(ρ=1100.0, E=1e6, ν_poisson=0.45)\n\n# Geometry: 0.2m beam with 51 nodes\ngeometry = BeamGeometry(0.2, 51; thickness=0.01, width=0.05)\n\n# Create beam with clamped-free boundary conditions\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED,\n                          bc_right=FREE,\n                          damping=0.1)\n\n# Apply uniform load\nfill!(beam.q, 10.0)  # 10 N/m\n\n# Time step the beam\nfor i in 1:100\n    step!(beam, 1e-4)\nend\n\n# Check results\nprintln(\"Max displacement: \", maximum(abs.(beam.w)) * 1000, \" mm\")\nprintln(\"Kinetic energy: \", kinetic_energy(beam), \" J\")\nprintln(\"Potential energy: \", potential_energy(beam), \" J\")","category":"section"},{"location":"examples/#Active-Swimming-with-Traveling-Wave","page":"Examples","title":"Active Swimming with Traveling Wave","text":"using BioFlows\n\n# Create fish-like beam\nL = 0.2  # Fish length\nmaterial = BeamMaterial(ρ=1050.0, E=5e5)\nh_func = fish_thickness_profile(L, 0.02)  # Max thickness 0.02m\ngeometry = BeamGeometry(L, 51; thickness=h_func, width=0.02)\n\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED, bc_right=FREE,\n                          damping=0.5)\n\n# Create traveling wave muscle activation (carangiform)\nf_wave = traveling_wave_forcing(\n    amplitude=100.0,\n    frequency=2.0,\n    wavelength=1.0,\n    envelope=:carangiform,\n    L=L\n)\n\n# Simulate swimming\ndt = 1e-4\nfor i in 1:5000\n    t = i * dt\n    set_active_forcing!(beam, f_wave, t)\n    step!(beam, dt)\nend\n\n# Get deformation\nκ = get_curvature(beam)\nM = get_bending_moment(beam)\nprintln(\"Max curvature: \", maximum(abs.(κ)), \" 1/m\")\nprintln(\"Max moment: \", maximum(abs.(M)), \" N·m\")","category":"section"},{"location":"examples/#Beam-Properties","page":"Examples","title":"Beam Properties","text":"Access displacement and rotation fields:\n\n# Displacement (w) and rotation (θ) at each node\nw = beam.w        # Returns view into state vector\nθ = beam.θ        # Rotation = ∂w/∂x\nw_dot = beam.w_dot  # Velocity\n\n# Set initial conditions (views allow in-place modification)\nfor i in 1:beam.geometry.n\n    s = beam.s[i]\n    beam.w[i] = 0.001 * (s/L)^2  # Parabolic shape\n    beam.θ[i] = 0.002 * s/L      # Corresponding rotation\nend\n\n# Reset to zero\nreset!(beam)","category":"section"},{"location":"examples/#Saving-Beam-State-to-Files","page":"Examples","title":"Saving Beam State to Files","text":"Save flexible body positions to JLD2 files with configurable save rates:\n\nusing BioFlows\n\n# Create beam\nmaterial = BeamMaterial(ρ=1100.0, E=1e6)\ngeometry = BeamGeometry(0.2, 51; thickness=0.01, width=0.05)\nbeam = EulerBernoulliBeam(geometry, material; bc_left=CLAMPED, bc_right=FREE)\n\n# Create writer - saves every 0.01 time units\nwriter = BeamStateWriter(\"flag_1.jld2\"; interval=0.01)\n\n# Simulation loop\ndt = 1e-4\nfor step in 1:10000\n    t = step * dt\n    fill!(beam.q, 50.0)  # Apply load\n    step!(beam, dt)\n    file_save!(writer, beam, t)\nend\n\n# IMPORTANT: Close writer to save data to file\nclose!(writer, beam)","category":"section"},{"location":"examples/#Multiple-Flags-(Separate-Files)","page":"Examples","title":"Multiple Flags (Separate Files)","text":"For multiple flexible bodies, each gets its own file:\n\n# Create 5 flags with different properties\nn_flags = 5\nbeams = [\n    EulerBernoulliBeam(\n        BeamGeometry(0.2, 51; thickness=0.01, width=0.05),\n        BeamMaterial(ρ=1100.0, E=1e6 * i);  # Different stiffness\n        bc_left=CLAMPED, bc_right=FREE\n    ) for i in 1:n_flags\n]\n\n# Create writer group - creates flag_1.jld2, flag_2.jld2, etc.\nwriters = BeamStateWriterGroup(\"flag\", n_flags; interval=0.01)\n\n# Simulation loop\nfor step in 1:10000\n    t = step * dt\n    for beam in beams\n        step!(beam, dt)\n    end\n    file_save!(writers, beams, t)  # Save all beams\nend\n\n# Close all writers\nclose!(writers, beams)","category":"section"},{"location":"examples/#Reading-Beam-State-Files","page":"Examples","title":"Reading Beam State Files","text":"using JLD2\n\njldopen(\"flag_1.jld2\", \"r\") do file\n    # Metadata\n    n_snapshots = file[\"metadata/n_snapshots\"]\n    n_nodes = file[\"metadata/n_nodes\"]\n    L = file[\"metadata/length\"]\n\n    # Time series\n    t = file[\"time\"]\n    KE = file[\"kinetic_energy\"]\n    PE = file[\"potential_energy\"]\n\n    # Field matrices (n_nodes × n_snapshots)\n    w = file[\"fields/displacement\"]\n    θ = file[\"fields/rotation\"]\n    κ = file[\"fields/curvature\"]\n\n    # Individual snapshots\n    w_10 = file[\"snapshots/10/displacement\"]\n    θ_10 = file[\"snapshots/10/rotation\"]\nend","category":"section"},{"location":"examples/#Static-Analysis-(Point-Loads)","page":"Examples","title":"Static Analysis (Point Loads)","text":"For static problems, solve K*u = F directly:\n\nusing LinearAlgebra\n\n# Create beam\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED, bc_right=FREE)\n\n# Apply point load at tip\nn_dof = 2 * beam.geometry.n\nF = zeros(n_dof)\ntip_dof = n_dof - 1  # Tip displacement DOF\nF[tip_dof] = 5.0     # 5 N point load\n\n# Static solve\nK = Matrix(beam.K_mat)\nu = K \\ F\n\n# Tip deflection\nw_tip = u[tip_dof]\nprintln(\"Tip deflection: \", w_tip * 1000, \" mm\")\n\n# Analytical: w = PL³/(3EI)\nE, I, L = material.E, beam.I_vec[1], beam.geometry.L\nw_analytical = 5.0 * L^3 / (3 * E * I)\nprintln(\"Analytical: \", w_analytical * 1000, \" mm\")","category":"section"},{"location":"examples/#GPU-Execution","page":"Examples","title":"GPU Execution","text":"Run on NVIDIA GPU:\n\nusing CUDA\nusing BioFlows\n\nsim = Simulation((256, 128), (1, 0), 16.0;\n                 ν = 16.0 / 200,\n                 body = AutoBody(sdf),\n                 mem = CuArray)  # Use GPU arrays\n\nsim_step!(sim, 10.0)","category":"section"},{"location":"core_types/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"core_types/#Simulation","page":"Core Types","title":"Simulation","text":"The main container for a BioFlows simulation.","category":"section"},{"location":"core_types/#Constructor","page":"Core Types","title":"Constructor","text":"Simulation(dims::NTuple{N}, L::NTuple{N};\n           inletBC=nothing, U=nothing, Δt=0.25, fixed_Δt=nothing, ν=0., ϵ=1, g=nothing,\n           perdir=(), outletBC=false, L_char=nothing, store_fluxes=false,\n           body::AbstractBody=NoBody(),\n           T=Float32, mem=Array)\n\nArguments:\n\nParameter Type Description\ndims NTuple{N,Int} Grid dimensions (nx, nz) or (nx, ny, nz)\nL NTuple{N} Physical domain size (Lx, Lz) or (Lx, Ly, Lz) in meters\ninletBC Tuple or Function Inlet boundary velocity (see below). Default: (1, 0, ...)\nU Number Velocity scale (auto-computed if inletBC is constant, required if function)\nΔt Number Initial time step (default: 0.25)\nfixed_Δt Number or Nothing Fixed time step. If set, disables adaptive CFL (default: nothing)\nν Number Kinematic viscosity (Re = U*L/ν)\nρ Number Fluid density (default: 1000 kg/m³ for water)\nϵ Number BDIM kernel width (default: 1)\ng Function or Nothing Acceleration field g(i,x,t)\nperdir Tuple Periodic directions, e.g. (2,)\noutletBC Bool Convective outlet in x-direction\nL_char Number Characteristic length for force coefficients (default: L[1])\nstore_fluxes Bool Enable FVM flux storage for conservation analysis (default: false)\nbody AbstractBody Immersed geometry\nT Type Float type (Float32 or Float64)\nmem Type Array backend (Array for CPU)","category":"section"},{"location":"core_types/#Inlet-Boundary-Conditions","page":"Core Types","title":"Inlet Boundary Conditions","text":"The inletBC parameter specifies the inlet velocity and can be:\n\nConstant (Tuple): Uniform velocity across the inlet\ninletBC = (1.0, 0.0)  # U=1 in x, 0 in z\nSpatially-varying (Function): Velocity varies with position\n# Parabolic profile: u(z) = U_max * (1 - (z-H)²/H²)\nH = Lz / 2\ninletBC(i, x, t) = i == 1 ? 1.5 * (1 - ((x[2] - H) / H)^2) : 0.0\nTime-varying (Function): Velocity varies with time\n# Oscillating inlet\ninletBC(i, x, t) = i == 1 ? 1.0 + 0.1*sin(2π*t) : 0.0\n\nFunction signature: inletBC(i, x, t) where:\n\ni: Velocity component (1=x, 2=z in 2D; 1=x, 2=y, 3=z in 3D)\nx: Position vector [x, z] or [x, y, z]\nt: Time","category":"section"},{"location":"core_types/#Fields","page":"Core Types","title":"Fields","text":"Field Description\nU Velocity scale\nL Length scale\nϵ BDIM kernel width\nflow Flow struct with velocity/pressure fields\nbody Immersed body geometry\npois Pressure Poisson solver","category":"section"},{"location":"core_types/#Flow","page":"Core Types","title":"Flow","text":"The Flow struct holds all fluid fields for the simulation.","category":"section"},{"location":"core_types/#Fields-2","page":"Core Types","title":"Fields","text":"Field Type Description\nu Array{T,D+1} Velocity vector field (m/s)\nu⁰ Array{T,D+1} Previous velocity (for time stepping)\nf Array{T,D+1} Force/RHS vector field (m/s²)\np Array{T,D} Pressure scalar field (Pa = kg/(m·s²))\nσ Array{T,D} Divergence scalar field (work array)\nV Array{T,D+1} Body velocity vector (BDIM)\nμ₀ Array{T,D+1} Zeroth moment (BDIM)\nμ₁ Array{T,D+2} First moment tensor (BDIM)\nF_conv Array{T,D+2} or Nothing Convective flux tensor (FVM mode)\nF_diff Array{T,D+2} or Nothing Diffusive flux tensor (FVM mode)\nstore_fluxes Bool FVM flux storage enabled\nΔt Vector{T} Time step history (s)\nν T Kinematic viscosity (m²/s)\nρ T Fluid density (kg/m³), default 1000 (water)\nΔx NTuple{D,T} Grid spacing per direction (m)\nfixed_Δt T or Nothing Fixed time step (disables CFL)","category":"section"},{"location":"core_types/#FVM-Flux-Storage","page":"Core Types","title":"FVM Flux Storage","text":"When store_fluxes=true, the Flow stores explicit flux tensors for conservation analysis:\n\n# Enable FVM mode\nflow = Flow((nx, nz); L=(Lx, Lz), store_fluxes=true, ν=0.01)\n\n# Access flux tensors after time step\nF_conv = flow.F_conv  # Convective flux: F_conv[I, j, i]\nF_diff = flow.F_diff  # Diffusive flux: F_diff[I, j, i]\n\nThe flux tensor indices are:\n\nI = spatial cell index (D-dimensional CartesianIndex)\nj = face direction (1=x, 2=y, 3=z)\ni = momentum component being transported","category":"section"},{"location":"core_types/#AutoBody","page":"Core Types","title":"AutoBody","text":"Define geometry implicitly via signed distance functions.","category":"section"},{"location":"core_types/#Constructor-2","page":"Core Types","title":"Constructor","text":"AutoBody(sdf, map=(x,t)->x; compose=true)\n\nArguments:\n\nParameter Description\nsdf Signed distance function sdf(x, t)\nmap Coordinate mapping function map(x, t) for moving bodies\ncompose Auto-compose sdf∘map when true (default)","category":"section"},{"location":"core_types/#Example:-Static-Cylinder","page":"Core Types","title":"Example: Static Cylinder","text":"radius = 8\ncenter = [32, 32]\nsdf(x, t) = sqrt((x[1] - center[1])^2 + (x[2] - center[2])^2) - radius\nbody = AutoBody(sdf)","category":"section"},{"location":"core_types/#Example:-Oscillating-Cylinder","page":"Core Types","title":"Example: Oscillating Cylinder","text":"radius = 8\nA = 5.0  # Amplitude\nω = 0.5  # Angular frequency\n\nsdf(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x, t) = x .- [0, A * sin(ω * t)]  # Vertical oscillation\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Example:-Rotating-Ellipse","page":"Core Types","title":"Example: Rotating Ellipse","text":"a, b = 10, 5  # Semi-axes\nω = 0.2       # Angular velocity\n\nsdf(x, t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\n\nfunction map(x, t)\n    θ = ω * t\n    c, s = cos(θ), sin(θ)\n    [c*x[1] + s*x[2], -s*x[1] + c*x[2]]\nend\n\nbody = AutoBody(sdf, map)","category":"section"},{"location":"core_types/#Simulation-Control-Functions","page":"Core Types","title":"Simulation Control Functions","text":"","category":"section"},{"location":"core_types/#Time-Stepping","page":"Core Types","title":"Time Stepping","text":"","category":"section"},{"location":"core_types/#Usage","page":"Core Types","title":"Usage","text":"# Single time step\nsim_step!(sim; remeasure=true)\n\n# Integrate to target time\nsim_step!(sim, 10.0; remeasure=false, verbose=true)\n\n# Query time\nt_star = sim_time(sim)  # Dimensionless time t*U/L\nt_raw = time(sim.flow)  # Raw simulation time\n\n# Update body for moving geometry\nmeasure!(sim)\n\n# Add perturbations for flow instability\nperturb!(sim; noise=0.1)\n\n# Print status\nsim_info(sim)  # Prints: tU/L=..., Δt=...","category":"section"},{"location":"core_types/#BioFlows.Simulation","page":"Core Types","title":"BioFlows.Simulation","text":"Simulation(dims::NTuple{N}, L::NTuple{N}; inletBC=(1,0,...), kwargs...)\n\nConstructor for a BioFlows simulation solving the dimensional incompressible Navier-Stokes equations:\n\n∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g\n∇·u = 0\n\nArguments\n\nRequired\n\ndims::NTuple{N,Int}: Number of grid cells in each direction, e.g., (nx, nz) or (nx, ny, nz)\nL::NTuple{N}: Physical domain size in each direction (e.g., (Lx, Lz) in meters)\n\nOptional (keyword arguments)\n\ninletBC: Inlet boundary velocity (default: unit velocity in x-direction)\nTuple: Constant velocity, e.g., (1.0, 0.0) for uniform flow\nFunction(i,x,t): Spatially/temporally varying (requires U to be specified)\noutletBC=false: Enable convective outlet BC in direction 1\nν=0.: Kinematic viscosity (m²/s)\nρ=1000.: Fluid density (kg/m³). Water = 1000, air ≈ 1.2\nbody=NoBody(): Immersed body geometry\nL_char: Characteristic length for force coefficients (default: L[1])\nU: Velocity scale. Auto-computed from inletBC if constant, required if function\nΔt=0.25: Initial time step (seconds)\nfixed_Δt=nothing: Fixed time step (seconds). If specified, disables adaptive CFL time stepping.\ng=nothing: Body acceleration function g(i,x,t) (m/s²)\nϵ=1: BDIM kernel width (in grid cells)\nperdir=(): Periodic directions, e.g., (2,) for z-periodic\nuλ=nothing: Initial velocity condition. Tuple or Function(i,x)\nT=Float32: Numeric type\nmem=Array: Memory backend (Array, CuArray, etc.)\nstore_fluxes=false: Enable FVM flux storage for conservation analysis\n\nExamples\n\nConstant inlet velocity\n\n# 2D channel with uniform inlet\nsim = Simulation((256, 128), (2.0, 1.0); inletBC=(1.0, 0.0), ν=1e-6)\n\n# With immersed cylinder\ndiameter = 0.2\ncylinder = AutoBody((x,t) -> √(x[1]^2 + x[2]^2) - diameter/2)\nsim = Simulation((256, 128), (2.0, 1.0);\n                 inletBC = (1.0, 0.0),\n                 ν = 1e-6,\n                 body = cylinder,\n                 L_char = diameter)\n\nSpatially-varying inlet (parabolic profile)\n\n# Parabolic inlet: u(z) = U_max * (1 - (z - H)²/H²)\nLx, Lz = 2.0, 1.0\nH = Lz / 2\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\n\nsim = Simulation((256, 128), (Lx, Lz);\n                 inletBC = inletBC,\n                 U = U_max,\n                 ν = 1e-6,\n                 outletBC = true)\n\nTime-varying inlet\n\nU₀, ω = 1.0, 2π\ninletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(ω*t)) : 0.0\n\nsim = Simulation((256, 128), (2.0, 1.0); inletBC=inletBC, U=U₀, ν=1e-6)\n\nSee files in examples folder for more examples.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.Flow","page":"Core Types","title":"BioFlows.Flow","text":"Flow{D::Int, T::Float, Sf<:AbstractArray{T,D}, Vf<:AbstractArray{T,D+1}, Tf<:AbstractArray{T,D+2}}\n\nComposite type for a multidimensional immersed boundary flow simulation.\n\nFlow solves the unsteady incompressible Navier-Stokes equations on a Cartesian grid. Solid boundaries are modelled using the Boundary Data Immersion Method. The primary variables are the scalar pressure p (an array of dimension D) and the velocity vector field u (an array of dimension D+1).\n\nThe equations solved are the dimensional incompressible Navier-Stokes:     ∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u + g     ∇·u = 0\n\nwhere Δx is the uniform grid spacing (m), ν is kinematic viscosity (m²/s), and all spatial derivatives are properly scaled by Δx.\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.AutoBody","page":"Core Types","title":"BioFlows.AutoBody","text":"AutoBody(sdf, map=(x,t)->x; compose=true, velocity=nothing) <: AbstractBody\n\nsdf(x::AbstractVector,t::Real)::Real: signed distance function\nmap(x::AbstractVector,t::Real)::AbstractVector: coordinate mapping function\ncompose::Bool=true: Flag for composing sdf=sdf∘map\nvelocity=nothing: Optional body velocity function velocity(x,t)\n\nImplicitly define a geometry by its sdf and optional coordinate map. Note: the map is composed automatically if compose=true, i.e. sdf(x,t) = sdf(map(x,t),t). Both parameters remain independent otherwise. It can be particularly heplful to set compose=false when adding mulitple bodies together to create a more complex one.\n\nExamples\n\n# Static cylinder\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nbody = AutoBody(sdf)\n\n# Oscillating cylinder (vertical motion)\nsdf(x,t) = sqrt(x[1]^2 + x[2]^2) - radius\nmap(x,t) = x .- [0, A*sin(ω*t)]  # Shift coordinate frame\nbody = AutoBody(sdf, map)\n\n# Rotating ellipse\nsdf(x,t) = sqrt((x[1]/a)^2 + (x[2]/b)^2) - 1\nmap(x,t) = [cos(ω*t) sin(ω*t); -sin(ω*t) cos(ω*t)] * x\nbody = AutoBody(sdf, map)\n\n\n\n\n\n","category":"type"},{"location":"core_types/#BioFlows.sim_step!","page":"Core Types","title":"BioFlows.sim_step!","text":"sim_step!(sim::AbstractSimulation,t_end;remeasure=true,λ=quick,max_steps=typemax(Int),verbose=false,\n    udf=nothing,kwargs...)\n\nIntegrate the simulation sim up to dimensionless time t_end. If remeasure=true, the body is remeasured at every time step. Can be set to false for static geometries to speed up simulation. A user-defined function udf can be passed to arbitrarily modify the ::Flow during the predictor and corrector steps. If the udf user keyword arguments, these needs to be included in the sim_step! call as well. A λ::Function function can be passed as a custom convective scheme, following the interface of λ(u,c,d) (for upstream, central, downstream points).\n\n\n\n\n\nsim_step!(sim::AMRSimulation; remeasure=true, λ=quick, kwargs...)\n\nAdvance AMR simulation by one time step with automatic regridding. Uses CompositePoisson for pressure solve when AMR has refined patches.\n\nFor flexible bodies (moving/deforming), the function:\n\nFirst remeasures the body position (if remeasure=true)\nChecks if regridding is needed based on:\nFixed interval (regrid_interval)\nBody motion detection (if flexible_body=true)\nAlways-regrid mode (if regridonmeasure=true)\nUpdates patch coefficients after body remeasurement\n\n\n\n\n\nsim_step!(sim::AMRSimulation, t_end; kwargs...)\n\nAdvance AMR simulation up to dimensionless time t_end.\n\n\n\n\n\nsim_step!(sim::FSISimulation; kwargs...)\n\nAdvance the FSI simulation by one time step.\n\nAlgorithm:\n\nAdvance fluid with current body shape\nCompute fluid forces on structure\nAdvance structure with forces\nUpdate body shape for next step\n\n\n\n\n\nsim_step!(sim::BeamAMRSimulation; kwargs...)\n\nAdvance the beam-AMR simulation by one time step.\n\nThis performs:\n\nApply active forcing to beam (if set)\nAdvance beam dynamics\nUpdate beam SDF\nCheck for AMR regridding based on beam motion\nAdvance fluid with updated body position\n\n\n\n\n\nsim_step!(sim::BeamAMRSimulation, t_end; kwargs...)\n\nAdvance simulation to target dimensionless time.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_time","page":"Core Types","title":"BioFlows.sim_time","text":"sim_time(sim::Simulation)\n\nReturn the current dimensionless time of the simulation tU/L where t=sum(Δt), and U,L are the simulation velocity and length scales.\n\n\n\n\n\nsim_time(sim::FSISimulation)\n\nGet the current simulation time.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.measure!","page":"Core Types","title":"BioFlows.measure!","text":"measure!(flow::Flow, body::AbstractBody; t=0, ϵ=1)\n\nQueries the body geometry to fill the arrays:\n\nflow.μ₀, Zeroth kernel moment\nflow.μ₁, First kernel moment scaled by the body normal\nflow.V,  Body velocity\n\nat time t using an immersion kernel of size ϵ.\n\nSee Maertens & Weymouth, doi:10.1016/j.cma.2014.09.007.\n\n\n\n\n\nmeasure!(sim::Simulation,t=timeNext(sim))\n\nMeasure a dynamic body to update the flow and pois coefficients.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.perturb!","page":"Core Types","title":"BioFlows.perturb!","text":"perturb!(sim; noise=0.1)\n\nPerturb the velocity field of a simulation with noise level with respect to velocity scale U.\n\n\n\n\n\n","category":"function"},{"location":"core_types/#BioFlows.sim_info","page":"Core Types","title":"BioFlows.sim_info","text":"sim_info(sim::AbstractSimulation)\n\nPrints information on the current state of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")","category":"section"},{"location":"getting_started/#Local-Development","page":"Getting Started","title":"Local Development","text":"Clone the repository and activate:\n\ngit clone https://github.com/subhk/BioFlows.jl.git\ncd BioFlows.jl\njulia --project\n\nThen instantiate dependencies:\n\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"getting_started/#Your-First-Simulation","page":"Getting Started","title":"Your First Simulation","text":"Here's a complete example of simulating flow past a 2D cylinder:\n\nusing BioFlows\n\n# Physical parameters\nRe = 100        # Reynolds number\nU = 1.0         # Inlet velocity\nD = 16.0        # Cylinder diameter (length scale)\n\n# Grid and domain parameters\nnx, nz = 128, 64\nLx, Lz = Float64(nx), Float64(nz)  # Domain size (Δx = 1)\n\n# Define cylinder geometry\ncenter_x = nx / 4\ncenter_z = nz / 2\nradius = D / 2\n\n# Signed distance function (negative inside body)\nsdf(x, t) = sqrt((x[1] - center_x)^2 + (x[2] - center_z)^2) - radius\n\n# Create simulation\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 ν = U * D / Re,\n                 body = AutoBody(sdf),\n                 L_char = D)\n\n# Time integration\nfinal_time = 10.0  # Convective time units\n\nwhile sim_time(sim) < final_time\n    sim_step!(sim; remeasure=false)\n\n    # Print progress every 100 steps\n    if length(sim.flow.Δt) % 100 == 0\n        println(\"t = \", round(sim_time(sim), digits=2))\n    end\nend\n\nprintln(\"Simulation complete!\")","category":"section"},{"location":"getting_started/#Key-Concepts","page":"Getting Started","title":"Key Concepts","text":"","category":"section"},{"location":"getting_started/#Dimensionless-Time","page":"Getting Started","title":"Dimensionless Time","text":"BioFlows uses dimensionless (convective) time:\n\nt^* = fract cdot UL\n\nwhere U is the velocity scale and L is the length scale.\n\nsim_time(sim) returns the current dimensionless time t*\ntime(sim.flow) returns the raw simulation time t","category":"section"},{"location":"getting_started/#Signed-Distance-Functions","page":"Getting Started","title":"Signed Distance Functions","text":"Geometry is defined implicitly via signed distance functions (SDF):\n\nsdf(x, t) < 0: Inside the body\nsdf(x, t) = 0: On the body surface\nsdf(x, t) > 0: Outside the body\n\nExample SDFs:\n\n# Circle/Cylinder\nsdf_circle(x, t) = sqrt(x[1]^2 + x[2]^2) - radius\n\n# Rectangle\nsdf_rect(x, t) = max(abs(x[1]) - width/2, abs(x[2]) - height/2)\n\n# Sphere (3D)\nsdf_sphere(x, t) = sqrt(x[1]^2 + x[2]^2 + x[3]^2) - radius","category":"section"},{"location":"getting_started/#Boundary-Conditions","page":"Getting Started","title":"Boundary Conditions","text":"Specify inlet boundary conditions via the inletBC keyword argument:\n\n# Constant inlet velocity (uniform flow)\nsim = Simulation(dims, L; inletBC=(1.0, 0.0), ...)\n\n# Spatially-varying inlet (parabolic profile in z)\n# Function signature: inletBC(i, x, t) where i=component, x=position, t=time\nH = Lz / 2  # channel half-height\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\nsim = Simulation(dims, L; inletBC=inletBC, U=U_max, ...)  # Must specify U for functions\n\n# Time-varying inlet (oscillating)\ninletBC(i, x, t) = i == 1 ? 1.0 + 0.1*sin(2π*t) : 0.0\nsim = Simulation(dims, L; inletBC=inletBC, U=1.0, ...)\n\nAdditional boundary options:\n\nperdir=(2,): Make direction 2 (z) periodic\noutletBC=true: Convective outlet in x-direction","category":"section"},{"location":"getting_started/#Running-Examples","page":"Getting Started","title":"Running Examples","text":"The examples/ directory contains ready-to-run scripts:\n\njulia --project examples/flow_past_cylinder_2d.jl\njulia --project examples/circle_benchmark.jl\njulia --project examples/oscillating_cylinder.jl\n\nSee Examples for detailed descriptions.","category":"section"},{"location":"#BioFlows.jl","page":"Home","title":"BioFlows.jl","text":"A Julia package for computational fluid dynamics with immersed boundary methods\n\nBioFlows.jl provides a complete solver for incompressible viscous flow on Cartesian grids using the Boundary Data Immersion Method (BDIM).","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Pure Julia solver for incompressible Navier-Stokes equations\nImmersed boundary method via BDIM (Boundary Data Immersion Method)\nImplicit geometry definition through signed distance functions\nAdaptive Mesh Refinement (AMR) near bodies and flow features\nFluid-Structure Interaction (FSI) via Euler-Bernoulli beam with Hermite FEM\nCPU and GPU execution via KernelAbstractions.jl\nMPI support for distributed computing\nBuilt-in diagnostics: forces, vorticity, cell-centered fields\nJLD2 and VTK output (via extensions)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/subhk/BioFlows.jl\")\n\nOr activate the project locally:\n\njulia --project\njulia> ]instantiate","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using BioFlows\n\n# Define cylinder geometry via signed distance function\nradius = 8\ncenter = 32\nsdf(x, t) = sqrt((x[1] - center)^2 + (x[2] - center)^2) - radius\n\n# Create simulation: domain (nx, nz), boundary velocity, length scale\nsim = Simulation((128, 64), (1, 0), 2radius;\n                 ν = 2radius / 100,    # Re = 100\n                 body = AutoBody(sdf))\n\n# Advance to t*U/L = 1.0 (convective time units)\nsim_step!(sim, 1.0; remeasure=false)\n\n# Check simulation state\nprintln(\"Time: \", sim_time(sim))","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"codebase_structure.md\",\n    \"numerical_methods.md\",\n    \"core_types.md\",\n    \"amr.md\",\n    \"diagnostics.md\",\n    \"examples.md\",\n    \"api.md\",\n]\nDepth = 2","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"Subhajit Kar\nDibyendu Ghosh","category":"section"},{"location":"numerical_methods/#Numerical-Methods","page":"Numerical Methods","title":"Numerical Methods","text":"This section describes the numerical methods used in BioFlows.jl for solving the incompressible Navier-Stokes equations.","category":"section"},{"location":"numerical_methods/#Governing-Equations","page":"Numerical Methods","title":"Governing Equations","text":"BioFlows.jl solves the incompressible Navier-Stokes equations in dimensional form:\n\nfracpartial mathbfupartial t + (mathbfu cdot nabla)mathbfu = -frac1rhonabla p + nu nabla^2 mathbfu\n\nnabla cdot mathbfu = 0\n\nwhere:\n\nmathbfu = (u v)\nis the velocity field (m/s)\np\nis the pressure (Pa)\nrho\nis the density (kg/m³)\nnu\nis the kinematic viscosity (m²/s)","category":"section"},{"location":"numerical_methods/#Staggered-Grid-(MAC-Grid)","page":"Numerical Methods","title":"Staggered Grid (MAC Grid)","text":"BioFlows.jl uses a staggered grid arrangement, also known as a Marker-And-Cell (MAC) grid. This arrangement naturally satisfies the discrete divergence-free condition and avoids spurious pressure oscillations (checkerboard modes).","category":"section"},{"location":"numerical_methods/#Variable-Locations-in-2D","page":"Numerical Methods","title":"Variable Locations in 2D","text":"On a staggered grid, different variables are stored at different locations within each cell:\n\nPressure (p): Cell centers\nx-velocity (u): Vertical cell faces (between left/right neighbors)\ny-velocity (v): Horizontal cell faces (between bottom/top neighbors)\n\n         Δx\n    ├─────────────┤\n\n    ┌─────────────┬─────────────┬─────────────┐  ─┬─\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │   │\n    │    p_i,j+1  │   p_i+1,j+1 │  p_i+2,j+1  │   │\n    │             │             │             │   Δy\n    u             u             u             u   │\n    │             │             │             │   │\n    │      ●      v      ●      v      ●      │  ─┴─\n    │    p_i,j    │   p_i+1,j   │  p_i+2,j    │\n    │             │             │             │\n    u             u             u             u\n    │             │             │             │\n    │      ●      v      ●      v      ●      │\n    │   p_i,j-1   │  p_i+1,j-1  │  p_i+2,j-1  │\n    │             │             │             │\n    └─────────────┴─────────────┴─────────────┘\n\n    Legend:\n    ●  = Pressure (p) at cell center\n    u  = x-velocity component at vertical faces\n    v  = y-velocity component at horizontal faces","category":"section"},{"location":"numerical_methods/#Detailed-Single-Cell-View","page":"Numerical Methods","title":"Detailed Single Cell View","text":"For a single cell (ij), the staggered arrangement is:\n\n                    v[i,j+1]\n                       ↑\n              ┌────────┼────────┐\n              │        │        │\n              │        │        │\n    u[i,j] ───┼───── p[i,j] ────┼─── u[i+1,j]\n      →       │        ●        │       →\n              │                 │\n              │                 │\n              └────────┼────────┘\n                       │\n                       ↓\n                    v[i,j]\n\n    Grid spacing: Δx (horizontal), Δy (vertical)\n    Cell center:  (i-½, j-½) in grid coordinates\n    u location:   (i, j-½) - on left/right faces\n    v location:   (i-½, j) - on bottom/top faces","category":"section"},{"location":"numerical_methods/#Indexing-Convention","page":"Numerical Methods","title":"Indexing Convention","text":"In BioFlows.jl, the arrays are indexed as follows:\n\nVariable Array Index Physical Location\np[i,j] Cell (ij) Center of cell (ij)\nu[i,j,1] Face (ij) Left face of cell (ij)\nu[i,j,2] Face (ij) Bottom face of cell (ij)\n\nThe velocity field is stored in a single array u[I,d] where I is the cell index and d is the direction (1=x, 2=y for 2D; 1=x, 2=y, 3=z for 3D).","category":"section"},{"location":"numerical_methods/#Extension-to-3D","page":"Numerical Methods","title":"Extension to 3D","text":"In three dimensions, the staggered grid extends naturally:\n\nPressure (p): Cell centers\nx-velocity (u): yz-faces (perpendicular to x)\ny-velocity (v): xz-faces (perpendicular to y)\nz-velocity (w): xy-faces (perpendicular to z)\n\n                        z\n                        │   y\n                        │  /\n                        │ /\n                        │/\n            ────────────┼──────────── x\n\n\n                    ┌───────────────────┐\n                   /│                  /│\n                  / │       w_top     / │\n                 /  │       ↑        /  │\n                ┌───────────────────┐   │\n                │   │      ●        │   │\n          u_L → │   │    p_ijk      │ → u_R\n                │   │               │   │\n                │   └ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ┘\n                │  /                │  /\n                │ /      ↓         │ /\n                │/    w_bottom     │/\n                └───────────────────┘\n                      ↗       ↘\n                   v_front   v_back\n\n\n    Legend:\n    ●     = Pressure at cell center (i,j,k)\n    u_L   = u[i,j,k,1] at left face\n    u_R   = u[i+1,j,k,1] at right face\n    v     = v[i,j,k,2] at front/back faces\n    w     = w[i,j,k,3] at top/bottom faces","category":"section"},{"location":"numerical_methods/#Finite-Difference-Operators","page":"Numerical Methods","title":"Finite Difference Operators","text":"","category":"section"},{"location":"numerical_methods/#Divergence","page":"Numerical Methods","title":"Divergence","text":"The discrete divergence operator at cell center (ij):\n\n(nabla cdot mathbfu)_ij = fracu_i+1j - u_ijDelta x + fracv_ij+1 - v_ijDelta y","category":"section"},{"location":"numerical_methods/#Gradient","page":"Numerical Methods","title":"Gradient","text":"The discrete pressure gradient at face locations:\n\nleft(fracpartial ppartial xright)_ij = fracp_ij - p_i-1jDelta x quad text(at u-location)\n\nleft(fracpartial ppartial yright)_ij = fracp_ij - p_ij-1Delta y quad text(at v-location)","category":"section"},{"location":"numerical_methods/#Laplacian","page":"Numerical Methods","title":"Laplacian","text":"The discrete Laplacian for the Poisson equation:\n\nnabla^2 p_ij = fracp_i+1j - 2p_ij + p_i-1jDelta x^2 + fracp_ij+1 - 2p_ij + p_ij-1Delta y^2","category":"section"},{"location":"numerical_methods/#Convection-Diffusion-Discretization","page":"Numerical Methods","title":"Convection-Diffusion Discretization","text":"The momentum equation contains convection and diffusion terms that must be carefully discretized on the staggered grid.","category":"section"},{"location":"numerical_methods/#Momentum-Equation","page":"Numerical Methods","title":"Momentum Equation","text":"For velocity component u_i, the semi-discrete momentum equation is:\n\nfracpartial u_ipartial t = -sum_j fracpartial (u_j u_i)partial x_j + nu sum_j fracpartial^2 u_ipartial x_j^2 - frac1rhofracpartial ppartial x_i\n\nThe convection term partial(u_j u_i)partial x_j is in conservative (flux) form, representing the divergence of momentum flux. This is distinct from the non-conservative form u_j partial u_ipartial x_j.","category":"section"},{"location":"numerical_methods/#2D-Momentum-Equations-(Conservative-Form)","page":"Numerical Methods","title":"2D Momentum Equations (Conservative Form)","text":"For 2D flow with coordinates (x z) and velocities (u w):\n\nx-momentum (u):\n\nfracpartial upartial t = -fracpartial (uu)partial x - fracpartial (wu)partial z + nuleft(fracpartial^2 upartial x^2 + fracpartial^2 upartial z^2right) - frac1rhofracpartial ppartial x\n\nz-momentum (w):\n\nfracpartial wpartial t = -fracpartial (uw)partial x - fracpartial (ww)partial z + nuleft(fracpartial^2 wpartial x^2 + fracpartial^2 wpartial z^2right) - frac1rhofracpartial ppartial z\n\nThe terms partial(uu)partial x, partial(wu)partial z, partial(uw)partial x, and partial(ww)partial z are the conservative convective fluxes.","category":"section"},{"location":"numerical_methods/#Finite-Volume-Formulation","page":"Numerical Methods","title":"Finite Volume Formulation","text":"BioFlows.jl uses a conservative finite volume method (FVM) where fluxes are computed at cell faces and applied symmetrically to adjacent cells. This ensures exact conservation of momentum.\n\nFor a control volume around velocity u_i at location I:\n\nfracd u_i^Id t = sum_j left( F_ij^I - F_ij^I-delta_j right)\n\nwhere F_ij^I is the total flux (convective + diffusive) of momentum component i through face j at index I.","category":"section"},{"location":"numerical_methods/#Flux-Computation-at-Cell-Faces","page":"Numerical Methods","title":"Flux Computation at Cell Faces","text":"At each face in direction j, two fluxes contribute to the momentum balance:","category":"section"},{"location":"numerical_methods/#1.-Convective-Flux","page":"Numerical Methods","title":"1. Convective Flux","text":"The convective flux transports momentum with the flow velocity:\n\nF_ij^conv = fracu_j^faceDelta x_j cdot phi(u_i)\n\nwhere:\n\nu_j^face\n= face-normal velocity (interpolated to face)\nphi(u_i)\n= upwind-biased reconstruction of u_i at the face\nDelta x_j\n= grid spacing in direction j\n\nThe face velocity u_j^face is computed by interpolation:\n\nu_j^face = frac12(u_j^L + u_j^R)","category":"section"},{"location":"numerical_methods/#2.-Diffusive-Flux","page":"Numerical Methods","title":"2. Diffusive Flux","text":"The diffusive flux represents viscous stress:\n\nF_ij^diff = -fracnuDelta x_j left( u_i^I - u_i^I-delta_j right)\n\nThis is a central difference approximation to -nu partial u_i  partial x_j.","category":"section"},{"location":"numerical_methods/#Total-Flux","page":"Numerical Methods","title":"Total Flux","text":"The total flux at face I in direction j for momentum component i:\n\nF_ij^I = F_ij^convI + F_ij^diffI","category":"section"},{"location":"numerical_methods/#Upwind-Schemes-for-Convection","page":"Numerical Methods","title":"Upwind Schemes for Convection","text":"BioFlows.jl implements several upwind schemes for reconstructing face values. Given the stencil values u_U (upwind), u_C (center), u_D (downwind), the schemes compute the face value phi.","category":"section"},{"location":"numerical_methods/#QUICK-with-Median-Limiter","page":"Numerical Methods","title":"QUICK with Median Limiter","text":"BioFlows uses a modified QUICK scheme with a median limiter for stability:\n\nphi_QUICK = textmedianleft( frac5u_C + 2u_D - u_U6  u_C  textmedian(10u_C - 9u_U  u_C  u_D) right)\n\nThe median limiter prevents spurious oscillations near discontinuities while maintaining high accuracy in smooth regions. For smooth monotonic profiles, this reduces to the quadratic interpolation (5u_C + 2u_D - u_U)6.\n\nCode: quick(u,c,d) = median((5c+2d-u)/6, c, median(10c-9u,c,d))","category":"section"},{"location":"numerical_methods/#Van-Leer-(TVD)","page":"Numerical Methods","title":"Van Leer (TVD)","text":"The van Leer scheme uses a monotonicity-preserving limiter:\n\nphi_vanLeer = begincases\nu_C  textif  u_C leq min(u_U u_D) text or  u_C geq max(u_U u_D) \nu_C + (u_D - u_C) cdot fracu_C - u_Uu_D - u_U  textotherwise\nendcases\n\nThis ensures the interpolated value lies between neighboring values, preventing oscillations.\n\nCode: vanLeer(u,c,d) = (c≤min(u,d) || c≥max(u,d)) ? c : c+(d-c)*(c-u)/(d-u)","category":"section"},{"location":"numerical_methods/#Central-Difference-(CDS)","page":"Numerical Methods","title":"Central Difference (CDS)","text":"The central difference scheme provides 2nd-order accuracy but may oscillate:\n\nphi_CDS = fracu_C + u_D2\n\nCode: cds(u,c,d) = (c+d)/2","category":"section"},{"location":"numerical_methods/#Stencil-Selection","page":"Numerical Methods","title":"Stencil Selection","text":"The upwind direction is determined by the face velocity u_j^face:\n\nphi(u_i) = begincases\nlambda(u_i^I-2delta u_i^I-delta u_i^I)  textif  u_j^face  0 \nlambda(u_i^I+delta u_i^I u_i^I-delta)  textif  u_j^face  0\nendcases\n\nwhere lambda is the chosen scheme (quick, vanLeer, or cds).","category":"section"},{"location":"numerical_methods/#Conservative-Flux-Application","page":"Numerical Methods","title":"Conservative Flux Application","text":"The key feature of FVM is that the same flux value is added to one cell and subtracted from its neighbor:\n\nCell I-1:    r[I-1] -= F[I]    (flux leaves)\nCell I:      r[I]   += F[I]    (flux enters)\n\nThis ensures that momentum is exactly conserved — no momentum is created or destroyed at internal faces.\n\n        Face I\n          ↓\n    ┌─────┼─────┐\n    │     │     │\n    │ I-1 │  I  │\n    │     │     │\n    └─────┼─────┘\n          │\n     -F ←─┼─→ +F","category":"section"},{"location":"numerical_methods/#Code-Implementation","page":"Numerical Methods","title":"Code Implementation","text":"The FVM is implemented in src/Flow.jl. Here's how the math maps to code:","category":"section"},{"location":"numerical_methods/#Flux-Storage-(Optional)","page":"Numerical Methods","title":"Flux Storage (Optional)","text":"# Flow struct fields for explicit flux storage\nF_conv :: Array{T,D+2}  # Convective flux F_conv[I,j,i]\nF_diff :: Array{T,D+2}  # Diffusive flux F_diff[I,j,i]\nstore_fluxes :: Bool    # Enable FVM mode\n\nThe flux tensor has indices:\n\nI = spatial cell index (D-dimensional)\nj = face direction (1=x, 2=y, 3=z)\ni = momentum component","category":"section"},{"location":"numerical_methods/#Computing-Fluxes","page":"Numerical Methods","title":"Computing Fluxes","text":"# From compute_face_flux! in src/Flow.jl\nfor i ∈ 1:n, j ∈ 1:n\n    inv_Δxj = 1/Δx[j]\n    ν_Δxj = ν/Δx[j]\n\n    # Interior faces\n    @loop (\n        # Convective flux: (1/Δx) * u_face * ϕ(u)\n        F_conv[I,j,i] = inv_Δxj * ϕu(j, CI(I,i), u, ϕ(i,CI(I,j),u), λ);\n        # Diffusive flux: -(ν/Δx) * ∂u/∂x\n        F_diff[I,j,i] = -ν_Δxj * ∂(j, CI(I,i), u)\n    ) over I ∈ inside_u(N,j)\n\n    # Boundary fluxes (one-sided stencils)\n    compute_boundary_flux!(...)\nend\n\nKey functions:\n\nϕ(i,I,u) — Interpolates velocity component i to face location\nϕu(j,I,u,u_face,λ) — Computes upwind flux using scheme λ (quick, vanLeer, cds)\n∂(j,I,u) — Central difference u^I - u^I-delta_j","category":"section"},{"location":"numerical_methods/#Applying-Fluxes-Conservatively","page":"Numerical Methods","title":"Applying Fluxes Conservatively","text":"# From apply_fluxes! in src/Flow.jl\nfor i ∈ 1:n, j ∈ 1:n\n    F_total = F_conv[I,j,i] + F_diff[I,j,i]\n\n    # Lower boundary: only flux INTO domain\n    @loop r[I,i] += F_total over I ∈ slice(N,2,j,2)\n\n    # Interior: flux enters I, leaves I-δ (CONSERVATIVE!)\n    @loop r[I,i] += F_total over I ∈ inside_u(N,j)\n    @loop r[I-δ(j,I),i] -= F_total over I ∈ inside_u(N,j)\n\n    # Upper boundary: only flux OUT OF domain\n    @loop r[I-δ(j,I),i] -= F_total over I ∈ slice(N,N[j],j,2)\nend","category":"section"},{"location":"numerical_methods/#Enabling-FVM-Mode","page":"Numerical Methods","title":"Enabling FVM Mode","text":"To use explicit flux storage and verification:\n\n# Enable FVM with flux storage\nsim = Simulation((nx, ny), (Lx, Ly);\n                 store_fluxes = true,  # Enable FVM mode\n                 ν = 0.01)\n\n# Run simulation\nsim_step!(sim)\n\n# Access stored fluxes for analysis\nF_conv = sim.flow.F_conv  # Convective fluxes\nF_diff = sim.flow.F_diff  # Diffusive fluxes\n\n# Verify conservation (sum of internal fluxes = 0)\n\nWhen store_fluxes=false (default), the original method is used which computes fluxes on-the-fly without storing them.","category":"section"},{"location":"numerical_methods/#Boundary-Flux-Treatment","page":"Numerical Methods","title":"Boundary Flux Treatment","text":"At domain boundaries, fluxes are handled specially since there's no neighbor cell outside:\n\nBoundary Treatment Stencil\nLower (index 2) One-sided upwind ϕuL\nUpper (index N) One-sided upwind ϕuR\nPeriodic Wrap-around ϕuP\n\n# Lower boundary: use left-biased stencil\nF_conv[I,j,i] = ϕuL(j, I, u, u_face, λ)\n\n# Upper boundary: use right-biased stencil\nF_conv[I,j,i] = ϕuR(j, I, u, u_face, λ)\n\n# Periodic: wrap to opposite boundary\nF_conv[I,j,i] = ϕuP(j, I_wrapped, I, u, u_face, λ)","category":"section"},{"location":"numerical_methods/#Conservation-Verification","page":"Numerical Methods","title":"Conservation Verification","text":"The FVM ensures exact momentum conservation. For a closed system with no external forces:\n\nfracddt sum_I u_i^I cdot Delta V = sum_textboundaries F_i^boundary\n\nInterior fluxes cancel exactly because each internal face contributes:\n\n+F\nto cell I\n-F\nto cell I-delta\n\nThis property is crucial for accurate long-time simulations and proper vortex dynamics.","category":"section"},{"location":"numerical_methods/#Time-Integration","page":"Numerical Methods","title":"Time Integration","text":"BioFlows.jl uses a 2nd-order predictor-corrector (Heun's method) combined with pressure projection to ensure incompressibility. This provides 2nd-order temporal accuracy.","category":"section"},{"location":"numerical_methods/#Predictor-Step","page":"Numerical Methods","title":"Predictor Step","text":"First, compute a forward Euler prediction:\n\nmathbfu^* = mathbfu^n + Delta t left -(mathbfu^n cdot nabla)mathbfu^n + nu nabla^2 mathbfu^n + mathbfg right\n\nThen project onto divergence-free space:\n\nnabla^2 phi = nabla cdot mathbfu^*\n\nmathbfu = mathbfu^* - nabla phi","category":"section"},{"location":"numerical_methods/#Corrector-Step","page":"Numerical Methods","title":"Corrector Step","text":"Re-evaluate the right-hand side at the predicted velocity:\n\nmathbff = -(mathbfu cdot nabla)mathbfu + nu nabla^2 mathbfu + mathbfg\n\nAverage the predictor and corrector contributions (Heun's method):\n\nmathbfu^** = frac12left( mathbfu + mathbfu^n + Delta t  mathbff right)\n\nThis is equivalent to the trapezoidal rule:\n\nmathbfu^** = mathbfu^n + fracDelta t2 left( mathbff^n + mathbff right)\n\nFinally, project onto divergence-free space:\n\nnabla^2 psi = frac2Delta t nabla cdot mathbfu^**\n\nmathbfu^n+1 = mathbfu^** - fracDelta t2 nabla psi","category":"section"},{"location":"numerical_methods/#Summary-of-the-Algorithm","page":"Numerical Methods","title":"Summary of the Algorithm","text":"Algorithm: 2nd-order Predictor-Corrector with Pressure Projection\n─────────────────────────────────────────────────────────────────\nInput: uⁿ (divergence-free velocity at time tⁿ)\nOutput: uⁿ⁺¹ (divergence-free velocity at time tⁿ⁺¹)\n\n1. Save: u⁰ ← uⁿ\n\n2. PREDICTOR:\n   a. f ← RHS(u⁰)                    // Convection + diffusion\n   b. u* ← u⁰ + Δt·f                 // Forward Euler\n   c. Solve ∇²φ = ∇·u*               // Pressure Poisson\n   d. u' ← u* - ∇φ                   // Project to div-free\n\n3. CORRECTOR:\n   a. f' ← RHS(u')                   // Re-evaluate at predicted\n   b. u** ← u' + u⁰ + Δt·f'          // Accumulate\n   c. u** ← 0.5·u**                  // Average (Heun)\n   d. Solve ∇²ψ = (2/Δt)·∇·u**       // Pressure Poisson\n   e. uⁿ⁺¹ ← u** - (Δt/2)·∇ψ        // Final projection\n\n4. Compute Δt from CFL condition","category":"section"},{"location":"numerical_methods/#CFL-Condition","page":"Numerical Methods","title":"CFL Condition","text":"The time step is constrained by the CFL (Courant-Friedrichs-Lewy) condition:\n\nDelta t leq left( sum_d fracu_dDelta x_d + sum_d frac2nuDelta x_d^2 right)^-1\n\nwhere the first term is the convective constraint and the second is the diffusive constraint.","category":"section"},{"location":"numerical_methods/#Pressure-Solver","page":"Numerical Methods","title":"Pressure Solver","text":"The pressure Poisson equation is solved using a geometric multigrid method with:\n\nJacobi smoothing iterations\nFull-weighting restriction\nBilinear interpolation for prolongation\nV-cycle iteration until convergence\n\nThe multigrid solver operates on a hierarchy of progressively coarser grids, enabling efficient solution of the elliptic pressure equation.","category":"section"},{"location":"numerical_methods/#Immersed-Boundary-Method-(BDIM)","page":"Numerical Methods","title":"Immersed Boundary Method (BDIM)","text":"BioFlows.jl implements the Boundary Data Immersion Method (BDIM) for handling complex geometries, including moving and deforming bodies. This section provides the complete mathematical formulation.","category":"section"},{"location":"numerical_methods/#Signed-Distance-Function-(SDF)","page":"Numerical Methods","title":"Signed Distance Function (SDF)","text":"Bodies are defined implicitly through signed distance functions:\n\nphi(mathbfx t)  0 quad textinside body\n\nphi(mathbfx t) = 0 quad texton boundary\n\nphi(mathbfx t)  0 quad textin fluid\n\nThe SDF provides:\n\nDistance to surface: d = phi(mathbfx t)\nSurface normal: mathbfn = nablaphi  nablaphi\nCurvature: kappa = nabla cdot mathbfn","category":"section"},{"location":"numerical_methods/#BDIM-Kernel-Functions","page":"Numerical Methods","title":"BDIM Kernel Functions","text":"The BDIM uses a smooth kernel to transition from fluid to solid over a band of width 2epsilon centered at the body surface. The kernel is a raised cosine:\n\nK(xi) = frac12 + frac12cos(pixi) quad xi in -1 1\n\nwhere xi = depsilon is the normalized distance.","category":"section"},{"location":"numerical_methods/#Zeroth-Moment-(Volume-Fraction)","page":"Numerical Methods","title":"Zeroth Moment (Volume Fraction)","text":"The volume fraction mu_0 represents how much of a cell is fluid:\n\nmu_0(d epsilon) = int_-1^depsilon K(s)  ds = frac12 + fracd2epsilon + frac12pisinleft(fracpi depsilonright)\n\nProperties:\n\nmu_0 = 0\nwhen d leq -epsilon (fully inside solid)\nmu_0 = 1\nwhen d geq +epsilon (fully in fluid)\nmu_0 = 05\nat d = 0 (on surface)","category":"section"},{"location":"numerical_methods/#First-Moment-(Gradient-Correction)","page":"Numerical Methods","title":"First Moment (Gradient Correction)","text":"The first moment mu_1 provides gradient information for boundary layer resolution:\n\nmu_1(d epsilon) = epsilon int_-1^depsilon s cdot K(s)  ds = epsilon left frac14left(1 - fracd^2epsilon^2right) - frac12pi^2left(fracdepsilonsinfracpi depsilon + frac1 + cosfracpi depsilonpiright) right","category":"section"},{"location":"numerical_methods/#BDIM-Velocity-Update","page":"Numerical Methods","title":"BDIM Velocity Update","text":"The BDIM enforces no-slip/no-penetration at immersed boundaries by blending the fluid velocity mathbfu^* with the body velocity mathbfV:\n\nmathbfu = mu_0 cdot mathbff + mathbfV + boldsymbolmu_1 cdot nabla mathbff\n\nwhere the correction field is:\n\nmathbff = mathbfu^0 + Delta t cdot mathbfRHS - mathbfV\n\nand:\n\nmathbfu^0\n= velocity at previous time step\nmathbfRHS\n= convection + diffusion terms\nmathbfV\n= body velocity at each point\nboldsymbolmu_1 = mu_1 cdot mathbfn\n= directional first moment\n\nThis formulation:\n\nSmoothly transitions from fluid velocity to body velocity\nMaintains proper boundary layer behavior\nConserves momentum at the interface","category":"section"},{"location":"numerical_methods/#Reference","page":"Numerical Methods","title":"Reference","text":"Maertens, A.P. and Weymouth, G.D. (2015). \"Accurate Cartesian-grid simulations of near-body flows at intermediate Reynolds numbers.\" Computer Methods in Applied Mechanics and Engineering, 283, 106-129. doi:10.1016/j.cma.2014.09.007","category":"section"},{"location":"numerical_methods/#Flexible-Body-Kinematics","page":"Numerical Methods","title":"Flexible Body Kinematics","text":"BioFlows supports time-varying body geometries through two mechanisms:\n\nCoordinate mapping for rigid body motion (translation, rotation)\nTime-dependent SDF for flexible/deforming bodies","category":"section"},{"location":"numerical_methods/#Coordinate-Mapping-(Rigid-Motion)","page":"Numerical Methods","title":"Coordinate Mapping (Rigid Motion)","text":"For rigid bodies, the SDF shape is fixed but the body moves via a coordinate mapping mathbfm(mathbfx t):\n\nphi(mathbfx t) = phi_0(mathbfm(mathbfx t))\n\nwhere phi_0 is the reference SDF and mathbfm maps world coordinates to body-fixed coordinates.","category":"section"},{"location":"numerical_methods/#Body-Velocity-from-Mapping","page":"Numerical Methods","title":"Body Velocity from Mapping","text":"The body velocity is computed from the coordinate mapping using:\n\nmathbfV = -mathbfJ^-1 cdot fracpartial mathbfmpartial t\n\nwhere mathbfJ = partial mathbfm  partial mathbfx is the Jacobian of the mapping.\n\nDerivation: For a material point boldsymbolxi = mathbfm(mathbfx t) fixed in the body frame, we have DboldsymbolxiDt = 0. Using the chain rule:\n\nfracpartial mathbfmpartial t + mathbfJ cdot dotmathbfx = 0\n\nSolving for the velocity dotmathbfx = mathbfV:\n\nmathbfV = -mathbfJ^-1 cdot fracpartial mathbfmpartial t","category":"section"},{"location":"numerical_methods/#Examples","page":"Numerical Methods","title":"Examples","text":"Oscillating Cylinder (vertical sinusoidal motion):\n\nmathbfm(mathbfx t) = mathbfx - beginpmatrix 0  Asin(omega t) endpmatrix\n\nBody velocity:\n\nmathbfV = beginpmatrix 0  Aomegacos(omega t) endpmatrix\n\nRotating Body (angular velocity Omega):\n\nmathbfm(mathbfx t) = mathbfR(-Omega t) cdot (mathbfx - mathbfx_c)\n\nwhere mathbfR(theta) is the rotation matrix and mathbfx_c is the center of rotation.","category":"section"},{"location":"numerical_methods/#Time-Dependent-SDF-(Flexible-Bodies)","page":"Numerical Methods","title":"Time-Dependent SDF (Flexible Bodies)","text":"For flexible bodies where the shape itself changes over time, the SDF is directly time-dependent:\n\nphi = phi(mathbfx t)\n\nThe surface normal is computed as:\n\nmathbfn = fracnabla phinabla phi\n\nFor pseudo-SDFs (implicit functions where nabla phi neq 1), the distance is corrected:\n\nd = fracphinabla phi","category":"section"},{"location":"numerical_methods/#Fluid-Structure-Interaction-(FSI)","page":"Numerical Methods","title":"Fluid-Structure Interaction (FSI)","text":"BioFlows implements true fluid-structure interaction using the Euler-Bernoulli beam equation coupled with the incompressible Navier-Stokes equations. This allows simulation of passive flexible bodies whose deformation is computed from fluid forces, not prescribed.","category":"section"},{"location":"numerical_methods/#Euler-Bernoulli-Beam-Equation","page":"Numerical Methods","title":"Euler-Bernoulli Beam Equation","text":"The governing equation for a flexible beam is:\n\nrho_s A fracpartial^2 wpartial t^2 + c fracpartial wpartial t + EI fracpartial^4 wpartial x^4 - T fracpartial^2 wpartial x^2 = q(x t) + f_active(x t)\n\nwhere:\n\nSymbol Description Units\nrho_s Beam material density kg/m³\nA Cross-sectional area m²\nc Damping coefficient kg/(m·s)\nE Young's modulus Pa\nI Second moment of area m⁴\nT Axial tension N\nw(x t) Transverse displacement m\nq(x t) Distributed fluid load N/m\nf_active(x t) Active forcing (muscle) N/m","category":"section"},{"location":"numerical_methods/#Physical-Interpretation","page":"Numerical Methods","title":"Physical Interpretation","text":"Each term represents a physical effect:\n\nInertia: rho_s A  partial^2 wpartial t^2 — mass times acceleration\nDamping: c  partial wpartial t — viscous resistance to motion\nBending: EI  partial^4 wpartial x^4 — resistance to curvature\nTension: -T  partial^2 wpartial x^2 — stiffening from axial load\nFluid load: q(x t) — pressure forces from surrounding fluid\nActive forcing: f_active(x t) — muscle activation for swimming","category":"section"},{"location":"numerical_methods/#Boundary-Conditions","page":"Numerical Methods","title":"Boundary Conditions","text":"The beam supports several boundary condition types:\n\nType Conditions Physical Meaning\nClamped w = 0  w = 0 Fixed position and slope\nFree w = 0  w = 0 No moment, no shear\nPinned w = 0  w = 0 Fixed position, free rotation\nPrescribed w = w_p(t) Time-varying position\n\nFor a fish-like body:\n\nHead (left): Clamped or prescribed motion\nTail (right): Free","category":"section"},{"location":"numerical_methods/#Two-Way-Coupling","page":"Numerical Methods","title":"Two-Way Coupling","text":"The FSI coupling is bidirectional:","category":"section"},{"location":"numerical_methods/#1.-Fluid-Structure","page":"Numerical Methods","title":"1. Fluid → Structure","text":"The fluid exerts pressure forces on the beam:\n\nq(s) = oint p(mathbfx)  mathbfn cdot mathbfe_z  dell approx Delta p(s) cdot b(s)\n\nwhere:\n\nDelta p = p_below - p_above\nis the pressure difference across the body\nb(s)\nis the local body width","category":"section"},{"location":"numerical_methods/#2.-Structure-Fluid","page":"Numerical Methods","title":"2. Structure → Fluid","text":"The beam deformation updates the body geometry:\n\nphi(mathbfx t) = z - z_body(x t) - h(s)\n\nwhere z_body(x t) = z_center + w(s t) is the deformed centerline.","category":"section"},{"location":"numerical_methods/#Numerical-Discretization","page":"Numerical Methods","title":"Numerical Discretization","text":"","category":"section"},{"location":"numerical_methods/#Hermite-Finite-Element-Method","page":"Numerical Methods","title":"Hermite Finite Element Method","text":"BioFlows uses Hermite cubic finite elements for accurate beam dynamics. Each node has two degrees of freedom:\n\nDOF Symbol Description\nDisplacement w_i Transverse deflection at node i\nRotation theta_i Slope partial wpartial x at node i\n\nThe state vector for n nodes is:\n\nmathbfu = w_1 theta_1 w_2 theta_2 ldots w_n theta_n^T in mathbbR^2n","category":"section"},{"location":"numerical_methods/#Element-Matrices","page":"Numerical Methods","title":"Element Matrices","text":"For element e connecting nodes i and i+1 with length h:\n\nElement Stiffness Matrix (bending):\n\nmathbfK^e = fracEIh^3 beginbmatrix\n12  6h  -12  6h \n6h  4h^2  -6h  2h^2 \n-12  -6h  12  -6h \n6h  2h^2  -6h  4h^2\nendbmatrix\n\nElement Mass Matrix (consistent mass):\n\nmathbfM^e = fracrho A h420 beginbmatrix\n156  22h  54  -13h \n22h  4h^2  13h  -3h^2 \n54  13h  156  -22h \n-13h  -3h^2  -22h  4h^2\nendbmatrix\n\nGeometric Stiffness (for tension T):\n\nmathbfK_g^e = fracT30h beginbmatrix\n36  3h  -36  3h \n3h  4h^2  -3h  -h^2 \n-36  -3h  36  -3h \n3h  -h^2  -3h  4h^2\nendbmatrix","category":"section"},{"location":"numerical_methods/#Global-Assembly","page":"Numerical Methods","title":"Global Assembly","text":"Element matrices are assembled into global system matrices mathbfM, mathbfC, mathbfK by summing contributions at shared nodes. The semi-discrete equation becomes:\n\nmathbfM ddotmathbfu + mathbfC dotmathbfu + mathbfK mathbfu = mathbfF(t)","category":"section"},{"location":"numerical_methods/#Boundary-Conditions-2","page":"Numerical Methods","title":"Boundary Conditions","text":"Boundary conditions are enforced using the penalty method:\n\nK_ii leftarrow K_ii + alpha quad F_i leftarrow alpha cdot u_prescribed\n\nwhere alpha sim 10^8 cdot max(K_ij) is a large penalty parameter.\n\nBC Type Constrained DOFs\nClamped w_i = 0, theta_i = 0\nPinned w_i = 0\nFree None","category":"section"},{"location":"numerical_methods/#Time-Integration-(Newmark-Beta)","page":"Numerical Methods","title":"Time Integration (Newmark-Beta)","text":"The Newmark-beta method provides unconditionally stable time integration:\n\nmathbfu_n+1 = mathbfu_n + Delta t  dotmathbfu_n + Delta t^2 left left(frac12 - betaright) ddotmathbfu_n + beta  ddotmathbfu_n+1 right\n\ndotmathbfu_n+1 = dotmathbfu_n + Delta t left (1 - gamma) ddotmathbfu_n + gamma  ddotmathbfu_n+1 right\n\nWith beta = 025 and gamma = 05 (average acceleration method), the scheme is:\n\nUnconditionally stable for any time step\nSecond-order accurate in time\nNo numerical damping (energy conserving)","category":"section"},{"location":"numerical_methods/#Effective-Stiffness-Formulation","page":"Numerical Methods","title":"Effective Stiffness Formulation","text":"At each time step, solve:\n\nmathbfK_eff  mathbfu_n+1 = mathbfF_eff\n\nwhere:\n\nmathbfK_eff = mathbfK + fracgammabeta Delta t mathbfC + frac1beta Delta t^2 mathbfM\n\nmathbfF_eff = mathbfF_n+1 + mathbfM left( frac1beta Delta t^2 mathbfu_n + frac1beta Delta t dotmathbfu_n + left(frac12beta - 1right) ddotmathbfu_n right) + mathbfC left( fracgammabeta Delta t mathbfu_n + left(fracgammabeta - 1right) dotmathbfu_n + fracDelta t2 left(fracgammabeta - 2right) ddotmathbfu_n right)","category":"section"},{"location":"numerical_methods/#Verification-Results","page":"Numerical Methods","title":"Verification Results","text":"The Hermite FEM implementation has been verified against analytical solutions:\n\nTest Case Analytical Numerical Error\nCantilever (uniform load) w_tip = qL^4(8EI) Computed < 8%\nCantilever (point load) w_tip = PL^3(3EI) Computed < 1%\nNatural frequency f_1 = 1875^2 sqrtEI(rho A L^4)(2pi) Computed < 1%\nEnergy conservation E_total = const Computed < 1%","category":"section"},{"location":"numerical_methods/#Adaptive-Mesh-Refinement-for-Flexible-Bodies","page":"Numerical Methods","title":"Adaptive Mesh Refinement for Flexible Bodies","text":"BioFlows supports adaptive mesh refinement (AMR) that automatically follows flexible bodies as they deform during simulation. This ensures high resolution near the moving body surface while keeping computational cost low in far-field regions.","category":"section"},{"location":"numerical_methods/#FlexibleBodySDF","page":"Numerical Methods","title":"FlexibleBodySDF","text":"The FlexibleBodySDF creates a time-dependent signed distance function from the beam state:\n\nbeam_sdf = FlexibleBodySDF(beam, x_head, z_center;\n                           thickness_func=s -> beam.geometry.thickness(s),\n                           width=0.01)\n\nThe SDF automatically updates as the beam deforms:\n\nNegative values: inside the body\nPositive values: outside the body\nZero: on the body surface","category":"section"},{"location":"numerical_methods/#AMR-Configuration","page":"Numerical Methods","title":"AMR Configuration","text":"Configure AMR behavior with BeamAMRConfig:\n\nconfig = BeamAMRConfig(\n    max_level=2,                    # Maximum refinement level (2=4x)\n    beam_distance_threshold=3.0,    # Refine within 3 cells of beam\n    gradient_threshold=1.0,         # Velocity gradient threshold\n    vorticity_threshold=1.0,        # Vorticity threshold\n    beam_weight=0.6,                # Weight for beam proximity\n    gradient_weight=0.25,           # Weight for velocity gradients\n    vorticity_weight=0.15,          # Weight for vorticity\n    buffer_size=2,                  # Buffer cells around refined region\n    min_regrid_interval=5,          # Minimum steps between regrids\n    motion_threshold=0.5,           # Displacement change to trigger regrid\n    regrid_interval=10              # Force regrid every N steps\n)","category":"section"},{"location":"numerical_methods/#Motion-Triggered-Regridding","page":"Numerical Methods","title":"Motion-Triggered Regridding","text":"The BeamAMRTracker monitors beam motion and triggers regridding when the beam moves significantly:\n\ntracker = BeamAMRTracker(beam_sdf)\n\n# In simulation loop\nfor step in 1:n_steps\n    # Advance beam\n    step!(beam, dt)\n\n    # Check if regrid needed\n    if should_regrid(tracker, step; min_interval=5, motion_threshold=0.5)\n        # Perform regridding\n        regrid_for_beam!(amr_sim, beam_sdf, tracker, step, config)\n    end\nend","category":"section"},{"location":"numerical_methods/#Combined-Refinement-Indicator","page":"Numerical Methods","title":"Combined Refinement Indicator","text":"The refinement decision combines three criteria:\n\nI_combined = w_b I_beam + w_g I_gradient + w_v I_vorticity\n\nwhere:\n\nI_beam\n: 1 if within beam_distance_threshold of beam surface\nI_gradient\n: 1 if velocity gradient exceeds threshold\nI_vorticity\n: 1 if vorticity magnitude exceeds threshold\nw_b w_g w_v\n: configurable weights (default: 0.6, 0.25, 0.15)","category":"section"},{"location":"numerical_methods/#Example:-Swimming-Fish-with-AMR","page":"Numerical Methods","title":"Example: Swimming Fish with AMR","text":"using BioFlows\n\n# Create flexible beam (fish body)\nmaterial = BeamMaterial(ρ=1050.0, E=5e5)\nL = 0.2\nh_func = fish_thickness_profile(L, 0.02)\ngeometry = BeamGeometry(L, 51; thickness=h_func, width=0.02)\n\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED, bc_right=FREE,\n                          damping=0.5)\n\n# Create body and SDF from beam\nbody, beam_sdf = create_beam_body(beam, 0.2, 0.5)\n\n# Create AMR simulation\namr_config = AMRConfig(\n    max_level=2,\n    body_distance_threshold=3.0,\n    flexible_body=true,\n    indicator_change_threshold=0.1\n)\n\nsim = AMRSimulation((256, 128), (2.0, 1.0);\n                    body=body,\n                    amr_config=amr_config,\n                    ν=0.001)\n\n# Create tracker for motion-based regridding\ntracker = BeamAMRTracker(beam_sdf)\nflex_config = BeamAMRConfig(max_level=2, beam_weight=0.7)\n\n# Traveling wave forcing\nf_wave = traveling_wave_forcing(amplitude=100.0, frequency=2.0,\n                                wavelength=1.0, envelope=:carangiform, L=L)\n\n# Simulation loop\ndt = 1e-4\nfor step in 1:10000\n    t = step * dt\n\n    # Advance beam\n    set_active_forcing!(beam, f_wave, t)\n    step!(beam, dt)\n\n    # Update body SDF\n    update!(beam_sdf)\n\n    # Advance flow with remeasure for moving body\n    sim_step!(sim; remeasure=true)\n\n    # Check for regrid\n    if should_regrid(tracker, step; motion_threshold=0.5)\n        regrid_for_beam!(sim, beam_sdf, tracker, step, flex_config)\n        println(\"Regrid at step $step\")\n    end\nend","category":"section"},{"location":"numerical_methods/#Utility-Functions","page":"Numerical Methods","title":"Utility Functions","text":"Function Description\ncreate_beam_body(beam, x, z) Create AutoBody from beam\nupdate!(beam_sdf) Update SDF with current beam state\nget_beam_bounding_box(sdf) Get current bounding box\nshould_regrid(tracker, step) Check if regrid needed\nmark_regrid!(tracker, step) Mark that regrid occurred\ncompute_beam_refinement_indicator(flow, sdf) Compute beam-only indicator\ncompute_beam_combined_indicator(flow, sdf) Compute weighted combined indicator","category":"section"},{"location":"numerical_methods/#BeamAMRSimulation","page":"Numerical Methods","title":"BeamAMRSimulation","text":"For fully integrated beam-fluid simulations with AMR, use BeamAMRSimulation:\n\nusing BioFlows\n\n# Create beam\nmaterial = BeamMaterial(ρ=1050.0, E=5e5)\ngeometry = BeamGeometry(0.2, 51; thickness=fish_thickness_profile(0.2, 0.02))\nbeam = EulerBernoulliBeam(geometry, material; bc_left=CLAMPED, bc_right=FREE)\n\n# AMR configuration\nconfig = BeamAMRConfig(\n    max_level=2,\n    beam_distance_threshold=4.0,\n    beam_weight=0.7,\n    min_regrid_interval=10,\n    motion_threshold=0.002\n)\n\n# Create integrated simulation\nsim = BeamAMRSimulation((256, 128), (2.0, 1.0), beam, 0.4, 0.5;\n                         config=config, ν=0.001, U=1.0)\n\n# Set active forcing\nf_wave = traveling_wave_forcing(amplitude=100.0, frequency=2.0)\nset_forcing!(sim, f_wave)\n\n# Run simulation - beam and fluid are coupled automatically\nfor step in 1:1000\n    sim_step!(sim)\nend\n\n# Get status\nbeam_info(sim)\n\nThe BeamAMRSimulation automatically:\n\nAdvances beam dynamics with the specified dt_beam\nUpdates the body SDF with the deformed beam shape\nTriggers AMR regridding when the beam moves significantly\nAdvances the fluid with the updated body position\nCouples forces between beam and fluid (when enabled)","category":"section"},{"location":"numerical_methods/#Convenience-Constructor","page":"Numerical Methods","title":"Convenience Constructor","text":"For quick setup of swimming fish simulations:\n\n# Create ready-to-run swimming fish with AMR\nsim = swimming_fish_simulation(\n    L_fish = 0.2,           # Fish length\n    Re = 1000,              # Reynolds number\n    St = 0.3,               # Strouhal number\n    grid_size = (256, 128), # Base grid\n    domain = (2.0, 1.0)     # Domain size\n)\n\n# Run\nfor step in 1:10000\n    sim_step!(sim)\nend","category":"section"},{"location":"numerical_methods/#Active-Forcing-for-Swimming","page":"Numerical Methods","title":"Active Forcing for Swimming","text":"","category":"section"},{"location":"numerical_methods/#Traveling-Wave-Muscle-Activation","page":"Numerical Methods","title":"Traveling Wave Muscle Activation","text":"To simulate active swimming, apply a traveling wave force:\n\nf_active(s t) = A_muscle(s) sin(ks - omega t)\n\nwhere the amplitude envelope A_muscle(s) follows the swimming mode:\n\nMode Envelope Description\nCarangiform A(s) = A_0 (sL)^2 Tail-dominated\nAnguilliform A(s) = A_0 (03 + 07 sL) Whole-body\nSubcarangiform A(s) = A_0 (sL)^15 Intermediate","category":"section"},{"location":"numerical_methods/#Heave-Pitch-Forcing","page":"Numerical Methods","title":"Heave + Pitch Forcing","text":"For leading-edge oscillation:\n\nf_active(s t) = f_heave(s t) + f_pitch(s t)\n\nwhere:\n\nf_heave = A_heave exp(-(sL)^2001) sin(omega t + phi_heave)\n— concentrated at head\nf_pitch = A_pitch (sL) exp(-(sL)^201) sin(omega t + phi_pitch)\n— moment at head","category":"section"},{"location":"numerical_methods/#Fish-Body-Geometry","page":"Numerical Methods","title":"Fish Body Geometry","text":"The fish body uses a NACA-like thickness profile:\n\nh(s) = h_max cdot 4 fracsL left(1 - fracsLright)\n\nThis gives:\n\nZero thickness at head (s=0) and tail (s=L)\nMaximum thickness at mid-body (s=L2)","category":"section"},{"location":"numerical_methods/#Dimensionless-Parameters","page":"Numerical Methods","title":"Dimensionless Parameters","text":"","category":"section"},{"location":"numerical_methods/#Strouhal-Number","page":"Numerical Methods","title":"Strouhal Number","text":"St = fracf cdot A_tailU\n\nOptimal swimming: St approx 02 - 04","category":"section"},{"location":"numerical_methods/#Reynolds-Number","page":"Numerical Methods","title":"Reynolds Number","text":"Re = fracU cdot Lnu","category":"section"},{"location":"numerical_methods/#Cauchy-Number-(Flexibility)","page":"Numerical Methods","title":"Cauchy Number (Flexibility)","text":"Ca = fracrho_f U^2 L^3EI\n\nCa ll 1\n: Rigid body (bending dominates)\nCa gg 1\n: Highly flexible (fluid forces dominate)","category":"section"},{"location":"numerical_methods/#Mass-Ratio","page":"Numerical Methods","title":"Mass Ratio","text":"m^* = fracrho_srho_f\n\nm^* ll 1\n: Light structure (strong FSI effects)\nm^* gg 1\n: Heavy structure (weak FSI effects)","category":"section"},{"location":"numerical_methods/#FSI-Coupling-Algorithm","page":"Numerical Methods","title":"FSI Coupling Algorithm","text":"Algorithm: Two-Way FSI Coupling\n───────────────────────────────────────────────\nInput: Flow state uⁿ, pⁿ; Beam state wⁿ, ẇⁿ\nOutput: Flow state uⁿ⁺¹, pⁿ⁺¹; Beam state wⁿ⁺¹, ẇⁿ⁺¹\n\n1. FLUID STEP:\n   a. Update body SDF from wⁿ\n   b. Measure body (compute μ₀, μ₁, V)\n   c. Advance flow: mom_step!(flow, poisson)\n   d. Output: uⁿ⁺¹, pⁿ⁺¹\n\n2. STRUCTURE STEP:\n   For iter = 1 to max_iterations:\n     a. Compute fluid load: q ← integrate(pⁿ⁺¹)\n     b. Set active forcing: f_active ← muscle(s, t)\n     c. Advance beam: Newmark-beta step\n     d. Under-relax: w ← ω·w_new + (1-ω)·w_old\n     e. Check convergence: |w - w_old| < tol ?\n   Output: wⁿ⁺¹, ẇⁿ⁺¹\n\n3. Update time: t ← t + Δt","category":"section"},{"location":"numerical_methods/#Example:-Passive-Flag-in-Flow","page":"Numerical Methods","title":"Example: Passive Flag in Flow","text":"using BioFlows\n\n# Material: flexible rubber sheet\nmaterial = BeamMaterial(ρ=1100.0, E=1e6)\n\n# Geometry: thin flag\ngeometry = BeamGeometry(L=0.2, n=51; thickness=0.002, width=0.1)\n\n# Beam: clamped at leading edge, free at trailing edge\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED, bc_right=FREE,\n                          damping=0.1)\n\n# Create FSI simulation\nsim = FSISimulation((256, 128), (1.0, 0.5);\n                    beam=beam,\n                    x_head=0.2, z_center=0.25,\n                    ν=0.001, ρ=1000.0,\n                    inletBC=(1.0, 0.0))\n\n# Run simulation\nfor step in 1:1000\n    sim_step!(sim)\nend","category":"section"},{"location":"numerical_methods/#Example:-Active-Swimming-Fish","page":"Numerical Methods","title":"Example: Active Swimming Fish","text":"using BioFlows\n\n# Material: fish tissue\nmaterial = BeamMaterial(ρ=1050.0, E=5e5)\n\n# Geometry: fish-like profile\nL = 0.2  # Fish length\nh_func = fish_thickness_profile(L, 0.02)\ngeometry = BeamGeometry(L, 51; thickness=h_func, width=0.02)\n\n# Active forcing: carangiform swimming\nf_active = traveling_wave_forcing(\n    amplitude=100.0,    # N/m\n    frequency=2.0,      # Hz\n    wavelength=1.0,     # Body lengths\n    envelope=:carangiform,\n    L=L\n)\n\n# Create FSI simulation with muscle activation\nsim = FSISimulation((256, 128), (1.0, 0.5);\n                    beam=beam,\n                    active_forcing=f_active,\n                    x_head=0.2, z_center=0.25,\n                    ν=0.001, ρ=1000.0)\n\n# Run simulation\nfor step in 1:1000\n    sim_step!(sim)\n\n    # Monitor energy\n    KE = kinetic_energy(get_beam(sim))\n    PE = potential_energy(get_beam(sim))\n    println(\"Step $step: KE=$KE, PE=$PE\")\nend","category":"section"},{"location":"numerical_methods/#Beam-State-Output","page":"Numerical Methods","title":"Beam State Output","text":"BioFlows provides BeamStateWriter for saving flexible body positions to JLD2 files with configurable save rates. Each beam/flag can have its own separate output file.","category":"section"},{"location":"numerical_methods/#BeamStateWriter","page":"Numerical Methods","title":"BeamStateWriter","text":"The BeamStateWriter records beam state at specified time intervals:\n\nBeamStateWriter(filename::String; interval::Real=0.01, overwrite::Bool=true)\n\nParameter Description Default\nfilename Output JLD2 file path Required\ninterval Time interval between saves 0.01\noverwrite Overwrite existing file true\n\nSaved Data:\n\nField Description Shape\ndisplacement Transverse displacement w(s) (n n_snap)\nrotation Rotation angle theta(s) = partial wpartial s (n n_snap)\nvelocity Velocity dotw(s) (n n_snap)\ncurvature Curvature kappa(s) = partialthetapartial s (n n_snap)\nmoment Bending moment M(s) = EIkappa (n n_snap)\nkinetic_energy Kinetic energy time series (n_snap)\npotential_energy Potential energy time series (n_snap)","category":"section"},{"location":"numerical_methods/#Single-Beam-Output","page":"Numerical Methods","title":"Single Beam Output","text":"using BioFlows\n\n# Create beam\nmaterial = BeamMaterial(ρ=1100.0, E=1e6)\ngeometry = BeamGeometry(0.2, 51; thickness=0.01, width=0.05)\nbeam = EulerBernoulliBeam(geometry, material;\n                          bc_left=CLAMPED, bc_right=FREE)\n\n# Create writer with 0.01 time unit interval\nwriter = BeamStateWriter(\"flag_simulation.jld2\"; interval=0.01)\n\n# Simulation loop\ndt = 1e-4\nfor step in 1:10000\n    t = step * dt\n    fill!(beam.q, 50.0)  # Apply load\n    step!(beam, dt)\n    file_save!(writer, beam, t)\nend\n\n# IMPORTANT: Must close writer to save data to file\nclose!(writer, beam)","category":"section"},{"location":"numerical_methods/#Multiple-Beams-(Separate-Files)","page":"Numerical Methods","title":"Multiple Beams (Separate Files)","text":"For simulations with multiple flexible bodies, use BeamStateWriterGroup to create one file per beam:\n\nusing BioFlows\n\n# Create multiple beams with different properties\nn_flags = 5\nbeams = [\n    EulerBernoulliBeam(\n        BeamGeometry(0.2, 51; thickness=0.01, width=0.05),\n        BeamMaterial(ρ=1100.0, E=1e6 * i);  # Varying stiffness\n        bc_left=CLAMPED, bc_right=FREE\n    ) for i in 1:n_flags\n]\n\n# Create writer group - generates flag_1.jld2, flag_2.jld2, etc.\nwriters = BeamStateWriterGroup(\"flag\", n_flags; interval=0.01)\n\n# Simulation loop\ndt = 1e-4\nfor step in 1:10000\n    t = step * dt\n    for beam in beams\n        step!(beam, dt)\n    end\n    file_save!(writers, beams, t)  # Save all beams at once\nend\n\n# Close all writers\nclose!(writers, beams)","category":"section"},{"location":"numerical_methods/#JLD2-File-Structure","page":"Numerical Methods","title":"JLD2 File Structure","text":"The output JLD2 file has the following hierarchical structure:\n\nbeam_state.jld2\n├── metadata/\n│   ├── n_snapshots      # Total number of saved snapshots\n│   ├── interval         # Time interval between saves\n│   ├── n_nodes          # Number of beam nodes\n│   └── length           # Beam length L\n├── coordinates/\n│   └── s                # Arc-length coordinates [0, L]\n├── material/\n│   ├── density          # Material density ρ\n│   └── youngs_modulus   # Young's modulus E\n├── time                 # Time array [t₁, t₂, ..., tₙ]\n├── kinetic_energy       # KE time series\n├── potential_energy     # PE time series\n├── fields/              # Matrices (n_nodes × n_snapshots)\n│   ├── displacement     # w(s, t)\n│   ├── rotation         # θ(s, t)\n│   ├── velocity         # ẇ(s, t)\n│   └── curvature        # κ(s, t)\n└── snapshots/           # Individual snapshot groups\n    ├── 1/\n    │   ├── time\n    │   ├── displacement\n    │   ├── rotation\n    │   ├── velocity\n    │   ├── curvature\n    │   └── moment\n    ├── 2/\n    │   └── ...\n    └── ...","category":"section"},{"location":"numerical_methods/#Reading-Beam-State-Data","page":"Numerical Methods","title":"Reading Beam State Data","text":"using JLD2\n\njldopen(\"flag_simulation.jld2\", \"r\") do file\n    # Read metadata\n    n_snapshots = file[\"metadata/n_snapshots\"]\n    n_nodes = file[\"metadata/n_nodes\"]\n    L = file[\"metadata/length\"]\n    println(\"Loaded $n_snapshots snapshots, $n_nodes nodes, L=$L m\")\n\n    # Read coordinates\n    s = file[\"coordinates/s\"]\n\n    # Read time series\n    t = file[\"time\"]\n    KE = file[\"kinetic_energy\"]\n    PE = file[\"potential_energy\"]\n\n    # Read field matrices (efficient for analysis)\n    w = file[\"fields/displacement\"]  # Shape: (n_nodes, n_snapshots)\n    θ = file[\"fields/rotation\"]\n    κ = file[\"fields/curvature\"]\n\n    # Compute tip displacement over time\n    w_tip = w[end, :]\n    println(\"Max tip displacement: $(maximum(abs.(w_tip)) * 1000) mm\")\n\n    # Read individual snapshot\n    w_50 = file[\"snapshots/50/displacement\"]\n    M_50 = file[\"snapshots/50/moment\"]\nend","category":"section"},{"location":"numerical_methods/#Post-Processing-Example","page":"Numerical Methods","title":"Post-Processing Example","text":"using JLD2\nusing Plots\n\n# Load data\ndata = load(\"flag_simulation.jld2\")\nt = data[\"time\"]\ns = data[\"coordinates/s\"]\nw = data[\"fields/displacement\"]\nKE = data[\"kinetic_energy\"]\nPE = data[\"potential_energy\"]\n\n# Plot 1: Energy over time\np1 = plot(t, KE, label=\"Kinetic\", xlabel=\"Time (s)\", ylabel=\"Energy (J)\")\nplot!(p1, t, PE, label=\"Potential\")\nplot!(p1, t, KE .+ PE, label=\"Total\", linestyle=:dash)\n\n# Plot 2: Beam shape at different times\np2 = plot(xlabel=\"Arc length s (m)\", ylabel=\"Displacement w (m)\")\nfor i in [1, 10, 50, 100]\n    plot!(p2, s, w[:, i], label=\"t=$(round(t[i], digits=3))\")\nend\n\n# Plot 3: Tip displacement over time\np3 = plot(t, w[end, :] * 1000,\n          xlabel=\"Time (s)\", ylabel=\"Tip displacement (mm)\",\n          legend=false)\n\n# Combine plots\nplot(p1, p2, p3, layout=(3, 1), size=(600, 800))\nsavefig(\"beam_analysis.png\")","category":"section"},{"location":"numerical_methods/#Boundary-Conditions-3","page":"Numerical Methods","title":"Boundary Conditions","text":"BioFlows.jl supports three types of boundary conditions for the domain boundaries (not to be confused with immersed body boundaries handled by BDIM).","category":"section"},{"location":"numerical_methods/#Domain-Boundary-Overview","page":"Numerical Methods","title":"Domain Boundary Overview","text":"                    Top boundary (j = nz)\n                    ─────────────────────\n                    │                   │\n                    │                   │\n    Inlet           │                   │    Outlet\n    (i = 1)         │     Domain        │    (i = nx)\n    inletBC         │                   │    outletBC\n                    │                   │\n                    │                   │\n                    ─────────────────────\n                    Bottom boundary (j = 1)","category":"section"},{"location":"numerical_methods/#1.-Inlet-Boundary-Condition-(inletBC)","page":"Numerical Methods","title":"1. Inlet Boundary Condition (inletBC)","text":"The inlet boundary (at x = 0) uses a Dirichlet condition where velocity is prescribed.","category":"section"},{"location":"numerical_methods/#Constant-Inlet","page":"Numerical Methods","title":"Constant Inlet","text":"For uniform inflow, specify a tuple:\n\ninletBC = (U, 0.0)  # u = U, v = 0 at inlet\n\nThis sets:\n\nu(0 y t) = U quad v(0 y t) = 0","category":"section"},{"location":"numerical_methods/#Spatially-Varying-Inlet","page":"Numerical Methods","title":"Spatially-Varying Inlet","text":"For non-uniform profiles (e.g., parabolic channel flow), use a function:\n\n# Parabolic profile: u(y) = U_max * (1 - (y-H)²/H²)\nH = Ly / 2  # channel half-height\nU_max = 1.5\ninletBC(i, x, t) = i == 1 ? U_max * (1 - ((x[2] - H) / H)^2) : 0.0\n\nThe function signature is inletBC(i, x, t) where:\n\ni = velocity component (1 = x, 2 = y/z)\nx = position vector\nt = time","category":"section"},{"location":"numerical_methods/#Time-Varying-Inlet","page":"Numerical Methods","title":"Time-Varying Inlet","text":"For pulsatile or oscillating inflow:\n\n# Oscillating inlet: u(t) = U₀(1 + A·sin(ωt))\ninletBC(i, x, t) = i == 1 ? U₀ * (1 + 0.1*sin(2π*t)) : 0.0\n\nnote: Velocity Scale Required\nWhen using a function for inletBC, you must specify U (velocity scale) explicitly since it cannot be auto-computed.","category":"section"},{"location":"numerical_methods/#2.-Convective-Outlet-Boundary-Condition-(outletBC)","page":"Numerical Methods","title":"2. Convective Outlet Boundary Condition (outletBC)","text":"The outlet boundary (at x = L_x) is the most challenging because we don't know the flow state there in advance. Simple conditions like zero-gradient (partial upartial x = 0) cause spurious reflections — pressure waves bounce back into the domain and contaminate the solution.","category":"section"},{"location":"numerical_methods/#The-Convective-BC-Approach","page":"Numerical Methods","title":"The Convective BC Approach","text":"The convective (or advective) outlet condition assumes flow structures are transported out of the domain at a convection velocity U_c:\n\nfracpartial upartial t + U_c fracpartial upartial x = 0\n\nThis is a 1D wave equation that advects the local velocity pattern out of the domain.","category":"section"},{"location":"numerical_methods/#Discretization","page":"Numerical Methods","title":"Discretization","text":"Using first-order upwind differencing:\n\nu_i^n+1 = u_i^n - U_c Delta t fracu_i^n - u_i-1^nDelta x\n\nIn BioFlows, U_c is taken as the mean inlet velocity to ensure mass conservation.","category":"section"},{"location":"numerical_methods/#Mass-Conservation-Correction","page":"Numerical Methods","title":"Mass Conservation Correction","text":"After applying the convective BC, a correction ensures global mass conservation:\n\noint u  dA = 0 quad text(for incompressible flow)\n\nThe outlet velocity is adjusted so that mass flux out equals mass flux in:\n\n# From src/util.jl - exitBC!\nU = mean(u_inlet)           # Average inlet flux\nu_outlet = u_outlet - Δt * U * ∂u/∂x  # Convective update\ncorrection = mean(u_outlet) - U       # Mass imbalance\nu_outlet = u_outlet - correction      # Enforce conservation","category":"section"},{"location":"numerical_methods/#Why-Convective-BC-Works","page":"Numerical Methods","title":"Why Convective BC Works","text":"Without Convective BC:              With Convective BC:\n\n    ────────────────────┐              ────────────────────→\n    Vortex → → → ↩ ↩ ↩  │              Vortex → → → → → →\n    ────────────────────┘              ────────────────────→\n                ↑                                  ↑\n          Reflection!                      Passes through\n\nThe convective BC allows vortices, wakes, and other flow structures to exit smoothly without generating artificial reflections.","category":"section"},{"location":"numerical_methods/#Usage","page":"Numerical Methods","title":"Usage","text":"sim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (1.0, 0.0),\n                 outletBC = true)      # Enable convective outlet","category":"section"},{"location":"numerical_methods/#3.-Periodic-Boundary-Condition-(perdir)","page":"Numerical Methods","title":"3. Periodic Boundary Condition (perdir)","text":"Periodic boundaries make the domain wrap around — flow exiting one side re-enters from the opposite side.\n\nu(x 0 t) = u(x L_y t) quad v(x 0 t) = v(x L_y t)","category":"section"},{"location":"numerical_methods/#When-to-Use-Periodic-BC","page":"Numerical Methods","title":"When to Use Periodic BC","text":"Scenario Direction Example\nInfinite span z (spanwise) Flow past cylinder\nChannel flow x (streamwise) Fully-developed pipe flow\nHomogeneous turbulence All Isotropic turbulence box","category":"section"},{"location":"numerical_methods/#Usage-2","page":"Numerical Methods","title":"Usage","text":"# Periodic in z-direction (direction 2)\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (1.0, 0.0),\n                 perdir = (2,))\n\n# Periodic in both y and z (3D)\nsim = Simulation((nx, ny, nz), (Lx, Ly, Lz);\n                 inletBC = (1.0, 0.0, 0.0),\n                 perdir = (2, 3))","category":"section"},{"location":"numerical_methods/#4.-Default-(No-Flux)-Boundaries","page":"Numerical Methods","title":"4. Default (No-Flux) Boundaries","text":"Boundaries not explicitly set use a zero normal gradient (Neumann) condition:\n\nfracpartial upartial n = 0\n\nThis is appropriate for:\n\nSlip walls (free-slip, no penetration)\nSymmetry planes\nFar-field boundaries (approximate)","category":"section"},{"location":"numerical_methods/#Boundary-Condition-Summary","page":"Numerical Methods","title":"Boundary Condition Summary","text":"Parameter Condition Mathematical Form Use Case\ninletBC Dirichlet u = u_prescribed Inflow boundaries\noutletBC=true Convective partial_t u + U partial_x u = 0 Outflow (prevents reflections)\nperdir=(d,) Periodic u(0) = u(L) Infinite/repeating domains\n(default) Neumann partial_n u = 0 Slip walls, symmetry","category":"section"},{"location":"numerical_methods/#Common-Configurations","page":"Numerical Methods","title":"Common Configurations","text":"","category":"section"},{"location":"numerical_methods/#External-Flow-(Wake-Problems)","page":"Numerical Methods","title":"External Flow (Wake Problems)","text":"# Flow past cylinder: inlet + convective outlet + periodic spanwise\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 outletBC = true,\n                 perdir = (2,),\n                 body = AutoBody(sdf))","category":"section"},{"location":"numerical_methods/#Channel-Flow","page":"Numerical Methods","title":"Channel Flow","text":"# Fully-developed channel: periodic streamwise + no-slip walls\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0),\n                 perdir = (1,))  # Periodic in x (streamwise)","category":"section"},{"location":"numerical_methods/#Closed-Cavity","page":"Numerical Methods","title":"Closed Cavity","text":"# Lid-driven cavity: no outlet, no periodic\nsim = Simulation((nx, nz), (Lx, Lz);\n                 inletBC = (U, 0.0))  # Top wall moves at U","category":"section"},{"location":"numerical_methods/#References","page":"Numerical Methods","title":"References","text":"Harlow, F.H. and Welch, J.E. (1965). \"Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface.\" Physics of Fluids, 8(12), 2182-2189.\nWeymouth, G.D. and Yue, D.K.P. (2011). \"Boundary data immersion method for Cartesian-grid simulations of fluid-body interaction problems.\" Journal of Computational Physics, 230(16), 6233-6247.\nOrlanski, I. (1976). \"A simple boundary condition for unbounded hyperbolic flows.\" Journal of Computational Physics, 21(3), 251-269.\nLeonard, B.P. (1979). \"A stable and accurate convective modelling procedure based on quadratic upstream interpolation.\" Computer Methods in Applied Mechanics and Engineering, 19(1), 59-98. (QUICK scheme)\nVan Leer, B. (1979). \"Towards the ultimate conservative difference scheme. V. A second-order sequel to Godunov's method.\" Journal of Computational Physics, 32(1), 101-136. (Van Leer limiter)\nVersteeg, H.K. and Malalasekera, W. (2007). An Introduction to Computational Fluid Dynamics: The Finite Volume Method. Pearson Education.","category":"section"}]
}
